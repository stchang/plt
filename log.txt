--------------------------------------------------------------------------------
----- 6/24/2010 - HOME PC
--------------------------------------------------------------------------------

- dl and install Racket Full 6/24/2010 nightly build
- copied over lazy/info.rkt and lazy/lazy-tool.rkt so stepper button would show up (must run setup-plt to register changes (use -D option, it's doesnt build docs so it's quicker))

Tried to step test program:
(define (f x) (+ 1 x))
(f 10)

Error Message:
annotate/top-level: unexpected top-level expression: (define-values (f) (#%app lazy-proc (lambda (x) (#%app lazy (lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2)))))))))

Solution:
A cond clause seems to have been removed from annotate/top-level in stepper/private/annotate.rkt (it's there on the version in my laptop)
 - no, this was added by me

Added clause: [(define-values (ids ...) bodies) (annotate/module-top-level exp)]



Error Message:
Internal stepper error: time to resync with simple-module-based-language-convert-value

Solution:
cond clause missing in simple-module-based-language-convert-value in stepper/stepper-tool.rkt

Added clause: [(print) value]

(TODO: eventually, I want Lazy Racket to use the 'constructor print style as default, but I havent been able to figure out how to do that yet)


- It works!

Output: 
(define f
  #(struct:lazy-proc
    #<procedure:...ate\annotate.rkt:809:52>))
((#<procedure:parameter-procedure>)
 (let ((p f) (temp6 10))
   (if (if (lazy-proc? p)
         #t
         (struct-constructor-procedure?
          p))
     (p temp6)
     (p temp6))))


- changed print style to 'constructor

Output:
(define f
  |...ate\annotate.rkt:809:52|)
((parameter-procedure)
 (let ((p f) (temp6 10))
   (if (if (lazy-proc? p)
         true
         (struct-constructor-procedure?
          p))
     (p temp6)
     (p temp6))))


- uncommented stepper-skipto annotation in !*app in lazy/lazy.rkt

Output:
(define f
  |...ts\lazy\lazy.rkt:124:48|)
((parameter-procedure)
 (let ((p f) (temp6 10))
   (p temp6)))


- trying to wrap output of ~!%app in lazy/lazy.rkt with stepper-annotate function
 - wrapped around (toplevel?) clause, got error: 
#%plain-app: bad syntax in: (#%plain-app (#%plain-app parameter-procedure) (let-values (((p) f) ((temp6) (quote 10))) (#%app p temp6)))

 - wrapped around else clause, no effect - same as if stepper-annotate wasnt used


Experiment:
- added a test clause in unwinder in ~!%app in lazy/lazy.rkt to see if unwinder gets called - it worked (error gets raised)
test clause: [_ (raise-syntax-error 'hi "testing...")]

- moved test clause to be last clause in unwinder to see if first clause matches - error gets raised again, which means first clause didnt get matched


Experiment:
- trying to move stepper-annotate to !*app in lazy/lazy.rkt - applied stepper-annotate to quasisyntax/loc expr - pattern in unwinder still not matched
- if I remove the raise-syntax-error clause, the error is:
let-values: bad syntax in: (let-values (((p) f) ((temp6) (quote 10))) (#%app p temp6))

Experiment:
- trying to change the pattern in unwinder to match the expression I'm working with (removed stepper-skip-double-break property for now):
(define (unwinder stx rec)
      (syntax-case stx (!)
        [(let-values ([(_p) f] [(_y) x] ...) _body)
         (with-syntax ([(f x ...) (rec #'(f x ...))])
           #'(f x ...))]))

It worked! Output:
(define f
  |...ts\lazy\lazy.rkt:124:48|)
((parameter-procedure) (f 10))
->
(define f
  |...ts\lazy\lazy.rkt:124:48|)
(force (f 10))
->
(define f
  |...ts\lazy\lazy.rkt:124:48|)
(define p_0 f)
(define temp6_0 10)
(force (p_0 temp6_0))
->
(define f
  |...ts\lazy\lazy.rkt:124:48|)
(define p_0
  |...ts\lazy\lazy.rkt:124:48|)
(define temp6_0 10)
(force
 (|...ts\lazy\lazy.rkt:124:48|
  temp6_0))
->
(define f
  |...ts\lazy\lazy.rkt:124:48|)
(define p_0
  |...ts\lazy\lazy.rkt:124:48|)
(define temp6_0 10)
(force
 (|...ts\lazy\lazy.rkt:124:48|
  10))
->
(define f
  |...ts\lazy\lazy.rkt:124:48|)
(define p_0
  |...ts\lazy\lazy.rkt:124:48|)
(define temp6_0 10)
(force
 (...
  (lazy (lambda () (+ 1 10)))
  ...))
->
(define f
  |...ts\lazy\lazy.rkt:124:48|)
(define p_0
  |...ts\lazy\lazy.rkt:124:48|)
(define temp6_0 10)
(force (delay ...))
->
(define f
  |...ts\lazy\lazy.rkt:124:48|)
(define p_0
  |...ts\lazy\lazy.rkt:124:48|)
(define temp6_0 10)
(define p_0 +)
(define temp1_0 1)
(define x2_0 10)
(... (p_0 temp1_0 x2_0) ...)

(13 steps total)



- adding back stepper-skip-double-break property

Output:
(define f
  |...ts\lazy\lazy.rkt:124:48|)
((parameter-procedure) (f 10))
->
(define f
  |...ts\lazy\lazy.rkt:124:48|)
(force (f 10))
->
(define f
  |...ts\lazy\lazy.rkt:124:48|)
(define p_0
  |...ts\lazy\lazy.rkt:124:48|)
(define temp6_0 10)
(force
 (|...ts\lazy\lazy.rkt:124:48|
  temp6_0))
->
(define f
  |...ts\lazy\lazy.rkt:124:48|)
(define p_0
  |...ts\lazy\lazy.rkt:124:48|)
(define temp6_0 10)
(force
 (|...ts\lazy\lazy.rkt:124:48|
  10))

(11 steps total)


TODO tomorrow:
1) read stepper internal docs more carefully
2) reread lazy code and lazy srfi docs


--------------------------------------------------------------------------------
----- 6/25/2010 - HOME PC
--------------------------------------------------------------------------------

- Functions defined with define (ie - (define (f x) (+ x 1)) ) in the Beginner languages are displayed the same way in the Stepper regardless of whether the Output Style in the Choose Language menu is 'constructor or 'quasiquote or 'write

- extended lazy language class (which implements module-based-language<%> - in drracket/private/language.rkt) and overrode default-settings and default-settings? methods so that the default print-style was 'constructor
 - ran setup-plt and stepper prints functions as lambdas with Lazy Racket
 - I tried experimenting with the pretty-print-depth parameter (#f = all depths printed, instead of "...") previously to show the entire lambda but was not successful

Weird behavior:
- when I change something in lazy.rkt and restart DrRacket, fns in the stepper display as line numbers -- (define f |...ts\lazy\lazy.rkt:131:25|) -- but when I re-run setup-plt (both with undoing and not undoing the changes), fns go back to being displayed as lambdas
  - yes this makes sense, because the source of the syntax is in the changed file so you need to recompile to make them show up properly

observation:
- There are two ways to add a property to some syntax (or other similar operations) (is this true?)
 1) use with-syntax
 2) use quasisyntax and escape when calling stepper-syntax-property, etc


Trying to get fns defined with define (and not using lambda) to display properly in stepper:

Experiment: 
- trying to use stepper-define-type stepper-syntax property to do it (Beginner languages use this property)

- doesnt seem to be working
- it works! if I remove the lazy-proc wrapping the lambda (so if I use just lambda instead of ~lambda)

Possible solutions:
1) add case in unwind-define in stepper/private/macro-unwind.rkt for functions that use ~lambda
2) add custom unwinder using stepper-hint like in !*app in lazy/lazy.rkt

TODO tomorrow:
1) finish implementing displaying of fns defined with define (see possible solutions above)

--------------------------------------------------------------------------------
----- 6/28/2010 - LAPTOP
--------------------------------------------------------------------------------

- module-identifier=? in mzscheme is the same as free-identifier=? in racket/base


--------------------------------------------------------------------------------
----- 6/29/2010 - LAPTOP
--------------------------------------------------------------------------------

- somehow, when using the custom unwinder, the body of the lambda gets quoted, but when using unwind-define in stepper/private/macro-unwind.rkt, there is no quote, even though both functions are the same and get they get the same inputs - THIS ISNT QUITE RIGHT, see below
  - finally figured it out! The custom unwinder was using recur-on-pieces (as specified in unwind in stepper/private/macro-unwind.rkt) to recursively unwind the body of the function but unwind-define was using unwind as the recursive call
    - I changed the recursive call in unwind in stepper/private/macro-unwind.rkt to use unwind instead of recur-on-pieces

- the recur-on-pieces doesnt add the quote, it just doesnt get rid of it. the unwind fn has a syntax-case clause in fall-through that gets rid of the quote; I still dont know why adding lazy-proc adds a quote
  - it seems like something funny is happening during annotation of lazy-proc - probably because it's a struct constructor and not a real function, so that the stepper doesnt quite know how to reconstruct it, and so that's why we get the funny results with the quote and the dots
  something like (lazy-proc (lambda (x) (+ 1 x))) is getting annotated and reconstructed as (quote (lambda (a1) ...)) where the quote and the dots are part of the actual output

- the 'stepper-define-type stepper-syntax-property seems to be lost when I add lazy-proc around the lambda


Call Graph: stepper/private/macro-unwind.rkt::unwind

stepper/private/model.rkt
  break:reconstruct-all-completed
  break (not skip-step, normal-break, normal-break/values)
    - applied to results of reconstruct.rkt::reconstruct-left-side
  break (not skip-step, result-exp-break, result-value-break)
    - applied to results of reconstruct.rkt::reconstruct-right-side
  break (not skip-step, double-break)
    - applied to results of reconstruct.rkt::reconstruct-double-break

          |
          V

stepper/private/macro-unwind.rkt::unwind



Call Graph: stepper/private/reconstruct.rkt::reconstruct-current

stepper/private/reconstruct.rkt
  reconstruct-left-side
  reconstruct-right-side
  reconstruct-double-break

          |
          V

stepper/private/reconstruct.rkt::reconstruct-current


- trying now to just use stepper-skipto to skip the lazy-proc application
  - the 'stepper-define-type stepper-syntax-property still seems to be lost when I add lazy-proc around 
    - trying to add the stepper-define-type property around the lazy-proc instead of around the lambda (and hopefully it gets transferred over?)the lambda
      - didnt work


TODO tomorrow:
 - look at stepper/private/reconstruct.rkt::recon-value
   - this is the function that inserts the quote
     1) it's because stepper/private/shared.rkt::closure-table-lookup returns #f
     2) also, the dots comes from render-settings-render-to-sexp, I think?
       - look in stepper/stepper-tool.rkt at stepper:render-to-sexp and simple-module-based-language-convert-value
 - check stepper/private/annotate.rkt::top-level-rewrite to see what kind of label lazy-proc gets (ie - macro-bound, non-lexical, etc)
   - print out stepper-binding-type given by top-level-rewrite for each var case
     - lazy-proc is 'non-lexical
   - labels are used in var (used in varref-abstraction in annotate::annotate/inner



--------------------------------------------------------------------------------
----- 6/30/2010 - LAPTOP
--------------------------------------------------------------------------------

 - stepper/private/annotate.rkt::return-value-wrap - calls return-value-wrap-maker - adds specified breakpoint and deals with multiple values
 - stepper/private/annotate.rkt::break-wrap adds a normal-break
 - annotate/inner::wcm-break-wrap adds a break-wrap to the expr before calling outer-wcm-wrap
 - annotate.rkt::wcm-pre-break-wrap adds pre-break-wrap to expr before calling wcm-wrap (pre-break-app adds result-exp-break)
 - stepper/private/marks.rkt::wcm-wrap makes the standard call to wcm with key 'debug-key

Annotating vars:
 - if var is not lexical but is from current module, add a break; otherwise, dont add a break


Experiment: see what happens if lambdas in lazy racket are wrapped with regular function (defined in module, ie - in lazy.rkt)

1) wrap with fn (define (test-proc x) x) defined in lazy.rkt
 - most things worked
   - using stepper-skipto (append skipto/cdr skipto/second)
   - using kernal-syntax-case* with literal #%app and pattern (#%app xx body) for function body, xx gets bound to 'test-proc
   - works when test-proc is in another file that is required


Experiment: what happens in annotate.rkt::varref-abstraction for various vars
  - interesting, neither test-proc nor f shows up as a parameter to varref-abstraction
    - dump: lazy private/promise.rkt + (quote #%kernel) toplevel-forcer (lib lazy/lazy.rkt)
  - dump is the same when test-proc is replaced with lazy-proc


Experiment: dumping all the exprs that get annotated by stepper/private/annotate.rkt::annotate::annotate/inner (using stepper-skipto for lazy-proc/test-proc)

- when using lazy-proc:
(#%app lazy-proc (lambda (x) (#%app lazy (lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2))))))))

(lambda (x) (#%app lazy (lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2)))))))


(#%app lazy (lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2))))))

lazy

(lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2)))))

(let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2))))

(#%app ! +)
+
(quote 1)
x
(if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2)))
(#%app p temp1 x2)
p
temp1
x2
(#%app p (#%app ! temp1) (#%app ! x2))
p
(#%app ! temp1)
temp1
(#%app ! x2)
x2
(#%app (#%app toplevel-forcer) (let-values (((p) (#%app ! (#%top . f))) ((temp6) (quote 10))) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp6) (#%app p (#%app ! temp6)))))
(#%app toplevel-forcer)
toplevel-forcer
(let-values (((p) (#%app ! (#%top . f))) ((temp6) (quote 10))) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp6)
(#%app p (#%app ! temp6))))
(#%app ! (#%top . f))
(#%top . f)
(quote 10)
(if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp6) (#%app p (#%app ! temp6)))
(#%app p temp6)
p
temp6
(#%app p (#%app ! temp6))
p
(#%app ! temp6)
temp6


when using test-proc (seems to be identical to lazy-proc)

(#%app test-proc (lambda (x) (#%app lazy (lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2))))))))

(lambda (x) (#%app lazy (lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2)))))))

(#%app lazy (lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2))))))

lazy

(lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%appp temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2)))))

(let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2))))

(#%app ! +)
+
(quote 1)
x
(if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2)))
(#%app p temp1 x2)
p
temp1
x2
(#%app p (#%app ! temp1) (#%app ! x2))
p
(#%app ! temp1)
temp1
(#%app ! x2)
x2
(#%app (#%app toplevel-forcer) (let-values (((p) (#%app ! (#%top . f))) ((temp6) (quote 10))) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp6) (#%app p (#%app ! temp6)))))
(#%app toplevel-forcer)
toplevel-forcer
(let-values (((p) (#%app ! (#%top . f))) ((temp6) (quote 10))) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp6) (#%app p (#%app ! temp6))))
(#%app ! (#%top . f))
(#%top . f)
(quote 10)
(if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp6) (#%app p (#%app ! temp6)))
(#%app p temp6)
p
temp6
(#%app p (#%app ! temp6))
p
(#%app ! temp6)
temp6


Experiment: dump of all exprs that get annotated by annotate.rkt:annotate (for my test file that uses lazy racket: (define (f x) (+ x 1)) (f 10)     )

- using lazy-proc

(define-values (f) (#%app lazy-proc (lambda (x) (#%app lazy (lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2)))))))))

(#%app (#%app toplevel-forcer) (let-values (((p) (#%app ! (#%top . f))) ((temp6) (quote 10))) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp6) (#%app p (#%app ! temp6)))))


- using test-proc (seems the same as for lazy-proc except using test-proc)

(define-values (f) (#%app test-proc (lambda (x) (#%app lazy (lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2)))))))))

(#%app (#%app toplevel-forcer) (let-values (((p) (#%app ! (#%top . f))) ((temp6) (quote 10))) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp6) (#%app p (#%app ! temp6)))))





Call graph for annotation of lazy racket (define (f x) (+ x 1))


stepper/private/model.rkt:

go
     |
     V

go::step-through-expression
(annotate break parameter is break fn in model.rkt)
(annotated expr is then eval'ed)

     |
     V

in stepper/private/annotate.rkt:

annotate
(break parameter is break fn in model.rkt)
     |
     V

annotate::annotate/top-level #'(define-values (f) (#%app lazy-proc (lambda (x) (+ x 1))))

     |
     V

annotate::annotate/module-top-level #'(define-values (f) (#%app lazy-proc (lambda (x) (+ x 1))))

     |
     V

annotate::top-level-annotate/inner #'(#%app lazy-proc (lambda (x) (+ x 1)))

     |
     V

annotate::annotate/inner #'(#%app lazy-proc (lambda (x) (+ x 1)))



- displaying syntax->datum of top-level-rewrites for my test code seems to produce no change
  - yes of course this is true, top-level-rewrites only applies stepper-binding-type labels and other stepper-properties





Experiment: dump of exprs given to annotate/inner and the results

----- deleted -----



Experiment: dumping exprs given to annotate/inner, along with associated stepper-properties


- using lazy-proc


(#%app lazy-proc (lambda (x) (#%app lazy (lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2))))))))

((stepper-skipto (syntax-e cdr syntax-e cdr car)))

(lambda (x) (#%app lazy (lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2)))))))

((stepper-proc-define-name #<syntax:C:\Documents and Settings\Stephen Chang\My Documents\plt\sandbox\lazy-expand-test.rkt:1:9 f>) (stepper-define-type shortened
-proc-define))

(#%app lazy (lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2))))))

#f

lazy

((stepper-binding-type non-lexical))

(lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2)))))

#f

(let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2))))

((stepper-skip-double-break #t) (stepper-hint #<procedure:unwinder>))

(#%app ! +)

((stepper-skipto (syntax-e cdr syntax-e cdr car)))

+

((stepper-binding-type non-lexical))

(quote 1)
#f
x
((stepper-binding-type lambda-bound))
(if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2)))

(((stepper-skipto (syntax-e cdr cdr both-l () (car)))) (stepper-skipto (syntax-e cdr cdr both-l () (car))))

(#%app p temp1 x2)
#f
p
((stepper-binding-type let-bound))
temp1
((stepper-binding-type let-bound))
x2
((stepper-binding-type let-bound))
(#%app p (#%app ! temp1) (#%app ! x2))
#f
p
((stepper-binding-type let-bound))
(#%app ! temp1)
((stepper-skipto (syntax-e cdr syntax-e cdr car)))
temp1
((stepper-binding-type let-bound))
(#%app ! x2)
((stepper-skipto (syntax-e cdr syntax-e cdr car)))
x2
((stepper-binding-type let-bound))
(#%app (#%app toplevel-forcer) (let-values (((p) (#%app ! (#%top . f))) ((temp6) (quote 10))) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp6) (#%app p (#%app ! temp6)))))
#f
(#%app toplevel-forcer)
#f
toplevel-forcer
((stepper-binding-type non-lexical))
(let-values (((p) (#%app ! (#%top . f))) ((temp6) (quote 10))) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp6) (#%app p (#%app ! temp6))))
((stepper-skip-double-break #t) (stepper-hint #<procedure:unwinder>))
(#%app ! (#%top . f))
((stepper-skipto (syntax-e cdr syntax-e cdr car)))
(#%top . f)
#f
(quote 10)
#f
(if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp6) (#%app p (#%app ! temp6)))
(((stepper-skipto (syntax-e cdr cdr both-l () (car)))) (stepper-skipto (syntax-e
 cdr cdr both-l () (car))))
(#%app p temp6)
#f
p
((stepper-binding-type let-bound))
temp6
((stepper-binding-type let-bound))
(#%app p (#%app ! temp6))
#f
p
((stepper-binding-type let-bound))
(#%app ! temp6)
((stepper-skipto (syntax-e cdr syntax-e cdr car)))
temp6
((stepper-binding-type let-bound))


- using test-proc

(#%app test-proc (lambda (x) (#%app lazy (lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2))))))))

((stepper-skipto (syntax-e cdr syntax-e cdr car)))

(lambda (x) (#%app lazy (lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2)))))))

((stepper-proc-define-name #<syntax:C:\Documents and Settings\Stephen Chang\My Documents\plt\sandbox\lazy-expand-test.rkt:1:9 f>) (stepper-define-type shortened-proc-define))

(#%app lazy (lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2))))))

#f

lazy

((stepper-binding-type non-lexical))

(lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2)))))


#f

(let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2))))


((stepper-skip-double-break #t) (stepper-hint #<procedure:unwinder>))

(#%app ! +)
((stepper-skipto (syntax-e cdr syntax-e cdr car)))
+
((stepper-binding-type non-lexical))
(quote 1)
#f
x
((stepper-binding-type lambda-bound))
(if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p))
 (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2)))
(((stepper-skipto (syntax-e cdr cdr both-l () (car)))) (stepper-skipto (syntax-e
 cdr cdr both-l () (car))))
(#%app p temp1 x2)
#f
p
((stepper-binding-type let-bound))
temp1
((stepper-binding-type let-bound))
x2
((stepper-binding-type let-bound))
(#%app p (#%app ! temp1) (#%app ! x2))
#f
p
((stepper-binding-type let-bound))
(#%app ! temp1)
((stepper-skipto (syntax-e cdr syntax-e cdr car)))
temp1
((stepper-binding-type let-bound))
(#%app ! x2)
((stepper-skipto (syntax-e cdr syntax-e cdr car)))
x2
((stepper-binding-type let-bound))
(#%app (#%app toplevel-forcer) (let-values (((p) (#%app ! (#%top . f))) ((temp6)
 (quote 10))) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-
procedure? p)) (#%app p temp6) (#%app p (#%app ! temp6)))))
#f
(#%app toplevel-forcer)
#f
toplevel-forcer
((stepper-binding-type non-lexical))
(let-values (((p) (#%app ! (#%top . f))) ((temp6) (quote 10))) (if (if (#%app la
zy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp6)
(#%app p (#%app ! temp6))))
((stepper-skip-double-break #t) (stepper-hint #<procedure:unwinder>))
(#%app ! (#%top . f))
((stepper-skipto (syntax-e cdr syntax-e cdr car)))
(#%top . f)
#f
(quote 10)
#f
(if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p))
 (#%app p temp6) (#%app p (#%app ! temp6)))
(((stepper-skipto (syntax-e cdr cdr both-l () (car)))) (stepper-skipto (syntax-e
 cdr cdr both-l () (car))))
(#%app p temp6)
#f
p
((stepper-binding-type let-bound))
temp6
((stepper-binding-type let-bound))
(#%app p (#%app ! temp6))
#f
p
((stepper-binding-type let-bound))
(#%app ! temp6)
((stepper-skipto (syntax-e cdr syntax-e cdr car)))
temp6
((stepper-binding-type let-bound))





Structure of annotate function:

annotate
    normal-break
    result-exp-break
    result-value-break
    normal-break/values
    exp-finished-break
    double-break
    wcm-pre-break-wrap
    pre-break-wrap
    break-wrap
    double-break-wrap
    return-value-wrap
    normal-break/values-wrap
    top-level-annotate/inner

    annotate/inner
        cond skipto or skipto/discard
             skip-completely
             else let:

        tail-recur
        non-tail-recur
        result-recur
        lambda-body-recur
        make-debug-info-normal
        make-debug-info-app
        outer-wcm-wrap
        wcm-break-wrap
        lambda-clause-abstraction
        outer-lambda-abstraction
        let-abstraction
        if-abstraction
        varref-abraction
        recertifier
        maybe-final-val-wrap

        kernel-syntax-case
            (#%plain-lambda . clause)
            (case-lambda . clauses)
            (if test then else)
            (begin . bodies-stx)
            (begin0 body)
            (begin0 first-body . bodies-stx)
            (let-values . _)
            (letrec-values . _)
            (set! var val)
            (quote _)
            (quote-syntax _)
            (with-continuation-mark key mark body)
            (#%plain-app . terms)
            (#%top . var-stx)
            var-stx
            else
    annotate/top-level
    annotate/module-top-level




Experiment: dump of clause, annotated clause, and free-varrefs in #%plain-lambda case of kernal-syntax in annotate/inner

----- deleted -----
see dump-annotate.rkt-annotateinner-plainlambda-lazy-proc.txt




Experiment: checking out what is happening outer lambda abstraction (only place where closure-table-put! gets called)
 - for both lazy-proc and test-proc, show-lambdas-as-lambdas = #t, procedure-name-info = #f and f (symbol f, not false), and closure-name = #f
 - i'm starting to think the problem is not in the annotation code



Experiment: dump of vals given to recon-value
  - when test-proc is used, body of lambda seems to be processed (evidenced by the 1), but body is not processed when lazy-proc is used (no 1)

----- deleted -----
see dump-reconstruct.rkt-revonvalue-val-closurerecord-lazy-proc.txt



TODO for tomorrow: 
 - look at how lambdas are reconstructed for both lazy-proc and test-proc - start in recon-value function?


--------------------------------------------------------------------------------
----- 7/1/2010 - LAPTOP
--------------------------------------------------------------------------------

Experiment: dump of vars given to stepper/private/reconstruct.rkt::recon-source-expr

 - using test-proc:
lazy + x p temp1 x2 p temp1 x2 p temp6 p temp6 lazy + x p temp1 x2 p temp1 x2 p
temp6 p temp6 lazy + x p temp1 x2 p temp1 x2 lazy + x p temp1 x2 p temp1 x2 lazy
 + x p temp1 x2 p temp1 x2 p temp6 lazy + x p temp1 x2 p temp1 x2 lazy + x p tem
p1 x2 p temp1 x2 lazy + x p temp1 x2 p temp1 x2 temp6 lazy + x p temp1 x2 p temp
1 x2 lazy + x p temp1 x2 p temp1 x2 temp6 lazy + x p temp1 x2 p temp1 x2 lazy +
x p temp1 x2 p temp1 x2 lazy + x p temp1 x2 p temp1 x2 lazy + x p temp1 x2 p tem
p1 x2 lazy + x p temp1 x2 p temp1 x2 lazy + x p temp1 x2 p temp1 x2 lazy + x p t
emp1 x2 p temp1 x2 lazy + x p temp1 x2 p temp1 x2 lazy + x p temp1 x2 p temp1 x2
 lazy + x p temp1 x2 p temp1 x2 lazy + x p temp1 x2 p temp1 x2 lazy + x p temp1
x2 p temp1 x2 p temp1 x2 lazy + x p temp1 x2 p temp1 x2 lazy + x p temp1 x2 p te
mp1 x2 temp1 x2 lazy + x p temp1 x2 p temp1 x2 lazy + x p temp1 x2 p temp1 x2 te
mp1 x2 lazy + x p temp1 x2 p temp1 x2 lazy + x p temp1 x2 p temp1 x2 x2 lazy + x
 p temp1 x2 p temp1 x2 lazy + x p temp1 x2 p temp1 x2 x2 lazy + x p temp1 x2 p t
emp1 x2 lazy + x p temp1 x2 p temp1 x2 lazy + x p temp1 x2 p temp1 x2 lazy + x p
 temp1 x2 p temp1 x2 lazy + x p temp1 x2 p temp1 x2 lazy + x p temp1 x2 p temp1
x2 lazy + x p temp1 x2 p temp1 x2 lazy + x p temp1 x2 p temp1 x2

 - using lazy-proc:
p temp6 p temp6 p temp6 p temp6 p temp6 temp6 temp6 lazy + x p temp1 x2 p temp1
x2 p temp1 x2 temp1 x2 temp1 x2 x2 x2



Experiment: dump of free-vars-captured after annotation in annotate/inner

- with lazy-proc:
(#<syntax:C:\Documents and Settings\Stephen Chang\My Documents\plt\sandbox\lazy-
expand-test.rkt:1:15 +>)
(#<syntax temp1>)
(#<syntax x2>)
(#<syntax:C:\Program Files\Racket-Full-5.0.0.1\collects\lazy\lazy.rkt:326:50 p>
#<syntax temp1> #<syntax x2>)
(#<syntax lazy> #<syntax:C:\Documents and Settings\Stephen Chang\My Documents\pl
t\sandbox\lazy-expand-test.rkt:1:15 +>)
(#<syntax:C:\Documents and Settings\Stephen Chang\My Documents\plt\sandbox\lazy-
expand-test.rkt:3:1 f>)
(#<syntax temp6>)
(#<syntax:C:\Program Files\Racket-Full-5.0.0.1\collects\lazy\lazy.rkt:326:50 p>
#<syntax temp6>)

- with test-proc
(#<syntax:C:\Documents and Settings\Stephen Chang\My Documents\plt\sandbox\lazy-
expand-test.rkt:1:15 +>)
(#<syntax temp1>)
(#<syntax x2>)
(#<syntax:C:\Program Files\Racket-Full-5.0.0.1\collects\lazy\lazy.rkt:326:50 p>
#<syntax temp1> #<syntax x2>)
(#<syntax lazy> #<syntax:C:\Documents and Settings\Stephen Chang\My Documents\pl
t\sandbox\lazy-expand-test.rkt:1:15 +>)
(#<syntax:C:\Documents and Settings\Stephen Chang\My Documents\plt\sandbox\lazy-
expand-test.rkt:3:1 f>)
(#<syntax temp6>)
(#<syntax:C:\Program Files\Racket-Full-5.0.0.1\collects\lazy\lazy.rkt:326:50 p>
#<syntax temp6>)



Experiment: dump of annotate.rkt::top-level-rewrite labels for all variables

 - with test-proc:
#%app non-lexical test-proc non-lexical lambda non-lexical x lambda-bound #%app
non-lexical lazy non-lexical lambda non-lexical p let-bound temp1 let-bound x2 l
et-bound #%app non-lexical ! non-lexical + non-lexical quote non-lexical x lambd
a-bound if non-lexical if non-lexical #%app non-lexical lazy-proc? non-lexical p
 let-bound quote non-lexical #%app non-lexical struct-constructor-procedure? non
-lexical p let-bound #%app non-lexical p let-bound temp1 let-bound x2 let-bound
#%app non-lexical p let-bound #%app non-lexical ! non-lexical temp1 let-bound #%
app non-lexical ! non-lexical x2 let-bound 

 - with lazy-proc:
#%app non-lexical lazy-proc non-lexical lambda non-lexical x lambda-bound #%app
non-lexical lazy non-lexical lambda non-lexical p let-bound temp1 let-bound x2 l
et-bound #%app non-lexical ! non-lexical + non-lexical quote non-lexical x lambd
a-bound if non-lexical if non-lexical #%app non-lexical lazy-proc? non-lexical p
 let-bound quote non-lexical #%app non-lexical struct-constructor-procedure? non
-lexical p let-bound #%app non-lexical p let-bound temp1 let-bound x2 let-bound
#%app non-lexical p let-bound #%app non-lexical ! non-lexical temp1 let-bound #%
app non-lexical ! non-lexical x2 let-bound 








TODO for tomorrow:
 - dump stuff in annotate/inner #%plain-app case and make sure everything is same for test-proc and lazy-proc (I did this already for #%plain-lambda case)





Experiment: dump of terms, annotated terms, and free varrefs for #%plain-app case in annotate/inner (outpouts are identical)

----- deleted -----




Experiment: dump of tail-args in #%plain-app case of annotate/inner (identical)

- using test-proc
all
all
all
(#<syntax arg0-1733>)
(#<syntax:C:\Program Files\Racket-Full-5.0.0.1\collects\lazy\lazy.rkt:329:22 p>
#<syntax temp6> #<syntax arg0-1733> #<syntax arg1-1734>)
(#<syntax:C:\Program Files\Racket-Full-5.0.0.1\collects\lazy\lazy.rkt:329:22 p>
#<syntax temp6> #<syntax arg0-1733> #<syntax arg1-1734>)
all

- using lazy-proc
all
all
all
(#<syntax arg0-1733>)
(#<syntax:C:\Program Files\Racket-Full-5.0.0.1\collects\lazy\lazy.rkt:329:22 p>
#<syntax temp6> #<syntax arg0-1733> #<syntax arg1-1734>)
(#<syntax:C:\Program Files\Racket-Full-5.0.0.1\collects\lazy\lazy.rkt:329:22 p>
#<syntax temp6> #<syntax arg0-1733> #<syntax arg1-1734>)
all



Tentative conclusion - annotated programs are the same whether using lazy-proc or test-proc; reconstruction seems different though

TODO: find where reconstruction differs



reconstruction call graph


files in stepper/private

model.rkt::go::break

     |
     V

reconstruct.rkt::
reconstruct-left-side (normal-break, normal-break/values)
reconstruct-right-side (result-exp-break, result-value-break)
reconstruct-double-break (double-break)

     |
     V

reconstruct-current


     |
     V

(left-side)
recon-value
reconstruct-current::recon

(right-side)
recon-value or recon-source-expr
reconstruct-current::recon

(double-break)
recon-source-expr
reconstruct-current::recon

     |
     V

reconstruct-current::recon calls either
  reconstruct-top-level or
  reconstruct-current::recon-inner

Structure of stepper/private/reconstruct.rkt

recon-value
skip-step?
skip-redex-step?
recon-source-expr
- calls skipto/auto with 'discard and the following transformer fn
    recur
    let-recur
    recon-basic
    recon-let/rec
    recon-lambda-clause
    kernel-syntax-case
        (#%plain-lambda . clause-stx)
        (case-lambda . clauses-stx)
        (if test then else)
        (it test then)
        (begin . bodies)
        (begin0 . bodies)
        (let-values . rest)
        (letrec-values . rest)
        (set! var rhs)
        (quote body)
        (with-continuation-mark . rest)
        (#%plain-app . terms)
        var-stx
        (#%top . var)
reconstruct-completed
reconstruct-top-level
reconstruct-left-side
reconstruct-right-side
reconstruct-double-break
reconstruct-current
    recon-inner
        recon-source-current-marks
        iota
        recon-let
        kernel-syntax-case
            id
            (#%top . id)
            (#%plain-app . terms)
            (if test then else)
            (if test then)
            (begin . terms)
            (begin0 body)
            (begin0 first-body . rest-bodies)
            (let-values . rest)
            (letrec-values . rest)
            (set! var rhs)
    recon



Experiment: dumping closure-records in recon-value in reconstruct.rkt

 - using lazy-proc
 - using test-proc
 - everything seems to be a closure-record (no #f's)

Experiment: dumping base-names of closure-records in recon-value in reconstruct.rkt
 - weird, nothing printed from the true branch of if closure-records, even though in the previous experiment, everythings was showing as a closure-record
    - because closure-record is also a function - needed to use let*
 - trying to print something in the false branch of if closure-records (the rendered)
    - it seems like where test-proc has 1, lazy-proc has lazy.rkt:206:19 (which is the start of the (lambda ...) expr


----- deleted -----
see dump-reconstruct.rkt-revonvalue-val-closurerecord-lazy-proc.txt



Continuation Marks creation call graph:

stepper/private/marks.rkt::

make-debug-info

     |
     V

make-full-mark


     |
     V

make-make-full-mark-varargs

     |
     V

make-full-mark-struct
(define-struct full-mark-struct (source label bindings values))


--------------------------------------------------------------------------------
----- 7/2/2010 - LAPTOP
--------------------------------------------------------------------------------

Experiment: all keys added to closure table

- using lazy-proc:
#<procedure:...ts\lazy\lazy.rkt:207:19>
#<procedure:...ts\lazy\lazy.rkt:339:29>

- using test-proc
#<procedure:...ts\lazy\lazy.rkt:207:19>
#<procedure:...ts\lazy\lazy.rkt:339:29>




lookup-binding call graph:

stepper/private/

reconstruct.rkt::(various functions)

     |
     V

marks.rkt::

lookup-binding.rkt

     |
     V

lookup-first-binding

     |
     V

lookup-all-bindings
(for all marks, returns list of binding-value pairs where binding matches specified binding)
     |
     V

binding-matches
(for one mark, returns list of binding-value pairs where binding matches specified binding)
     |
     V

mark-bindings
(returns list of binding-value pairs)
     |
     V

full-mark-struct-bindings
full-mark-struct-values	



--------------------------------------------------------------------------------
----- 7/3/2010 - LAPTOP
--------------------------------------------------------------------------------


Call Graph - making a mark:

stepper/private/annotate.rkt::annotate:annotate/inner::
make-debug-info-normal (called by normal-bundle, if-abstraction, varref-abstraction, annotate/inner)
make-debug-info-app (outer-lambda-abstraction, annotate/inner)
make-debug-info-let (let-abstraction)
make-debug-info-fake-exp (let-abstraction)
make-debug-info-fake-exp/tail-bound (annotate/inner

     |
     V

stepper/private/marks.rkt::

make-debug-info
  source tail-bound free-vars label lifting

     |
     V

make-full-mark
  source label bindings
(creates syntax of a thunk where body is app:
   ( (make-make-full-mark-varargs source label bindings) 
     (map make-mark-binding-stx bindings) )

     | (when thunk is forced)           |
     V                                  V

make-make-full-mark-varargs      make-mark-binding-stx
  source label bindings
     |
     V

make-full-mark-struct
  source label bindings values
  (values is arg of lambda)



- lambda and lambda wrapped with lazy-proc print as the same!
  (see lazy-proc-print-test.rkt)

- if I apply the following fn to val before giving it to closure-table-lookup (this is in recon-value in reconstruct.rkt), then the function displays properly!

(lambda (val) 
    (if (procedure? val)
        (let ([targ (procedure-extract-target val)])
            (if targ
                targ
                val))
        val))


some various notes:
- equal-hash-code generates hash code for hash table entries
- struct procedures (ie - lambdas wrapped with lazy-proc) return #f when given to struct? - this seems counterintuitive



--------------------------------------------------------------------------------
----- 7/5/2010 - LAPTOP
--------------------------------------------------------------------------------

- download and install Racket Full 5.0.0.6 7/5/2010 build
 - note cant have "info" in any files with .rkt extension? - I had "copy of info.rkt" and it was messing things up so that stepper button wasnt showing up?
 - actually I think the problem was that the copied info.rkt file had a previous date and wasnt getting compiled - need to delete info compiled files (.zo and .dep) to get stepper button to show up
 
 - copied over info.rkt and lazy-tool.rkt to lazy/ and deleted info.zo and info.dep compiled files
 - ran setup-plt -D
 - copied over define-values case in annotate/top-level in annotate.rkt
 - copied over change to ~define and !*app in lazy.rkt
 - copied change to recon-value in reconstruct.rkt so struct wrapped procedures are extracted



Summary of changes to displaying fns defined with define in lazy racket:
 - changed displaying of this program (define (f x) (+ x 1))

from:

(define f (lambda (a1) ...))

to:

(define (f x)
  (lazy (lambda () (+ 1 x))))

- notes about this
 - dont actually need custom unwinder in ~define
 - therefore, dont need to change unwind in macro-unwind.rkt to use unwind instead of recur-on-pieces


Test program expansion:

running:

mzc --expand "\Documents and Settings\Stephen Chang\My Documents\plt\sandbox\lazy-expand-test.rkt"


on: 
(module test lazy  
  (define (f x) (+ 1 x))
  (f 10)
)

gives:

(module test lazy
  (#%plain-module-begin
   (#%require (for-syntax scheme/mzscheme))
   (define-values
    (f)
    (#%app
     lazy-proc
     (lambda (x)
       (#%app
        lazy
        (lambda ()
          (let-values (((p) (#%app ! +)) ((temp1) '1) ((x2) x))
            (if (if (#%app lazy-proc? p)
                  '#t
                  (#%app struct-constructor-procedure? p))
              (#%app p temp1 x2)
              (#%app p (#%app ! temp1) (#%app ! x2)))))))))
   (#%app
    (#%app toplevel-forcer)
    (let-values (((p) (#%app ! f)) ((temp3) '10))
      (if (if (#%app lazy-proc? p) '#t (#%app struct-constructor-procedure? p))
        (#%app p temp3)
        (#%app p (#%app ! temp3)))))))


Stepper steps: see stepper_steps_2010-07-05.txt for test-program1


TODO tomorrow: learn more about what stepper-skipto and skipto/auto are doing

--------------------------------------------------------------------------------
----- 7/6/2010 - LAPTOP
--------------------------------------------------------------------------------

- stepper-recertify in annotate.rkt calls syntax-recertify, which copies certificates from old syntax to a new target syntax


ToDo ToTry: expand beginner program with local - annotation of local may give hints on how to hide defines that are the result of lets in lazy racket?

- tried to annotate the toplevel case in ~!%app in lazy.rkt with 'stepper-skipto (append skipto/cdr skipto/second), but I got an error in find-special-value in reconstruct.rkt
 - hit the error case because the operand of the app wasnt another app
 - find-special-value is called by reset-special-values with name = 'list and valid-args = '(3)
 - somehow this expression (in find-special-value in reconstruct.rkt):
(expand (cons name valid-args)) = (expand (cons 'list '(3)))
expands to: 
(#%app (#%app toplevel-forcer) (let-values (((p) (#%app ! list)) ((temp3) (quote 3))) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp3) (#%app p (#%app ! temp3)))))
    - ok I guess this makes sense, it's the lazy expansion of (list 3)

 - reset-special-values is called in break in model.rkt as part of the "iter" lambda parameter to program-expander (break is local fn in go in model.rkt and program-expander is parameter to go)
 - reset-special-values sets two global variables: special-list-value and special-cons-value

Solution: added extra case to find-special-value (in reconstruct.rkt) to handle lazy-racket case and the annotation worked!!!
 - I needed to get rid of the double-break annotation in !*app, otherwise the first step would not show up at all




Call Graph: Stepper

stepper/

stepper-tool.rkt::stepper-unit-frame-mixin::stepper-button-callback

     |
     V

view-controller.rkt::go
 - called with current frame and stepper-tool.rkt::stepper-unit-frame-mixin::program-expander params

     |
     V

private/model.rkt::go
 - called with view-controller.rkt::go::program-expander-prime as param, which just wraps init param of stepper-tool.rkt::stepper-unit-frame-mixin::program-expander with custodian (iter param is not changed)

     |
     V

view-controller.rkt::go::program-expander-prime

     |
     V

stepper-tool.rkt::stepper-unit-frame-mixin::program-expander




Control Flow: iter parameter of stepper-tool.rkt::stepper-unit-frame-mixin::program-expander:
(created by stepper/private/model.rkt::go)

(lambda (expanded continue-thunk)
     (r:reset-special-values)
     (if (eof-object? expanded)
         (begin
           (receive-result (make-finished-stepping)))
         (step-through-expression expanded continue-thunk)))

- follows call graph above until given as param to:

drscheme:eval:expand-program

from racket help:

The first argument to iter is the expanded program (represented as syntax) or eof. The iter argument is called for each expression in the expanded program and once more with eof, unless an error is raised during expansion. It is called from the user’s thread. If an exception is raised during expansion of the user’s program, iter is not called. Consider setting the exception-handler during init  to handle this situation.

The second argument to iter is a thunk that continues expanding the rest of the contents of the definitions window. If the first argument to iter was eof, this argument is just the primitive void.


--------------------------------------------------------------------------------
----- 7/7/2010 - LAPTOP
--------------------------------------------------------------------------------

Next Task:

!*app in lazy.rkt introduces a let, but lets evaluate to a series of defines. In the lazy stepper, I want to hide these defines

ie - (let ([x ...] [y ...] ...) body) steps to (define x ...) (define y ...) ... body

- I think I will need to add a case to top-level-rewrite in annotate.rkt so identify when the defines come from a lazy racket introduced let, because it's not possible to annotate macros not in lazy racket (for a somewhat similar example, see cond in the beginner language and how it's handled in top-level-rewrite - it needs to check 'origin syntax-property and then uses 'comes-from-cond stepper-hint)

Where are the series of defines coming from?
 - unwind-define converts a define-values to a define (for non-lambda rhs)
 - they must be coming from the eval of the let?


TODO tomorrow:
 - figure out exactly what happens (ie - sequence of fn calls - from annotation to reconstruction) when the stepper "takes a step"
 - is there any way for the stepper to preserve stepper properties across a step?


--------------------------------------------------------------------------------
----- 7/8/2010 - LAPTOP
--------------------------------------------------------------------------------


Call Graph: what happens when stepper takes a step

files in stepper/

- private/model.rkt::go calls program-expander in stepper-tool.rkt with init and iter fns

- stepper-tool.rkt::stepper-unit-frame-mixin::program-expander calls drracket:eval:expand-program with iter

- iter is invoked once per (expanded) expression in def window
  - for test program, iter is called twice, once for f fn def and once for app of f

- iter calls private/model.rkt::go::step-through-expression with each expanded expr

- step-through-expression annotates given expr, evals it, and then evals the thunk that was given by drracket:eval:expand-program (to get to the other exprs in the def window)

expr #1

- the annotated f def looks like:
    (begin <annotated f fn def>
           (exp-finished-break (list (list (lambda () exp) 
                                           #f 
                                           (lambda () (list f))))))
   where exp is the unannotated expanded def of f

- annotate.rkt::annotate::exp-finished-break calls model.rkt::go::break with params:
    mark-set = #f
    break-find = 'exp-finished-break
    returned-value-list = (list (list (lambda () exp) #f (lambda () (list f))))

- when break-find is 'exp-finished-break, break applies add-to-finished to each element of returned-value-list

- add-to-finished appends (list (list (lambda () exp) #f (lambda () (list f)))) to the end of finished-exps, where
    exp-thunk = (lambda () exp)
    index = #f
    getter = (lambda () (list f))

- finished-exps used by model.rkt::go::break::reconstruct-all-completed
   - forces source thunk
   - checks if thunk has stepper-hide-completed property
   - if not, calls reconstruct.rkt::reconstruct-completed withed the forced source exp
   - depending on result of reconstruct-completed, calls macro-unwind.rkt::unwind

- reconstruct-all-completed used by model.rkt::go::break


expr #2
- annotated (f 10) first calls annotate.rkt::annotate::double-break, which calls break with current-continuation-marks and break-kind = 'double-break
  - there is a double break beause the expanded expr is a let-values and double-breaks always occur at the beginning of a let evaluation

- in the double-break case of break:
  - call reconstruct-all-completed (but finished-exps is still empty here???)
    - ok i think it's just here in case there's something, so we can append to it
  - call reconstruct.rkt::reconstruct-double-break with the mark-list, which calls reconstruct-current with break-kind = 'double-break
  - in the double-break case of reconstruct-current:
    - call recon-source-expr with car of mark-list, both with and without bindings (assuming car of mark-list is let) from let
      - when recon-source-expr is called with bindings, add stepper-lifted-name property to those bindings???
    - call recon with both versions the recon'ed car of mark-list (and rest of mark-list) and return as list of two elements
      - the first param of recon accumulates the marks recon'ed so far
      - recon just iterates over the rest of the (unreconstructed) mark-list, calling either reconstruct-top-level or reconstruct-current::recon-inner, depending on the label in the mark
  - unwind elements of 2 element returned list and use first as lhs and second as rhs
  - make append unwound elements to previous finished-exp and create make-before-after-result and give to receive-result, which is parameter of model.rkt::go (2nd param)
    - the fn given by view-controller.rkt::go is view-controller.rkt::go::hand-off


- expr #2 then sets from variables (see comments in annotate.rkt::annotate::annotate/inner::let-abstraction)

- then calls exp-finished-break with some variables

- the rest of the expression is annotated using with-continuation mark where the body of the wcm has the structure:

(begin (normal-break) 
       (result-value-break <some-variable>))


TODO tomorrow:
 - figure out how a let gets transformed into a series of defines
 - check out what happens in break when break-kind is 'normal-break and when break-kind is 'result-value-break
 - want to somehow annotate after a step
   - idea: annotate "left side" and transfer to "right side"
   - see double-break case in model.rkt::go::break



--------------------------------------------------------------------------------
----- 7/26-27/2010 - LAPTOP
--------------------------------------------------------------------------------


- difference between a "values" break and a regular break (ie - result-exp-break vs result-value-break, and normal-break vs normal-break/values) is the "values" break passes an additional "vals-list" param to break
  - the "vals-list" param is the result of evaluating the exp around which the break is wrapped

BREAK TYPE (FN NAME)  | WRAP FN NAME
----------------------------------------------------
normal-break          | break-wrap*
normal-break/values   | normal-break/values-wrap**
result-exp-break      | pre-break-wrap*
result-value-break    | return-value-wrap**
expr-finished-break / | make-define-struct-break***
exp-finished-break    |
double-break          | double-break-wrap*

* = (begin (break-fn) exp)
** = (call-with-values 
       (lambda () exp)
       (lambda (args)
         (break-fn args)
         (values args)))
*** = returns thunk with call to break and 'expr-finished-break break type (marks = #f)

wcm-wrap in marks.rkt:
(define (wcm-wrap marks expr)
  (wcm debug-key marks expr))

wcm-pre-break-wrap in annotate.rkt:
 - like wcm-wrap except wraps pre-break-wrap around exp

outer-wcm-wrap in annotate.rkt::annotate/inner:
 - gets set to wcm-pre-break-wrap if pre-break? = #t
 - gets set to wcm-wrap           if pre-break? = #f

wcm-break-wrap in annotate.rkt::annotate/inner:
 - like wcm-wrap except uses outer-wcm-wrap and wraps break-wrap around exp



- pre-break? in annotate/inner is #t in tail-recur and lambda-body-recur



--------- When are each of the break types used (in annotate/inner)? ----------
normal-break
- used by break-wrap, wcm-break-wrap
- used in #%plain-app case
- used in begin0 case
- used in varref-abstraction, var-stx case


normal-break/values
- used by normal-break/values-wrap
- used in let-abstraction, let-values, letrec-values case


result-exp-break
- used by pre-break-wrap, wcm-pre-break-wrap, and sometimes wcm-break-wrap (when pre-break = #t)
- used in let-abstraction (if outermost? = #f, ie - if not first expr in body)
- used in begin0 case (if not first-time?, ie - not first expr in begin)
wcm-break-wrap used in:
- used in varref-abstraction, in varref-break-wrap and top-level-varref-break-wrap
- used in begin0 case
outer-wcm-wrap used in (always as outer wrap):
- let-abstraction
- if-abstraction
- varref-abstraction, varref-no-break-wrap
- set! case
- #%plain-app case



result-value-break
- used by return-value-wrap
- wrapped around the var in varref-break-wrap
- used in set! case
- used in let-body of #%plain-app case


expr-finished-break
- used by exp-finished-break, make-define-struct-break
- used in annotate/module-top-level when there is a stepper-define-struct-hint property
- used in let-abstraction
- used in maybe-final-val-wrap, when there is 'stepper-use-val-as-final property
- in define-values case in annotate/module-top-level


double-break
- used by-double-break-wrap
- used in let-abstraction



--------- What does model.rkt::go::break do? ----------

- what does reconstruct-all-completed do?
for each expr in finished-exps:
1) forces thunk
2) calls reconstruct.rkt::reconstruct-completed
3) unwinds
-) skips expr if it has stepper-hide-completed property


- held-exp-list contains lhs exprs
  - gets init to the-no-sexp



- then it depends on BREAK TYPE:

--- normal-break, normal-break/values ---
1) set held-finished-list to result of reconstruct-all-completed
2) call reconstruct.rkt::reconstruct-left-side with mark list and returned-value-list
3) lifts result
4) unwind
5) stores result in held-exp-list



--- result-exp-break, result-value-break ---
1) create thunk for rhs:
  a) call reconstruct.rkt::reconstruct-right-side with mark list and returned-value-list
  b) lifts result
  c) unwind
2a) if held-exp-list is skipped step, reset it to the-no-sexp
2b) if held-exp-list is the-no-sexp, call send-result with before-after-result where before is result of reconstruct-all-completed, and after is result of forcing rhs thunk
2c) if held-exp-list is some held exps:
  a) add held-exps to end of held-finished-list and use as lhs
  b) add result of forcing rhs thunk to result of reconstruct-all-completed and use as rhs
  c) send result (resets held-exp-list to the-no-sexp)



--- double-break ---
- held-exp-list should be the-no-sexp
1) call reconstruct.rkt::reconstruct-double-break with mark list to get pair of exprs
2) lift 1st of pair and unwind and use as lhs
3) lift 2nd of pair and unwind and use as rhs
4) add lhs to end of reconstruct-all-completed and rhs to end of reconstruct-all-completed and send result



--- expr-finished-break ---
for each expr in returned-value-list:
1) add to finished-exps




- reconstruct-left-side, -right-side, and -double-break call reconstruct.rkt::reconstruct-current with either 'left-side, 'right-side, or 'double-break as the "break kind" (in addition to the mark-list and return-value-list)


---------- what does reconstruct-current do? ---------

- recon-inner
- recon

--- left-side ---
1) if return-value-list exists (break was normal-break/values)
  a) call recon-value on 1st element of return-value-list (there should be only 1 value)
  b) otherwise use nothing-so-far as the result
2) call recon with that result and mark list


--- right-side ---
1) if return-value-list exists (break was result-value-break)
  a) call recon-value on 1st element of return-value-list (there should be only 1 value)
  b) otherwise call recon-source-expr with the first expr in mark list and entire mark list
2) mark that result as highlight
3) call recon with that result and rest of mark list



--- double-break ---
1) call recon-source-expr with first expr in mark list (should be let) (and entire mark list)
2) mark result as highlight
3) call recon with result and rest of mark list

4) call recon-source-expr with first expr in mark list (should be let) (and entire mark list) and vars from let
5) mark result as highlight
6) call recon with result and rest of mark list

7) return two results as pair




TODO tomorrow: 
- add more fine-grained descriptions of when each break type is used
- check what recon-value, recon (in reconstruct-current), recon-source-expr, and reconstruct-completed do?




--------------------------------------------------------------------------------
----- 7/28/2010 - LAPTOP
--------------------------------------------------------------------------------


- in annotate.rkt::annotate/inner::let-abstraction, shared.rkt::get-lifted-var is called once for each var bound by the let
  - lifted vars look something like lifted-x-#, where x is the original name of the variable and # is an index that gets incremented every time get-lifted-var is called


---------- What does reconstruct.rkt::reconstruct-completed do? ----------
1a) turns variables and value(s) into a define
1b) handles stepper-define-struct-hint
1c) handles stepper-use-val-as-final
1d) o.w. uses vals-getter



---------- What does reconstruct.rkt::recon-value do? ----------
if val is closure
  then look it up in closure table and call recon-source-expr
  else render it using print-convert



---------- What does reconstruct.rkt::recon-source-expr do? ----------
- uses skipto/auto




---------- What does reconstruct.rkt::reconstruct-current::recon do? ----------




TODO tomorrow:
- figure out how to hide defines that get generated from let in lazy app
- fix body of the let to not use vars bound by let
- you've identified when a let comes from lazy racket, now wrap the defines that come from the let with stepper-skip-completely






--------------------------------------------------------------------------------
----- 7/29/2010 - LAPTOP
--------------------------------------------------------------------------------


- added 'comes-from-lazy case in reconstruct.rkt::hide-completed? (called by model.rkt::go::break::reconstruct-all-completed)

- in, annotate.rkt::annotate/inner::let-abstraction, add 'comes-from-lazy = #t stepper-syntax-property, to let clauses in exp-finished-clauses
  - TODO: add check to only add this property if original stx had it 
      - DONE 7/30/2010





TODO tomorrow:
- figure out how application gets annotated
  - I suspect it gets annotated as a sequence of partially evaluated steps, where one more subterm gets evaluated at each step
- also look at how app gets reconstructed
- add check in annotate.rkt::annotate/inner:let-abstraction to only add 'comes-from-lazy stepper-syntax-property if original let had the property - DONE 7/30/2010





--------------------------------------------------------------------------------
----- 7/30/2010 - LAPTOP
--------------------------------------------------------------------------------

- stepper steps are buffered in an async channel, using async-channel-put, and are retrieved using async-channel-get

- the receive-result param of model.rkt::go converts the received before-and-after result and converts it to a step, and adds to the view-history async-channel, where it gets retrieved by start-listener-thread

- in annotate.rkt::annotate/inner::let-abstraction, add 'comes-from-lazy property to let body (only in bodies length = 1 case)
 - TODO: add check to add this property only if original let (stx param) has it
    - DONE 7/30/2010
 - TODO: add this property to bodies length > 1 case also (just add to first one?)

- added steps-to-skip var in model.rkt::go, used in break to skip over a specified number of steps
example:
if we have the following stepper steps:
0: a -> b
1: b -> c
2: c -> d
3: d -> e

and we want to skip 2 steps starting at 0, then the stepper will display:
0: a -> e


- in lazy.rkt::!*app, we definitely do not want the stepper-skip-double-break property. this way, we can unwind the let directly to get the application to display propertly initially




--------------------------------------------------------------------------------
----- 8/4/2010 - LAPTOP
--------------------------------------------------------------------------------

TODO tommorrow:
- implement find-highlighted-expr fn in model.rkt::go::break
- use find-highlighted-expr instead of entire expr when checking 'comes-from-lazy
  - there exists a find-highlight fn in lifting.rkt



--------------------------------------------------------------------------------
----- 8/4/2010 - LAPTOP
--------------------------------------------------------------------------------

TODO tommorrow:
- body of let in a lazy app is currently annotated with 'comes-from-lazy-app-let-body property
- document steps-to-skip system in model.rkt::go::break
- print marks in all break points in model.rkt::go::break and study them


--------------------------------------------------------------------------------
----- 8/6/2010 - LAPTOP
--------------------------------------------------------------------------------
TODO: unwind-define in lazy.rkt is now same as unwind-define in stepper/private/macro-unwind.rkt, so we can just use the unwind fn in macro-unwind.rkt?

TODO tomorrow:
- in model.rkt::go::break, need to deref exp-breaks as well (right now only normal-breaks are getting derefed)


--------------------------------------------------------------------------------
----- 8/6/2010 - LAPTOP
--------------------------------------------------------------------------------

- IDEA: to address lazy app let issue, why not just annotate the lazy app (which is a let) as an app and throw out the let altogether?
  - ANSWER: can't statically determine whether function is lazy? or not, so dont know which app to use


--------------------------------------------------------------------------------
----- 8/9/2010 - LAPTOP
--------------------------------------------------------------------------------

- in mzlib/pconvert.rkt::print-convert, for promise? case, tried to return (force expr) instead of '(delay ...) when promise has already been forced, ie - promise-forced? = true
  - problem is that promise is being evaluated, ie - promise-running? = true and you can't 
force a running promise; you'll get reentrant error

- changed !*app in lazy.rkt to use application instead of let - this is possible temporary only but I want to see if this is easier to annotate and reconstruct (this was John Clements's idea)

- first step (ie - (f (+ 1 10)) ) gets skipped for some reason, I think it's because the function is a promise, so the first step shown is:

((lambda (x) (+ x x))
 (delay ...))

TODO: figure out how to not hide this step (see above)
 - 8/10/2010 add (not (promise? fun-val)) to #%app case in reconstructk.rkt::skip-redex-step?

TODO: skip one step when app has property 'comes-from-lazy (because of the way I unwind, the before and after in the step looks the same)



--------------------------------------------------------------------------------
----- 8/12/2010 - LAPTOP
--------------------------------------------------------------------------------

annotate/reconstruct notes for lazy racket (lazy.rkt)
- when using 'stepper-skipto, you may not be able to use a custom unwinder if you dont have access to the result
  - for example, if you use 'stepper-skipto on the application of a lazy, the result will look something like (lambda () ...) but lazy racket doesnt have access to the creation of that syntax so you cant attach a custom unwinder.



--------------------------------------------------------------------------------
----- 8/13/2010 - LAPTOP
--------------------------------------------------------------------------------
- temporarily undoing some changes to lazy racket annotation:
 ) in reconstruct.rkt::recon-inner, undo hiding of ellipses for app with 'dont-use-ellipses property
 ) in reconstruct.rkt::skip-redex-step?, undo the fact that we dont skip a step for apps with property 'comes-from-lazy-app (ie - from ~!app in lazy.rkt)
 ) in reconstruct.rkt::skip-redex-step?, dont skip any applications
 ) in model.rkt::break, undoing skipping of step if left and right are the same
 ) in lazy.rkt::~lambda, undo skipping of lazy-proc application
 ) in lazy.rkt::~define, undo skipping of lazy-proc application
 ) in lazy.rkt::~!%app (ie - #%app), undo skipping of (top-level-forcer) application
 ) in lazy.rkt::~!app (adds a ~ around entire app, for non-toplevel apps), dont use custom unwinder
 ) in lazy.rkt::~!app, use ~ instead of hidden-~
 ) in lazy.rkt::!app, use ! instead of hidden-! to force operator
 ) in lazy.rkt::!*app, dont use custom unwinder
 ) in lazy.rkt::!*app, undo skipping of if
 ) in lazy.rkt::!*app, use ! instead of hidden-! to force operands
 ) in racket/private/promise.rkt::make-delayer, dont use custom unwinder


test program:
(define (f x) (+ x 1))
(f 10)


 - application of lazy still doesnt seem to show up, but the result (a delay) does show up
   - oops, this is because I was still using hidden-~ instead of ~
 - application of a lazy-proc (the defined f) seems to produce ellipses (...) around the fn body after substitution
   - experiment confirms this
   - application of force also produces the ellipses (if the result required more reduction, ie - is not an immediate value)
 - returning a val from a reduction with ellipses around it produces ellipses as the left step (ie - there is no normal-break)

- now adding back:
 ) in lazy.rkt, add skipping of lazy-proc application in ~lambda and ~define
  result: removed 1 step, evaluation of f in define (the lazy-proc application)
 ) in lazy.rkt, add back skipping of if stmt in !*app
  result: as expected
 ) in lazy.rkt::~!%app, add back skipping of top-level-forcer


- got rid of ellipses due to lazy-proc: after lazy-proc? testing is done, extract procedure and use that instead of the lazy-proc struct-procedure 

- note about ellipses:
  - there are two types: ill call them "incoming" ellipses and "outgoing" ellipses
  - "incoming" ellipses are generated when you apply an annotated fn, like from a library, or in lazy racket, either a struct-procedure or a force; they are displayed as ellipses around the part of the fn body that is annotated
  - "outgoing" ellipses are generated when finishing evaluation of a fn body that had incoming ellipses around it; outgoing ellipses are always on the lhs of a step


TODO: 
IDEA: how to get rid of ellipses in general
  - in recon-inner (where ellipses get generated), check top mark and if operator in app is something where we dont want ellipses (like force, !, (#%app toplevel-forcer, etc), then dont use ellipses
  - to get rid of ellipses on lhs coming out of ellipses-generating app, when held = no sexp, check top mark, and if operator in app is something where we dont want ellipses (like force, ~, (#%app toplevel-forcer, etc), then skip the step
  - note, oftentimes, operators that generate ellipses get hidden and the top mark may not contain the info we need to determine whether to hide ellipses; to address this, add stepper-syntax-property and use that instead of looking at the top mark

TODO tomorrow: get dont-use-ellipses working





--------------------------------------------------------------------------------
----- 8/16/2010 - LAPTOP
--------------------------------------------------------------------------------

adding back (continued from 8/13/2010)
- get rid of ellipses due to lazy-proc by extracting procedure after test for lazy-proc? (in !*app)
- hide all forces (use hidden-! instead of !)
  - automatically gets rid of (incoming) ellipses due to skipping of force application
- hide all ~ (use hidden-~)
- to hide outgoing ellipses, add 'dont-use-ellipses property around term being delayed (in ~!app), and then add check in model.rkt::go::break, in the result-exp-break/result-value-break case, in the held = no-sexp case, dont send the step if there is a 'dont-use-ellipses property
- add custom unwind fn to !*app
- add custom unwind fn to ~!app
  - it seems like this shouldnt be needed and that the custom unwinder around !*app should be enough, but I think because the term is inside a thunk, the property gets lost unless it is explicitly added here; so we pretty much have two duplicate unwind fns now
- hide steps where lhs and rhs are identical



--------------------------------------------------------------------------------
----- 8/17/2010 - LAPTOP
--------------------------------------------------------------------------------
lazy.rkt stepper additions, grouped by problem description:

Problem: get rid of post-application ellipses due to lazy-proc
Solution: extract procedure after lazy-proc? testing, and hide the extraction

Problem: get rid of post-application ellipses due to force
Solution: hide the force

Problem: get rid of ellipses coming out of force
Solution: use dont-use-ellipses property around expression being delayed
Solution addition: Sometimes, you need to keep the rhs, even if lhs is ellipses. Therefore, in model.rkt::go::break, keep around last rhs and use it as lhs when there are ellipses and dont-use-ellipses = true
Solution addition: if there was no previous rhs (for example, if the step is the first step), then we need to save the rhs of the ellipses step, and add an extra step during the next lhs (normal break), where the rhs of the ellipses step is the lhs and the normal break is the rhs



--------------------------------------------------------------------------------
----- 8/24/2010 - LAPTOP
--------------------------------------------------------------------------------

- outer-lambda-abstraction in annotate.rkt::annotate::annotate-inner adds annotated lambda to closure-table first, using call to closure-storing-proc

- added hash table in reconstruct.rkt called partially-evaluated-promises
  - gets initialized to make-weak-hash in reconstruct-current
  - entries added in reconstruct-current:recon-inner, #%plain-app, not-yet-called case
  - table accessed in recon-source-expr, var-stx case




--------------------------------------------------------------------------------
----- 8/25/2010 - LAPTOP
--------------------------------------------------------------------------------

- I thought I needed access to the thunk in a running promise, but it turns out I dont need it, as long as I keep track of all promises that are currently being evaluated; in this way, the first time I see a running promise, I'll know how to render the partial evaluation, and on subsequent, I can use the cached rendering of the partial evaluation

TODO tomorrow:
- in model.rkt::go::break, fix naming of "held" variables - often variables that have "held" in the name are not actually "held" variables (ie - "held" variables should be an instance of the held struct)
  - also, may want to change things like last-rhs and pending-rhs to be instances of the held struct
- investigate whether there's a bug when there are multiple expressions in your lazy program that produce values



--------------------------------------------------------------------------------
----- 8/26/2010 - LAPTOP
--------------------------------------------------------------------------------

- annotate.rkt::annotate call graph (again)

(annotate main-exp break show-lambdas-as-lambdas? language-level)

     |
     V

(annotate/top-level exp)

     |
     V

(annotate/module-top-level exp)



--------------------------------------------------------------------------------
----- 8/27/2010 - LAPTOP
--------------------------------------------------------------------------------
- in reconstruct.rkt::reconstruct-current:recon-inner, #%plain-app case, maybe-extract-binding did not have case when the syntax was not a binding (ie - an identifier?)
  - this was causing programs without bindings to fail, ie like (car (list (lambda (x) x)))



TODO tomorrow:
- figure out what to do when there is a pending rhs and we have an result-exp-break (this can happen if there is a pending rhs and the subsequent normal break has an identical expr, so the step gets skipped)
  - DONE 8/28/2010
- in model.rkt::break, some abstraction of code is needed
  - DONE 8/28/2010
- figure out how to display lambdas (and thus promises) in lists using the closure-table method instead of using the pconvert output (need some kind of recursive call in recon-value) (beginning student languages suffer from this also)
  - DONE 8/30/2010
  - TODO: need to refer to render settings when creating list syntax in recursive calls, right now just using #'(list ...) for all cases
- when pending rhs is handled, last rhs should get set
  - DONE 8/28/2010

--------------------------------------------------------------------------------
----- 8/30/2010 - LAPTOP
--------------------------------------------------------------------------------
BUG: pending-rhs-held and last-rhs-held getting reset on every call to break
CAUSE: in model.rkt::go::break, accidentally put pending-rhs-held and last-rhs-held inside break fn, so they were getting reset to null on every call
SOLUTION: move out of break fn, to go fn

BUG: when there is more than 1 expr in the program, only the last one (the one being evaluated) shows up in the stepper
CAUSE: finished value not showing up because there was no exp-finished-break; this was because, in annotate/module-top-level, there was no case to handle top level applications for lazy programs
SOLUTION: added case in annotate/module-top-level that matches top level lazy apps, and inserted exp-finished-break



CODE CHANGE: in reconstruct.rkt::skip-redex-step?, in #%plain-app case, removed skipping of list and cons application, and struct-constructors, because this functionality is already handled, more generally, by my duplicate steps check in model.rkt::go::break

CODE CHANGE: set last-rhs-held variable, even when lhs = rhs
  - this prevents us from missing a step; and if we werent going to miss a step, the last rhs should be the same as the one we are setting anyways
  - this causes the lazy stepper to lose the variable (for fns) in an application; all applications will have the actual lambda there now
    - this wasnt working fully anyways
    - TODO: look into fixing this at lambda reconstruction time (ie - in recon-value), instead of the way it's done now, at unwind time using 'use-inferred-name property


--------------------------------------------------------------------------------
----- 9/1/2010 - LAPTOP
--------------------------------------------------------------------------------

BUG: ellipses still show up in lazy racket programs, when using list fns like cadr
CAUSE:
SOLUTION:
 - add 'dont-use-ellipses property around application (body of lambda) in !*app
 - check for ellipses in rhs and for dont-use-ellipses property in send-step fn (in model.rkt::go::break)

BUG: (related to above bug) ellipses still show up in nested applications
CAUSE: currently not recursively checking for ellipses
SOLUTION: recursively check for ellipses in model.rkt::go:break::rhs-has-ellipses?



--------------------------------------------------------------------------------
----- 9/2/2010 - LAPTOP
--------------------------------------------------------------------------------

BUG: when there is more than 1 expr in the program, previous exprs that were strict applications dont show up after they are evaluated
CAUSE: clause for lazy racket added to annotate/module-top-level only matches apps with toplevel-forcer
SOLUTION: add 'comes-from-lazy property around strict top level lazy racket apps, and then check for it in annotate/module-top-level -- need to remove 'comes-from-lazy property check in reconstruct.rkt::hide-completed?
RELATED BUG: top level constants still dont show up
SOLUTION CHANGE: just put in an exp-finished-break for all top level exprs not already matched in annotate/module-top-level; beginner programs shouldnt be affected because they all have the call-with-values/do-print structure at top level
  - clause needed in annotate/top-level now, just call annotate/module-top-level by default for everything -- no more error msg, TOOD: check that this doesnt break any existing tests

BUG: if last step has lhs ellipses, and is only step, then there is no last-rhs to use, so last step doesnt show up
CAUSE: all other steps were skipped
SOLUTION: set lhs of first step with ellipses (so lhs still doesnt have ellipses), to last-rhs-held
  - this should not affect other programs bc lhs of first ellipses step should be same as last-rhs-held anyways

BUG: lazy if doesnt step correctly
CAUSE: not annotated
SOLUTION: rewrite lazy if to use hidden-~ and hidden-!
  - TODO: do we still want lazy if as a function? -- may not work in stepper

BUG: dont want to skip over steps with ellipses that come from force application
CAUSE: currently, exprs with 'dont-use-ellipses property, get skipped
SOLUTION: add new property 'remove-ellipses, that doesnt get skipped, but ellipses are removed
  - need to also check for this property when deciding whether to remove lhs ellipses on result-exp-break



--------------------------------------------------------------------------------
----- 9/8/2010 - LAPTOP
--------------------------------------------------------------------------------

WRITING TESTS:
- broke some existing stepper tests

BUG: printing in expr-finished-break case in model.rkt::go::break broke caused error sometimes when printing getter
CAUSE: there is no getter when expression has 'stepper-define-struct-hint property
SOLUTION: check for 'stepper-define-struct-hint property before printing getter

BUG: lam-let test fails, error: given 0 args, expected 1
CAUSE: in annotate.rkt::annotate::annotate/inner::let-abstraction let-clauses (part of exp-finished-clauses) wasnt being wrapped in thunk - error was raised when (non)thunks were being forced (I accidentally commented out this code when I was trying something)
SOLUTION: wrap let-clauses in thunks

BUG: lam-let test generates "undefined syntax-e identifier" error
CAUSE: my maybe-extract-binding fn is failing on eval when in the student languages -- need to parameterize eval somehow???
SOLUTION: just dont use eval and just use case to match symbolic fn name to actual fn

BUG: empty prints as (list)
CAUSE: in recon-value, all lists are rendered as (list ...)
SOLUTION: handle empty list separately in recon-value

BUG: some printf has problems in check-expect test because a string like "C:\docu~1" gets printed and printf doesnt like the "~1"


--------------------------------------------------------------------------------
----- 9/15/2010 - LAPTOP
--------------------------------------------------------------------------------

BUG: some printf has problems in check-expect test because a string like "C:\docu~1" gets printed and printf doesnt like the "~1"
CAUSE: test-engine/test-engine.scm has printf where string parameter is generated, ie - (printf (format-src dest))
SOLUTION: remove tildes in output of path->string. Used this fn in place of path->string

    (define (path->string-no-tilde path)
      (regexp-replace* #rx"~" (path->string path) ""))
SOLUTION2: John just changed to (printf "~a") instead of using the string directly as the printf arg

--------------------------------------------------------------------------------
----- 9/20/2010 - LAPTOP
--------------------------------------------------------------------------------

- debugging the stepper test framework:

~~~~~ Summary of model:go function ~~~~~
args:
  program-expander
  receive-result
  render-settings
  show-lambdas?
  lang-level
  disable-err-handling?

- calls program-expander with 2 args:
  - init: thunk that sets error display handling 
  - iter: fn with two args: expanded and continue-thunk
      - resets special vals 
      - if expanded == eof, call receive-result with FINISHED token
      - else 1) call eval-syntax with annotated version of expanded
             2) force continue-thunk

Different program-expander fns:
*** from stepper test framework ***
- forces init
- 1) writes test prog to file
  2) reads with read-syntax
  3) expands with expand-teaching-program
  4) expands normally
  5) calls iter with expanded and a thunk that makes the same (???) call
     - i think the call looks the same but the next call will read the next part of the program

*** from stepper ***
- calls iter with expanded program and thunk that repeats the same loop (I think this is the same issue as the stepper test framework program-expander, the loop probably reads the next part of the program on each iteration)


BUG: stepper output in test framework is not the same as normal stepper
CAUSE: racket/private/promise.rkt does not get added to namespace for some reason, so call to promise? in reconstruct.rkt::extract-if-struct returns #f for promise values (I dont know why it doesnt error)
SOLUTION: add racket/private/promise module to namespace using namespace-attach-module:

(define (run-lazy-test name)
  (let ([ns (make-base-namespace)])
    (namespace-attach-module (current-namespace) 'racket/private/promise ns)
    (parameterize ([current-namespace ns])
      (run-test name))))


BUG: stepper output in test framework doesnt print function names correctly, like force or !
CAUSE: ll-model for lazy language (in tests/stepper/language-level-model.rkt) was using print-convert and not stepper/stepper-tool.rkt::stepper-print-convert in its render-settings (stepper/private/model-settings.rkt)
  - stepper-print-convert has a hack that uses the object-name of a procedure if it exists, before passing its arg off the print-convert
SOLUTION: copy the hack so that the lazy ll-model also uses stepper-print-convert
  - it turns out that the hack was already copied so the beginner languages could use it
  - stepper/private/model-settings.rkt::make-fake-render-to-sexp has the hack



TODO: fix dereferencing of fn var name before substituting
- var shows up if it is the first step and we get an extra dereferencing step where the fn var is replaced with the lambda
- if it is not the first step, the fn var never shows up and we only get a step with the lambda
- the highlighting isnt right when the fn var name is replaced with a lambda
- the stepper test framework doesnt show the step where the fn var name is replaced with a lambda
- NOTE: this can be controlled by the show-lambdas-as-lambdas? parameter
  - for the lazy language, this parameter is set at the bottom of lazy/lazy-tool.rkt, in the instantiation of the lazy-language% class


--------------------------------------------------------------------------------
----- 9/22/2010 - LAPTOP
--------------------------------------------------------------------------------

TODO:
1) nested list fns still dont step correctly, ie - (cadr (cdr (list (+ 1 2) (+ 2 3) (+ 4 5))))
2) need to fix rendering of promises that come from library code (ie - like the promise generated by take in lazy.rkt)
  - instead of delay, it should be something like <unknown:1>


--------------------------------------------------------------------------------
----- 10/6/2010 - LAPTOP
--------------------------------------------------------------------------------
BUG: nested list fns still dont step correctly, ie (cadr (cddr (list 1 2 3 4))
CAUSE:
  1) constructor applications in lazy racket arent skipped like they are in beginner langs bc special cons and list fns arent properly set (due to strangeness of lazy #%app definition)
  2) ellipses arent handled correctly - right now all steps with ellipses are being stepped even though when there are nested ellipses, we need to show a step when an inner ellipses finishes, even if there are still outer ellipses.
SOLUTION:
  1) fix proper skipping of constructor applications by 
    a) properly setting special list fns
    b) fixing reconstruct.rkt::skip-step?
      - allow skipping to match on lazy #%app forms:
        - (#%plain-app (lam args body) fn . rest)
        - (#%plain-app (#%plain-app proc-extract-target p) . args)
        - TODO: is it possible for non lazy programs to match these forms?
                maybe I need to add a special syntax property around these forms instead of relying on their shape to identify them
      - add checking of constructor applications in lazy forms to both normal-break and result-exp-break
      - constructor applications that we want to skip can also show up in lazy programs at result-value-break breakpoints, but thus far I havent added the skip checks to the result-value-break case because the test cases have been caught by the normal-break cases
      - TODO: it seems like it's possible for valid result-value-breaks to be skipped because held is not being reset to the-no-sexp, and it could still be the-skipped-step if we skipped a step due to skip-step? being true when there's a result-value/exp-break

BUG: reconstruction of #%app in recon-inner when top mark label is called and we dont want ellipses is broken because it only puts the procedure back and not the other args -- what we really want is to re-create the entire context and then put the so-far in the hole
CAUSE: only rebuilding the procedure and not the other args (ie - assuming it was always a 1-arg fn call)
SOLUTION: rebuild the entire app, similar to how the uncalled case works, except replace the running promise with the so-far. We know that there will always be a running promise because the lazy language is the only language that uses the dont-use-ellipses property.

BUG: highlighting is broken when eliminating ellipses
CAUSE: highlight remains on the value of the last evaled subexpression
SOLUTION: move the highlight out one level (add optional param to send-step in model.rkt to do this) for saved rhs when encountering ellipses as the lhs of a step
BETTER SOLUTION (10/10/2010): move highlight out one level for all saved rhs whenever break is result-value-break


TODO Tomorrow:
1) make sure the moving out of the highlighting works when there are more than 1 expr in a step (right now I think I only deal with the first exp in the exps list)
  - this doesnt seem to be a problem 10/10/2010
2) write tests
3) email matthias
4) clean up debugging output



--------------------------------------------------------------------------------
----- 10/7/2010 - LAPTOP
--------------------------------------------------------------------------------
Getting error when trying to run stepper tests:

string<?: expects type <string> as 1st argument, given: #f; other arguments were: "dcdf0433aca16ea2f5db9a003821f56a718d2da5"


Isolated the error to:

mzlib/contract.rkt, when I try to run the file
     |
     V
mzlib/private/contract-object.rkt
     |
     V
mzlib/private/contract-arrow.rkt
     |
     V
racket/contract/private/opt.rkt
     |
     V
racket/contract/private/guts.rkt
     |
     V
racket/private/base.rkt
     |
     V
racket/private/pre-base.rkt
     |
     V
racket/private/more-scheme.rkt
     |
     V
racket/private/small-scheme.rkt
     |
     V
racket/private/define-et-al.rkt
     |
     V
racket/private/cond.rkt


SOLUTION: bug fixed in 5.0.1.*, see http://lists.racket-lang.org/dev/archive/2010-July/003692.html
WORKAROUND for 5.0.0.*: set Dynamic Properties (Choose Language -> Show Details) to Debugging and profiling (bug shows up when it's just Debugging, or maybe even with No debugging or profiling)

--------------------------------------------------------------------------------
----- 10/8/2010 - LAPTOP
--------------------------------------------------------------------------------
COMPILING Racket from source in Windows with Visual Studio express:
(basically following the appropriate steps of C:\plt\src\worksp\build.bat but doing it manually bc VS Express doesnt have devenv.exe)
(these steps are also outlined in c:\plt\src\worksp\README but less succinctly)
(*NOTE: "plt" is the base directory for the repository)

1) open C:\plt\src\worksp\racket\racket.sln with Visual C++ 2008 Express (double clicking the file is enough to open it) (click yes to convert the file, made backup)
2) Build -> Build Solution (Release Win32 version)
3) open C:\plt\src\worksp\gracket\gracket.sln with Visual C++ 2008 Express (double clicking the file is enough to open it) (click yes to convert the file, made backup)
4) Build -> Build Solution (Release Win32 version)
5) ran C:\program files\Microsoft Visual Studio 9.0\Common7\Tools\vsvars32.bat to "Setting environment for using Microsoft Visual Studio 2008 x86 tools."
6) ran ..\..\..\racketcgc.exe -c make.rkt from plt\src\worksp\gc2 
7) open C:\plt\src\worksp\mrstart\mrstart.sln with Visual C++ Express and compile like previous steps
8) open C:\plt\src\worksp\mzstart\mzstart.sln with Visual C++ Express and compile like previous steps
9) run racket -l setup -N "raco setup" from c:\plt to build other exe's
  - got errors:
raco setup: error: during Early Install for plot
raco setup:   compile-extension: can't find an installed C compiler
10) ran instead: racket.exe -l- setup
  - got same plot errors

1/11/2010: compiling 5.0.2
- got error:
raco setup: running: data\scribblings\data.scrbl
WORKER ERROR ffi-lib: couldn't open "libpng14-14.dll" (The specified module coul
d not be found.; errno=126)
STDOUT
raco setup: running: scribblings\draw\draw.scrbl
=====
STDERR
get-doc-info-worker error: ffi-lib: couldn't open "libpng14-14.dll" (The specifi
ed module could not be found.; errno=126)
=====
raco setup: running: preprocessor\scribblings\preprocessor.scrbl
WORKER ERROR ffi-lib: couldn't open "libpng14-14.dll" (The specified module coul
d not be found.; errno=126)
STDOUT
raco setup: running: scribblings\quick\quick.scrbl
=====
STDERR
get-doc-info-worker error: ffi-lib: couldn't open "libpng14-14.dll" (The specifi
ed module could not be found.; errno=126)
=====

solution: had to download gracket libs from github.com/mflatt/gracket-libs; saved and extracted to C:\racket\lib; copied everything from C:\racket\lib\mflatt-gracket-libs-2a312af\win32\i386 to C:\racket\lib
 - or do git clone https://github.com/mflatt/gracket-libs.git (from c:\plt), and copy everything into lib/ dir


--------------------------------------------------------------------------------
----- 10/10/2010 - LAPTOP
--------------------------------------------------------------------------------
BUG: 'trivial-begin0 stepper test fails in 5.0.1.5 when Dynamic properties is Debugging and profiling, but passes when debugging and profiling are off, or just debugging is on


--------------------------------------------------------------------------------
----- 10/13/2010 - LAPTOP
--------------------------------------------------------------------------------
BUG: some nested promises dont render correctly
example programs: 
(define (f x) (+ (car x) (car x)))
(f (list (+ 1 2) (+ 3 4)))
(define (g x) (+ (cadr x) (cadr x)))
(g (take 2 (list 1 2 3)))
CAUSE: partially evaluated promises wasnt being stored correctly all the time
SOLUTION: overhauled the way I store and retrieve partially evaluated promises:
At the beginning of recon-inner, look for any running promise in the bindings of the top mark (there either should only be 1, or they should all be the same one), and store that in the partially-evaluated-promises-table as the key, using so-far as the value. Then in recon-value, when rendering a promise, first look up in partially-evaluated-promises-table. (for some reason sometimes I needed to unwrap the promise one layer to get it to work. I still can't figure out why this is needed).

--------------------------------------------------------------------------------
----- 10/28/2010 - LAPTOP
--------------------------------------------------------------------------------
BUG: the so-far associated with a running-promise in partially-evaluated-promises is wrong sometimes, for example, in this program:

(define (list-length list)
  (if (null? list)
      0
      (+ 1 (list-length (rest list)))))
(list-length (list 1 2))

After the first recursive call, while evaluating the if test, we get the step:

(+ 1
 (if (null? (rest (list 1 2)))
   0
   (+ 1 (list-length (rest (rest (list 1 2)))))))

->

(+ 1
 (if (null? (rest (list 1 2)))
   0
   (+ 1 (list-length (rest (null? (rest (list 1 2))))))))

where the null? erroneously appears in the recursive call argument as wel

CAUSE: in recon-inner, when the running-promise is added to the partially-evaluated-promises-table, it's not checked whether the running-promise is already in the table, so it gets overwritten, which is wrong, because we always want the so-far associated with the first appearance of the running-promise

SOLUTION: before adding a running-promise/so-far pair to partially-evaluated-promises-table, check if it's already there, and if so, dont add to hash table

--------------------------------------------------------------------------------
----- 10/29/2010 - LAPTOP
--------------------------------------------------------------------------------
BUG: running-promise in definition doesnt update correctly
CAUSE: when the promise is at the top level, the running-promise never gets added to partially-evaluated-promises-table, so it gets displayed as "DelayedEvaluation" in the definition
SOLUTION: always save the last so-far and use it as the exp for a running-promise that's not found in partially-evaluated-promises-table. This is a HUGE assumption but I think it will work.
UPDATE 11/1/2010:
Of course, the huge assumption I made didnt quite hold all the time. Added a few guards:
- in recon-inner, dont add running promise to partially-evaluated-promises-table if so-far = nothing-so-far (this occurs when we have infinite lists in lazy racket)
- in recon, dont set last-so-far when so-far = nothing-so-far (again, this occurs when we have infinite lists)
- in recon-value, dont use last-so-far if it hasnt been set (ie - if it's still null)


--------------------------------------------------------------------------------
----- 11/1/2010 - LAPTOP
--------------------------------------------------------------------------------
TODO: infinite lists in lazy racket doesnt work in stepper test framework
Example: This test:

  (let ([def '(define ones (cons 1 ones))])
    (t 'lazy-eli-5 m:lazy
       ,def (car ones) (second ones) (fifth ones)
       :: ,def {(car (cons 1 (cons 1 <DelayedEvaluation#0>)))} -> ,def {1}
       :: ,def 1 {(second (cons 1 <DelayedEvaluation#0>))}     -> ,def 1 {1}
       :: ,def 1 1 {(fifth (cons 1 <DelayedEvaluation#0>))}    -> ,def 1 1 {1}))

Generates this error:

test-sequence: steps do not match
   given: #(struct:error-result "<collects>/stepper\\private\\shared.rkt: \n  (file\n   C:\\Program Files\\Racket-Full-5.0.0.6\\collects\\stepper\\private\\marks.rkt)\n broke the contract (-> syntax? any) on syntax->interned-datum given to \n  (file\n   C:\\Program Files\\Racket-Full-5.0.0.6\\collects\\stepper\\private\\reconstruct.rkt)\n; expected <syntax?>, given: ()")
expected: (before-after ((define ones (cons 1 ones)) (hilite (car (cons 1 (cons 1 <DelayedEvaluation#0>))))) ((define ones (cons 1 ones)) (hilite 1)))
...Error has occurred during test: lazy-eli-5


--------------------------------------------------------------------------------
----- 11/2/2010 - LAPTOP
--------------------------------------------------------------------------------

BUG: sometimes we dont want to move highlights on last-rhs used as lhs, when there normally would be ellipses on lhs
example:
(define (f lst) (+ (second lst) (third lst)))
(f (map (lambda (x) (+ x 1)) (list 1 2 3)))

simpler example: (+ (car (map + (list (+ 1 2)) (list (+ 3 4)))) 1)

CAUSE: highlights always moved
SOLUTION: add extra last-rhs-held-highlight-not-moved global var in model.rkt, and use it instead of last-rhs-held when 'dont-move-highlight stepper-syntax-property is true ('dont-move-hightlight used around app in thunk in racket/private/promise.rkt)


TODO tomorrow:
BUG: sometimes we want to use ellipses on lhs
example:
(define (f lst) (+ (second lst) (third lst)))
(f (map + (list 1 (+ 2 3) (+ 4 5)) (list 4 (+ 6 7) (+ 8 9))))

CAUSE: ellipses always removed
SOLUTION: add 'dont-remove-ellipses stepper-syntax-property?


--------------------------------------------------------------------------------
----- 11/4/2010 - LAPTOP
--------------------------------------------------------------------------------

BUG: Strategy of looking for running promise in recon-inner, #%plain-app, called case doesnt always work.
CAUSE: Sometimes, running promise is inside another promise, or there may be no running promise (usually infinite lists are involved in both cases). For the example, see the sieve primes example from Eli's lecture.
SOLUTION: instead of just checking for running promise and then replacing it with so-far, pass so-far to recon-val as optional param and use that to replace running promise if the running promise is not in partially-evaluated-promises-table (use the passed-in so-far before using last-so-far). This fixes the problem when the running promise is inside another promise.
SOLUTION 2: When there is no running promise, then there could be a highlighting problem. Add a check after recon-inner returns in recon (result is bound to reconstructed). If reconstructed has no highlight, then highlight the whole thing. It will probably be wrong, but it's better than crashing.
OTHER FIX: if we are going to use assigned name for promises when avail, we need to set assigned name to #t when we recur inside the promise, otherwise, we'll be using the wrong name
OTHER FIX 2: Also, last-so-far needs to be reset more often than just with the other special vals. Reset it on every recon (at the beginning of the eval of answer in reconstruct-current).


--------------------------------------------------------------------------------
----- 2/20/2011
--------------------------------------------------------------------------------
- NEW STRATEGY FOR DEALING WITH ETA-EXPANDED LAZY #%APP:
Instead of unwinding the extra application in lazy #%app's, I rewrite it before annotating, so that the extra eta-expansion is unncessary. This duplicates arguments, so it's not feasible for the lazy language, but it's ok for the stepper, since only small programs are usually stepped.

- doesnt work for some cases:
(define (f x) (+ (car x) (car x)))
(f (list (+ 1 2)))

The problem is that when the (+ 1 2) is evaled when evaluating the first (car x), the arg to the second (car x) displays a <DelayedEvaluation#0>. This is because the rewritten program doesnt get corrected stored as contmarks.

Marks for the unrewritten program:

---------- BREAK TYPE = normal-break ----------
MARKLIST:
source: (#%app p (#%app ! temp10) (#%app ! temp11))
label: called
bindings:
 arg0-2248 : #<procedure:+>
 arg1-2249 : 1
 arg2-2250 : 2

source: (#%app p (#%app ! temp1) (#%app ! temp2))
label: not-yet-called
bindings:
 p : #<procedure:+>
 temp1 : #<promise:!running>
 temp2 : #<promise>
 arg0-2248 : #<procedure:+>
 arg1-2249 : #<*unevaluated-struct*>
 arg2-2250 : #<*unevaluated-struct*>

RETURNED VALUE LIST: (3)


Marks for the rewritten program:

