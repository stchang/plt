--------------------------------------------------------------------------------
----- 6/24/2010 - HOME PC
--------------------------------------------------------------------------------

- dl and install Racket Full 6/24/2010 nightly build
- copied over lazy/info.rkt and lazy/lazy-tool.rkt so stepper button would show up (must run setup-plt to register changes (use -D option, it's doesnt build docs so it's quicker))

Tried to step test program:
(define (f x) (+ 1 x))
(f 10)

Error Message:
annotate/top-level: unexpected top-level expression: (define-values (f) (#%app lazy-proc (lambda (x) (#%app lazy (lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2)))))))))

Solution:
A cond clause seems to have been removed from annotate/top-level in stepper/private/annotate.rkt (it's there on the version in my laptop)
 - no, this was added by me

Added clause: [(define-values (ids ...) bodies) (annotate/module-top-level exp)]



Error Message:
Internal stepper error: time to resync with simple-module-based-language-convert-value

Solution:
cond clause missing in simple-module-based-language-convert-value in stepper/stepper-tool.rkt

Added clause: [(print) value]

(TODO: eventually, I want Lazy Racket to use the 'constructor print style as default, but I havent been able to figure out how to do that yet)


- It works!

Output: 
(define f
  #(struct:lazy-proc
    #<procedure:...ate\annotate.rkt:809:52>))
((#<procedure:parameter-procedure>)
 (let ((p f) (temp6 10))
   (if (if (lazy-proc? p)
         #t
         (struct-constructor-procedure?
          p))
     (p temp6)
     (p temp6))))


- changed print style to 'constructor

Output:
(define f
  |...ate\annotate.rkt:809:52|)
((parameter-procedure)
 (let ((p f) (temp6 10))
   (if (if (lazy-proc? p)
         true
         (struct-constructor-procedure?
          p))
     (p temp6)
     (p temp6))))


- uncommented stepper-skipto annotation in !*app in lazy/lazy.rkt

Output:
(define f
  |...ts\lazy\lazy.rkt:124:48|)
((parameter-procedure)
 (let ((p f) (temp6 10))
   (p temp6)))


- trying to wrap output of ~!%app in lazy/lazy.rkt with stepper-annotate function
 - wrapped around (toplevel?) clause, got error: 
#%plain-app: bad syntax in: (#%plain-app (#%plain-app parameter-procedure) (let-values (((p) f) ((temp6) (quote 10))) (#%app p temp6)))

 - wrapped around else clause, no effect - same as if stepper-annotate wasnt used


Experiment:
- added a test clause in unwinder in ~!%app in lazy/lazy.rkt to see if unwinder gets called - it worked (error gets raised)
test clause: [_ (raise-syntax-error 'hi "testing...")]

- moved test clause to be last clause in unwinder to see if first clause matches - error gets raised again, which means first clause didnt get matched


Experiment:
- trying to move stepper-annotate to !*app in lazy/lazy.rkt - applied stepper-annotate to quasisyntax/loc expr - pattern in unwinder still not matched
- if I remove the raise-syntax-error clause, the error is:
let-values: bad syntax in: (let-values (((p) f) ((temp6) (quote 10))) (#%app p temp6))

Experiment:
- trying to change the pattern in unwinder to match the expression I'm working with (removed stepper-skip-double-break property for now):
(define (unwinder stx rec)
      (syntax-case stx (!)
        [(let-values ([(_p) f] [(_y) x] ...) _body)
         (with-syntax ([(f x ...) (rec #'(f x ...))])
           #'(f x ...))]))

It worked! Output:
(define f
  |...ts\lazy\lazy.rkt:124:48|)
((parameter-procedure) (f 10))
->
(define f
  |...ts\lazy\lazy.rkt:124:48|)
(force (f 10))
->
(define f
  |...ts\lazy\lazy.rkt:124:48|)
(define p_0 f)
(define temp6_0 10)
(force (p_0 temp6_0))
->
(define f
  |...ts\lazy\lazy.rkt:124:48|)
(define p_0
  |...ts\lazy\lazy.rkt:124:48|)
(define temp6_0 10)
(force
 (|...ts\lazy\lazy.rkt:124:48|
  temp6_0))
->
(define f
  |...ts\lazy\lazy.rkt:124:48|)
(define p_0
  |...ts\lazy\lazy.rkt:124:48|)
(define temp6_0 10)
(force
 (|...ts\lazy\lazy.rkt:124:48|
  10))
->
(define f
  |...ts\lazy\lazy.rkt:124:48|)
(define p_0
  |...ts\lazy\lazy.rkt:124:48|)
(define temp6_0 10)
(force
 (...
  (lazy (lambda () (+ 1 10)))
  ...))
->
(define f
  |...ts\lazy\lazy.rkt:124:48|)
(define p_0
  |...ts\lazy\lazy.rkt:124:48|)
(define temp6_0 10)
(force (delay ...))
->
(define f
  |...ts\lazy\lazy.rkt:124:48|)
(define p_0
  |...ts\lazy\lazy.rkt:124:48|)
(define temp6_0 10)
(define p_0 +)
(define temp1_0 1)
(define x2_0 10)
(... (p_0 temp1_0 x2_0) ...)

(13 steps total)



- adding back stepper-skip-double-break property

Output:
(define f
  |...ts\lazy\lazy.rkt:124:48|)
((parameter-procedure) (f 10))
->
(define f
  |...ts\lazy\lazy.rkt:124:48|)
(force (f 10))
->
(define f
  |...ts\lazy\lazy.rkt:124:48|)
(define p_0
  |...ts\lazy\lazy.rkt:124:48|)
(define temp6_0 10)
(force
 (|...ts\lazy\lazy.rkt:124:48|
  temp6_0))
->
(define f
  |...ts\lazy\lazy.rkt:124:48|)
(define p_0
  |...ts\lazy\lazy.rkt:124:48|)
(define temp6_0 10)
(force
 (|...ts\lazy\lazy.rkt:124:48|
  10))

(11 steps total)


TODO tomorrow:
1) read stepper internal docs more carefully
2) reread lazy code and lazy srfi docs


--------------------------------------------------------------------------------
----- 6/25/2010 - HOME PC
--------------------------------------------------------------------------------

- Functions defined with define (ie - (define (f x) (+ x 1)) ) in the Beginner languages are displayed the same way in the Stepper regardless of whether the Output Style in the Choose Language menu is 'constructor or 'quasiquote or 'write

- extended lazy language class (which implements module-based-language<%> - in drracket/private/language.rkt) and overrode default-settings and default-settings? methods so that the default print-style was 'constructor
 - ran setup-plt and stepper prints functions as lambdas with Lazy Racket
 - I tried experimenting with the pretty-print-depth parameter (#f = all depths printed, instead of "...") previously to show the entire lambda but was not successful

Weird behavior:
- when I change something in lazy.rkt and restart DrRacket, fns in the stepper display as line numbers -- (define f |...ts\lazy\lazy.rkt:131:25|) -- but when I re-run setup-plt (both with undoing and not undoing the changes), fns go back to being displayed as lambdas
  - yes this makes sense, because the source of the syntax is in the changed file so you need to recompile to make them show up properly

observation:
- There are two ways to add a property to some syntax (or other similar operations) (is this true?)
 1) use with-syntax
 2) use quasisyntax and escape when calling stepper-syntax-property, etc


Trying to get fns defined with define (and not using lambda) to display properly in stepper:

Experiment: 
- trying to use stepper-define-type stepper-syntax property to do it (Beginner languages use this property)

- doesnt seem to be working
- it works! if I remove the lazy-proc wrapping the lambda (so if I use just lambda instead of ~lambda)

Possible solutions:
1) add case in unwind-define in stepper/private/macro-unwind.rkt for functions that use ~lambda
2) add custom unwinder using stepper-hint like in !*app in lazy/lazy.rkt

TODO tomorrow:
1) finish implementing displaying of fns defined with define (see possible solutions above)

--------------------------------------------------------------------------------
----- 6/28/2010 - LAPTOP
--------------------------------------------------------------------------------

- module-identifier=? in mzscheme is the same as free-identifier=? in racket/base


--------------------------------------------------------------------------------
----- 6/29/2010 - LAPTOP
--------------------------------------------------------------------------------

- somehow, when using the custom unwinder, the body of the lambda gets quoted, but when using unwind-define in stepper/private/macro-unwind.rkt, there is no quote, even though both functions are the same and get they get the same inputs - THIS ISNT QUITE RIGHT, see below
  - finally figured it out! The custom unwinder was using recur-on-pieces (as specified in unwind in stepper/private/macro-unwind.rkt) to recursively unwind the body of the function but unwind-define was using unwind as the recursive call
    - I changed the recursive call in unwind in stepper/private/macro-unwind.rkt to use unwind instead of recur-on-pieces

- the recur-on-pieces doesnt add the quote, it just doesnt get rid of it. the unwind fn has a syntax-case clause in fall-through that gets rid of the quote; I still dont know why adding lazy-proc adds a quote
  - it seems like something funny is happening during annotation of lazy-proc - probably because it's a struct constructor and not a real function, so that the stepper doesnt quite know how to reconstruct it, and so that's why we get the funny results with the quote and the dots
  something like (lazy-proc (lambda (x) (+ 1 x))) is getting annotated and reconstructed as (quote (lambda (a1) ...)) where the quote and the dots are part of the actual output

- the 'stepper-define-type stepper-syntax-property seems to be lost when I add lazy-proc around the lambda


Call Graph: stepper/private/macro-unwind.rkt::unwind

stepper/private/model.rkt
  break:reconstruct-all-completed
  break (not skip-step, normal-break, normal-break/values)
    - applied to results of reconstruct.rkt::reconstruct-left-side
  break (not skip-step, result-exp-break, result-value-break)
    - applied to results of reconstruct.rkt::reconstruct-right-side
  break (not skip-step, double-break)
    - applied to results of reconstruct.rkt::reconstruct-double-break

          |
          V

stepper/private/macro-unwind.rkt::unwind



Call Graph: stepper/private/reconstruct.rkt::reconstruct-current

stepper/private/reconstruct.rkt
  reconstruct-left-side
  reconstruct-right-side
  reconstruct-double-break

          |
          V

stepper/private/reconstruct.rkt::reconstruct-current


- trying now to just use stepper-skipto to skip the lazy-proc application
  - the 'stepper-define-type stepper-syntax-property still seems to be lost when I add lazy-proc around 
    - trying to add the stepper-define-type property around the lazy-proc instead of around the lambda (and hopefully it gets transferred over?)the lambda
      - didnt work


TODO tomorrow:
 - look at stepper/private/reconstruct.rkt::recon-value
   - this is the function that inserts the quote
     1) it's because stepper/private/shared.rkt::closure-table-lookup returns #f
     2) also, the dots comes from render-settings-render-to-sexp, I think?
       - look in stepper/stepper-tool.rkt at stepper:render-to-sexp and simple-module-based-language-convert-value
 - check stepper/private/annotate.rkt::top-level-rewrite to see what kind of label lazy-proc gets (ie - macro-bound, non-lexical, etc)
   - print out stepper-binding-type given by top-level-rewrite for each var case
     - lazy-proc is 'non-lexical
   - labels are used in var (used in varref-abstraction in annotate::annotate/inner



--------------------------------------------------------------------------------
----- 6/30/2010 - LAPTOP
--------------------------------------------------------------------------------

 - stepper/private/annotate.rkt::return-value-wrap - calls return-value-wrap-maker - adds specified breakpoint and deals with multiple values
 - stepper/private/annotate.rkt::break-wrap adds a normal-break
 - annotate/inner::wcm-break-wrap adds a break-wrap to the expr before calling outer-wcm-wrap
 - annotate.rkt::wcm-pre-break-wrap adds pre-break-wrap to expr before calling wcm-wrap (pre-break-app adds result-exp-break)
 - stepper/private/marks.rkt::wcm-wrap makes the standard call to wcm with key 'debug-key

Annotating vars:
 - if var is not lexical but is from current module, add a break; otherwise, dont add a break


Experiment: see what happens if lambdas in lazy racket are wrapped with regular function (defined in module, ie - in lazy.rkt)

1) wrap with fn (define (test-proc x) x) defined in lazy.rkt
 - most things worked
   - using stepper-skipto (append skipto/cdr skipto/second)
   - using kernal-syntax-case* with literal #%app and pattern (#%app xx body) for function body, xx gets bound to 'test-proc
   - works when test-proc is in another file that is required


Experiment: what happens in annotate.rkt::varref-abstraction for various vars
  - interesting, neither test-proc nor f shows up as a parameter to varref-abstraction
    - dump: lazy private/promise.rkt + (quote #%kernel) toplevel-forcer (lib lazy/lazy.rkt)
  - dump is the same when test-proc is replaced with lazy-proc


Experiment: dumping all the exprs that get annotated by stepper/private/annotate.rkt::annotate::annotate/inner (using stepper-skipto for lazy-proc/test-proc)

- when using lazy-proc:
(#%app lazy-proc (lambda (x) (#%app lazy (lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2))))))))

(lambda (x) (#%app lazy (lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2)))))))


(#%app lazy (lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2))))))

lazy

(lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2)))))

(let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2))))

(#%app ! +)
+
(quote 1)
x
(if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2)))
(#%app p temp1 x2)
p
temp1
x2
(#%app p (#%app ! temp1) (#%app ! x2))
p
(#%app ! temp1)
temp1
(#%app ! x2)
x2
(#%app (#%app toplevel-forcer) (let-values (((p) (#%app ! (#%top . f))) ((temp6) (quote 10))) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp6) (#%app p (#%app ! temp6)))))
(#%app toplevel-forcer)
toplevel-forcer
(let-values (((p) (#%app ! (#%top . f))) ((temp6) (quote 10))) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp6)
(#%app p (#%app ! temp6))))
(#%app ! (#%top . f))
(#%top . f)
(quote 10)
(if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp6) (#%app p (#%app ! temp6)))
(#%app p temp6)
p
temp6
(#%app p (#%app ! temp6))
p
(#%app ! temp6)
temp6


when using test-proc (seems to be identical to lazy-proc)

(#%app test-proc (lambda (x) (#%app lazy (lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2))))))))

(lambda (x) (#%app lazy (lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2)))))))

(#%app lazy (lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2))))))

lazy

(lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%appp temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2)))))

(let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2))))

(#%app ! +)
+
(quote 1)
x
(if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2)))
(#%app p temp1 x2)
p
temp1
x2
(#%app p (#%app ! temp1) (#%app ! x2))
p
(#%app ! temp1)
temp1
(#%app ! x2)
x2
(#%app (#%app toplevel-forcer) (let-values (((p) (#%app ! (#%top . f))) ((temp6) (quote 10))) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp6) (#%app p (#%app ! temp6)))))
(#%app toplevel-forcer)
toplevel-forcer
(let-values (((p) (#%app ! (#%top . f))) ((temp6) (quote 10))) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp6) (#%app p (#%app ! temp6))))
(#%app ! (#%top . f))
(#%top . f)
(quote 10)
(if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp6) (#%app p (#%app ! temp6)))
(#%app p temp6)
p
temp6
(#%app p (#%app ! temp6))
p
(#%app ! temp6)
temp6


Experiment: dump of all exprs that get annotated by annotate.rkt:annotate (for my test file that uses lazy racket: (define (f x) (+ x 1)) (f 10)     )

- using lazy-proc

(define-values (f) (#%app lazy-proc (lambda (x) (#%app lazy (lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2)))))))))

(#%app (#%app toplevel-forcer) (let-values (((p) (#%app ! (#%top . f))) ((temp6) (quote 10))) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp6) (#%app p (#%app ! temp6)))))


- using test-proc (seems the same as for lazy-proc except using test-proc)

(define-values (f) (#%app test-proc (lambda (x) (#%app lazy (lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2)))))))))

(#%app (#%app toplevel-forcer) (let-values (((p) (#%app ! (#%top . f))) ((temp6) (quote 10))) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp6) (#%app p (#%app ! temp6)))))





Call graph for annotation of lazy racket (define (f x) (+ x 1))


stepper/private/model.rkt:

go
     |
     V

go::step-through-expression
(annotate break parameter is break fn in model.rkt)
(annotated expr is then eval'ed)

     |
     V

in stepper/private/annotate.rkt:

annotate
(break parameter is break fn in model.rkt)
     |
     V

annotate::annotate/top-level #'(define-values (f) (#%app lazy-proc (lambda (x) (+ x 1))))

     |
     V

annotate::annotate/module-top-level #'(define-values (f) (#%app lazy-proc (lambda (x) (+ x 1))))

     |
     V

annotate::top-level-annotate/inner #'(#%app lazy-proc (lambda (x) (+ x 1)))

     |
     V

annotate::annotate/inner #'(#%app lazy-proc (lambda (x) (+ x 1)))



- displaying syntax->datum of top-level-rewrites for my test code seems to produce no change
  - yes of course this is true, top-level-rewrites only applies stepper-binding-type labels and other stepper-properties





Experiment: dump of exprs given to annotate/inner and the results

----- deleted -----



Experiment: dumping exprs given to annotate/inner, along with associated stepper-properties


- using lazy-proc


(#%app lazy-proc (lambda (x) (#%app lazy (lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2))))))))

((stepper-skipto (syntax-e cdr syntax-e cdr car)))

(lambda (x) (#%app lazy (lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2)))))))

((stepper-proc-define-name #<syntax:C:\Documents and Settings\Stephen Chang\My Documents\plt\sandbox\lazy-expand-test.rkt:1:9 f>) (stepper-define-type shortened
-proc-define))

(#%app lazy (lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2))))))

#f

lazy

((stepper-binding-type non-lexical))

(lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2)))))

#f

(let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2))))

((stepper-skip-double-break #t) (stepper-hint #<procedure:unwinder>))

(#%app ! +)

((stepper-skipto (syntax-e cdr syntax-e cdr car)))

+

((stepper-binding-type non-lexical))

(quote 1)
#f
x
((stepper-binding-type lambda-bound))
(if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2)))

(((stepper-skipto (syntax-e cdr cdr both-l () (car)))) (stepper-skipto (syntax-e cdr cdr both-l () (car))))

(#%app p temp1 x2)
#f
p
((stepper-binding-type let-bound))
temp1
((stepper-binding-type let-bound))
x2
((stepper-binding-type let-bound))
(#%app p (#%app ! temp1) (#%app ! x2))
#f
p
((stepper-binding-type let-bound))
(#%app ! temp1)
((stepper-skipto (syntax-e cdr syntax-e cdr car)))
temp1
((stepper-binding-type let-bound))
(#%app ! x2)
((stepper-skipto (syntax-e cdr syntax-e cdr car)))
x2
((stepper-binding-type let-bound))
(#%app (#%app toplevel-forcer) (let-values (((p) (#%app ! (#%top . f))) ((temp6) (quote 10))) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp6) (#%app p (#%app ! temp6)))))
#f
(#%app toplevel-forcer)
#f
toplevel-forcer
((stepper-binding-type non-lexical))
(let-values (((p) (#%app ! (#%top . f))) ((temp6) (quote 10))) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp6) (#%app p (#%app ! temp6))))
((stepper-skip-double-break #t) (stepper-hint #<procedure:unwinder>))
(#%app ! (#%top . f))
((stepper-skipto (syntax-e cdr syntax-e cdr car)))
(#%top . f)
#f
(quote 10)
#f
(if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp6) (#%app p (#%app ! temp6)))
(((stepper-skipto (syntax-e cdr cdr both-l () (car)))) (stepper-skipto (syntax-e
 cdr cdr both-l () (car))))
(#%app p temp6)
#f
p
((stepper-binding-type let-bound))
temp6
((stepper-binding-type let-bound))
(#%app p (#%app ! temp6))
#f
p
((stepper-binding-type let-bound))
(#%app ! temp6)
((stepper-skipto (syntax-e cdr syntax-e cdr car)))
temp6
((stepper-binding-type let-bound))


- using test-proc

(#%app test-proc (lambda (x) (#%app lazy (lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2))))))))

((stepper-skipto (syntax-e cdr syntax-e cdr car)))

(lambda (x) (#%app lazy (lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2)))))))

((stepper-proc-define-name #<syntax:C:\Documents and Settings\Stephen Chang\My Documents\plt\sandbox\lazy-expand-test.rkt:1:9 f>) (stepper-define-type shortened-proc-define))

(#%app lazy (lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2))))))

#f

lazy

((stepper-binding-type non-lexical))

(lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2)))))


#f

(let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2))))


((stepper-skip-double-break #t) (stepper-hint #<procedure:unwinder>))

(#%app ! +)
((stepper-skipto (syntax-e cdr syntax-e cdr car)))
+
((stepper-binding-type non-lexical))
(quote 1)
#f
x
((stepper-binding-type lambda-bound))
(if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p))
 (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2)))
(((stepper-skipto (syntax-e cdr cdr both-l () (car)))) (stepper-skipto (syntax-e
 cdr cdr both-l () (car))))
(#%app p temp1 x2)
#f
p
((stepper-binding-type let-bound))
temp1
((stepper-binding-type let-bound))
x2
((stepper-binding-type let-bound))
(#%app p (#%app ! temp1) (#%app ! x2))
#f
p
((stepper-binding-type let-bound))
(#%app ! temp1)
((stepper-skipto (syntax-e cdr syntax-e cdr car)))
temp1
((stepper-binding-type let-bound))
(#%app ! x2)
((stepper-skipto (syntax-e cdr syntax-e cdr car)))
x2
((stepper-binding-type let-bound))
(#%app (#%app toplevel-forcer) (let-values (((p) (#%app ! (#%top . f))) ((temp6)
 (quote 10))) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-
procedure? p)) (#%app p temp6) (#%app p (#%app ! temp6)))))
#f
(#%app toplevel-forcer)
#f
toplevel-forcer
((stepper-binding-type non-lexical))
(let-values (((p) (#%app ! (#%top . f))) ((temp6) (quote 10))) (if (if (#%app la
zy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp6)
(#%app p (#%app ! temp6))))
((stepper-skip-double-break #t) (stepper-hint #<procedure:unwinder>))
(#%app ! (#%top . f))
((stepper-skipto (syntax-e cdr syntax-e cdr car)))
(#%top . f)
#f
(quote 10)
#f
(if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p))
 (#%app p temp6) (#%app p (#%app ! temp6)))
(((stepper-skipto (syntax-e cdr cdr both-l () (car)))) (stepper-skipto (syntax-e
 cdr cdr both-l () (car))))
(#%app p temp6)
#f
p
((stepper-binding-type let-bound))
temp6
((stepper-binding-type let-bound))
(#%app p (#%app ! temp6))
#f
p
((stepper-binding-type let-bound))
(#%app ! temp6)
((stepper-skipto (syntax-e cdr syntax-e cdr car)))
temp6
((stepper-binding-type let-bound))





Structure of annotate function:

annotate
    normal-break
    result-exp-break
    result-value-break
    normal-break/values
    exp-finished-break
    double-break
    wcm-pre-break-wrap
    pre-break-wrap
    break-wrap
    double-break-wrap
    return-value-wrap
    normal-break/values-wrap
    top-level-annotate/inner

    annotate/inner
        cond skipto or skipto/discard
             skip-completely
             else let:

        tail-recur
        non-tail-recur
        result-recur
        lambda-body-recur
        make-debug-info-normal
        make-debug-info-app
        outer-wcm-wrap
        wcm-break-wrap
        lambda-clause-abstraction
        outer-lambda-abstraction
        let-abstraction
        if-abstraction
        varref-abraction
        recertifier
        maybe-final-val-wrap

        kernel-syntax-case
            (#%plain-lambda . clause)
            (case-lambda . clauses)
            (if test then else)
            (begin . bodies-stx)
            (begin0 body)
            (begin0 first-body . bodies-stx)
            (let-values . _)
            (letrec-values . _)
            (set! var val)
            (quote _)
            (quote-syntax _)
            (with-continuation-mark key mark body)
            (#%plain-app . terms)
            (#%top . var-stx)
            var-stx
            else
    annotate/top-level
    annotate/module-top-level




Experiment: dump of clause, annotated clause, and free-varrefs in #%plain-lambda case of kernal-syntax in annotate/inner

----- deleted -----
see dump-annotate.rkt-annotateinner-plainlambda-lazy-proc.txt




Experiment: checking out what is happening outer lambda abstraction (only place where closure-table-put! gets called)
 - for both lazy-proc and test-proc, show-lambdas-as-lambdas = #t, procedure-name-info = #f and f (symbol f, not false), and closure-name = #f
 - i'm starting to think the problem is not in the annotation code



Experiment: dump of vals given to recon-value
  - when test-proc is used, body of lambda seems to be processed (evidenced by the 1), but body is not processed when lazy-proc is used (no 1)

----- deleted -----
see dump-reconstruct.rkt-revonvalue-val-closurerecord-lazy-proc.txt



TODO for tomorrow: 
 - look at how lambdas are reconstructed for both lazy-proc and test-proc - start in recon-value function?


--------------------------------------------------------------------------------
----- 7/1/2010 - LAPTOP
--------------------------------------------------------------------------------

Experiment: dump of vars given to stepper/private/reconstruct.rkt::recon-source-expr

 - using test-proc:
lazy + x p temp1 x2 p temp1 x2 p temp6 p temp6 lazy + x p temp1 x2 p temp1 x2 p
temp6 p temp6 lazy + x p temp1 x2 p temp1 x2 lazy + x p temp1 x2 p temp1 x2 lazy
 + x p temp1 x2 p temp1 x2 p temp6 lazy + x p temp1 x2 p temp1 x2 lazy + x p tem
p1 x2 p temp1 x2 lazy + x p temp1 x2 p temp1 x2 temp6 lazy + x p temp1 x2 p temp
1 x2 lazy + x p temp1 x2 p temp1 x2 temp6 lazy + x p temp1 x2 p temp1 x2 lazy +
x p temp1 x2 p temp1 x2 lazy + x p temp1 x2 p temp1 x2 lazy + x p temp1 x2 p tem
p1 x2 lazy + x p temp1 x2 p temp1 x2 lazy + x p temp1 x2 p temp1 x2 lazy + x p t
emp1 x2 p temp1 x2 lazy + x p temp1 x2 p temp1 x2 lazy + x p temp1 x2 p temp1 x2
 lazy + x p temp1 x2 p temp1 x2 lazy + x p temp1 x2 p temp1 x2 lazy + x p temp1
x2 p temp1 x2 p temp1 x2 lazy + x p temp1 x2 p temp1 x2 lazy + x p temp1 x2 p te
mp1 x2 temp1 x2 lazy + x p temp1 x2 p temp1 x2 lazy + x p temp1 x2 p temp1 x2 te
mp1 x2 lazy + x p temp1 x2 p temp1 x2 lazy + x p temp1 x2 p temp1 x2 x2 lazy + x
 p temp1 x2 p temp1 x2 lazy + x p temp1 x2 p temp1 x2 x2 lazy + x p temp1 x2 p t
emp1 x2 lazy + x p temp1 x2 p temp1 x2 lazy + x p temp1 x2 p temp1 x2 lazy + x p
 temp1 x2 p temp1 x2 lazy + x p temp1 x2 p temp1 x2 lazy + x p temp1 x2 p temp1
x2 lazy + x p temp1 x2 p temp1 x2 lazy + x p temp1 x2 p temp1 x2

 - using lazy-proc:
p temp6 p temp6 p temp6 p temp6 p temp6 temp6 temp6 lazy + x p temp1 x2 p temp1
x2 p temp1 x2 temp1 x2 temp1 x2 x2 x2



Experiment: dump of free-vars-captured after annotation in annotate/inner

- with lazy-proc:
(#<syntax:C:\Documents and Settings\Stephen Chang\My Documents\plt\sandbox\lazy-
expand-test.rkt:1:15 +>)
(#<syntax temp1>)
(#<syntax x2>)
(#<syntax:C:\Program Files\Racket-Full-5.0.0.1\collects\lazy\lazy.rkt:326:50 p>
#<syntax temp1> #<syntax x2>)
(#<syntax lazy> #<syntax:C:\Documents and Settings\Stephen Chang\My Documents\pl
t\sandbox\lazy-expand-test.rkt:1:15 +>)
(#<syntax:C:\Documents and Settings\Stephen Chang\My Documents\plt\sandbox\lazy-
expand-test.rkt:3:1 f>)
(#<syntax temp6>)
(#<syntax:C:\Program Files\Racket-Full-5.0.0.1\collects\lazy\lazy.rkt:326:50 p>
#<syntax temp6>)

- with test-proc
(#<syntax:C:\Documents and Settings\Stephen Chang\My Documents\plt\sandbox\lazy-
expand-test.rkt:1:15 +>)
(#<syntax temp1>)
(#<syntax x2>)
(#<syntax:C:\Program Files\Racket-Full-5.0.0.1\collects\lazy\lazy.rkt:326:50 p>
#<syntax temp1> #<syntax x2>)
(#<syntax lazy> #<syntax:C:\Documents and Settings\Stephen Chang\My Documents\pl
t\sandbox\lazy-expand-test.rkt:1:15 +>)
(#<syntax:C:\Documents and Settings\Stephen Chang\My Documents\plt\sandbox\lazy-
expand-test.rkt:3:1 f>)
(#<syntax temp6>)
(#<syntax:C:\Program Files\Racket-Full-5.0.0.1\collects\lazy\lazy.rkt:326:50 p>
#<syntax temp6>)



Experiment: dump of annotate.rkt::top-level-rewrite labels for all variables

 - with test-proc:
#%app non-lexical test-proc non-lexical lambda non-lexical x lambda-bound #%app
non-lexical lazy non-lexical lambda non-lexical p let-bound temp1 let-bound x2 l
et-bound #%app non-lexical ! non-lexical + non-lexical quote non-lexical x lambd
a-bound if non-lexical if non-lexical #%app non-lexical lazy-proc? non-lexical p
 let-bound quote non-lexical #%app non-lexical struct-constructor-procedure? non
-lexical p let-bound #%app non-lexical p let-bound temp1 let-bound x2 let-bound
#%app non-lexical p let-bound #%app non-lexical ! non-lexical temp1 let-bound #%
app non-lexical ! non-lexical x2 let-bound 

 - with lazy-proc:
#%app non-lexical lazy-proc non-lexical lambda non-lexical x lambda-bound #%app
non-lexical lazy non-lexical lambda non-lexical p let-bound temp1 let-bound x2 l
et-bound #%app non-lexical ! non-lexical + non-lexical quote non-lexical x lambd
a-bound if non-lexical if non-lexical #%app non-lexical lazy-proc? non-lexical p
 let-bound quote non-lexical #%app non-lexical struct-constructor-procedure? non
-lexical p let-bound #%app non-lexical p let-bound temp1 let-bound x2 let-bound
#%app non-lexical p let-bound #%app non-lexical ! non-lexical temp1 let-bound #%
app non-lexical ! non-lexical x2 let-bound 








TODO for tomorrow:
 - dump stuff in annotate/inner #%plain-app case and make sure everything is same for test-proc and lazy-proc (I did this already for #%plain-lambda case)





Experiment: dump of terms, annotated terms, and free varrefs for #%plain-app case in annotate/inner (outpouts are identical)

----- deleted -----




Experiment: dump of tail-args in #%plain-app case of annotate/inner (identical)

- using test-proc
all
all
all
(#<syntax arg0-1733>)
(#<syntax:C:\Program Files\Racket-Full-5.0.0.1\collects\lazy\lazy.rkt:329:22 p>
#<syntax temp6> #<syntax arg0-1733> #<syntax arg1-1734>)
(#<syntax:C:\Program Files\Racket-Full-5.0.0.1\collects\lazy\lazy.rkt:329:22 p>
#<syntax temp6> #<syntax arg0-1733> #<syntax arg1-1734>)
all

- using lazy-proc
all
all
all
(#<syntax arg0-1733>)
(#<syntax:C:\Program Files\Racket-Full-5.0.0.1\collects\lazy\lazy.rkt:329:22 p>
#<syntax temp6> #<syntax arg0-1733> #<syntax arg1-1734>)
(#<syntax:C:\Program Files\Racket-Full-5.0.0.1\collects\lazy\lazy.rkt:329:22 p>
#<syntax temp6> #<syntax arg0-1733> #<syntax arg1-1734>)
all



Tentative conclusion - annotated programs are the same whether using lazy-proc or test-proc; reconstruction seems different though

TODO: find where reconstruction differs



reconstruction call graph


files in stepper/private

model.rkt::go::break

     |
     V

reconstruct.rkt::
reconstruct-left-side (normal-break, normal-break/values)
reconstruct-right-side (result-exp-break, result-value-break)
reconstruct-double-break (double-break)

     |
     V

reconstruct-current


     |
     V

(left-side)
recon-value
reconstruct-current::recon

(right-side)
recon-value or recon-source-expr
reconstruct-current::recon

(double-break)
recon-source-expr
reconstruct-current::recon

     |
     V

reconstruct-current::recon calls either
  reconstruct-top-level or
  reconstruct-current::recon-inner

Structure of stepper/private/reconstruct.rkt

recon-value
skip-step?
skip-redex-step?
recon-source-expr
- calls skipto/auto with 'discard and the following transformer fn
    recur
    let-recur
    recon-basic
    recon-let/rec
    recon-lambda-clause
    kernel-syntax-case
        (#%plain-lambda . clause-stx)
        (case-lambda . clauses-stx)
        (if test then else)
        (it test then)
        (begin . bodies)
        (begin0 . bodies)
        (let-values . rest)
        (letrec-values . rest)
        (set! var rhs)
        (quote body)
        (with-continuation-mark . rest)
        (#%plain-app . terms)
        var-stx
        (#%top . var)
reconstruct-completed
reconstruct-top-level
reconstruct-left-side
reconstruct-right-side
reconstruct-double-break
reconstruct-current
    recon-inner
        recon-source-current-marks
        iota
        recon-let
        kernel-syntax-case
            id
            (#%top . id)
            (#%plain-app . terms)
            (if test then else)
            (if test then)
            (begin . terms)
            (begin0 body)
            (begin0 first-body . rest-bodies)
            (let-values . rest)
            (letrec-values . rest)
            (set! var rhs)
    recon



Experiment: dumping closure-records in recon-value in reconstruct.rkt

 - using lazy-proc
 - using test-proc
 - everything seems to be a closure-record (no #f's)

Experiment: dumping base-names of closure-records in recon-value in reconstruct.rkt
 - weird, nothing printed from the true branch of if closure-records, even though in the previous experiment, everythings was showing as a closure-record
    - because closure-record is also a function - needed to use let*
 - trying to print something in the false branch of if closure-records (the rendered)
    - it seems like where test-proc has 1, lazy-proc has lazy.rkt:206:19 (which is the start of the (lambda ...) expr


----- deleted -----
see dump-reconstruct.rkt-revonvalue-val-closurerecord-lazy-proc.txt



Continuation Marks creation call graph:

stepper/private/marks.rkt::

make-debug-info

     |
     V

make-full-mark


     |
     V

make-make-full-mark-varargs

     |
     V

make-full-mark-struct
(define-struct full-mark-struct (source label bindings values))


--------------------------------------------------------------------------------
----- 7/2/2010 - LAPTOP
--------------------------------------------------------------------------------

Experiment: all keys added to closure table

- using lazy-proc:
#<procedure:...ts\lazy\lazy.rkt:207:19>
#<procedure:...ts\lazy\lazy.rkt:339:29>

- using test-proc
#<procedure:...ts\lazy\lazy.rkt:207:19>
#<procedure:...ts\lazy\lazy.rkt:339:29>




lookup-binding call graph:

stepper/private/

reconstruct.rkt::(various functions)

     |
     V

marks.rkt::

lookup-binding.rkt

     |
     V

lookup-first-binding

     |
     V

lookup-all-bindings
(for all marks, returns list of binding-value pairs where binding matches specified binding)
     |
     V

binding-matches
(for one mark, returns list of binding-value pairs where binding matches specified binding)
     |
     V

mark-bindings
(returns list of binding-value pairs)
     |
     V

full-mark-struct-bindings
full-mark-struct-values	



--------------------------------------------------------------------------------
----- 7/3/2010 - LAPTOP
--------------------------------------------------------------------------------


Call Graph - making a mark:

stepper/private/annotate.rkt::annotate:annotate/inner::
make-debug-info-normal (called by normal-bundle, if-abstraction, varref-abstraction, annotate/inner)
make-debug-info-app (outer-lambda-abstraction, annotate/inner)
make-debug-info-let (let-abstraction)
make-debug-info-fake-exp (let-abstraction)
make-debug-info-fake-exp/tail-bound (annotate/inner

     |
     V

stepper/private/marks.rkt::

make-debug-info
  source tail-bound free-vars label lifting

     |
     V

make-full-mark
  source label bindings
(creates syntax of a thunk where body is app:
   ( (make-make-full-mark-varargs source label bindings) 
     (map make-mark-binding-stx bindings) )

     | (when thunk is forced)           |
     V                                  V

make-make-full-mark-varargs      make-mark-binding-stx
  source label bindings
     |
     V

make-full-mark-struct
  source label bindings values
  (values is arg of lambda)



- lambda and lambda wrapped with lazy-proc print as the same!
  (see lazy-proc-print-test.rkt)

- if I apply the following fn to val before giving it to closure-table-lookup (this is in recon-value in reconstruct.rkt), then the function displays properly!

(lambda (val) 
    (if (procedure? val)
        (let ([targ (procedure-extract-target val)])
            (if targ
                targ
                val))
        val))


some various notes:
- equal-hash-code generates hash code for hash table entries
- struct procedures (ie - lambdas wrapped with lazy-proc) return #f when given to struct? - this seems counterintuitive



--------------------------------------------------------------------------------
----- 7/5/2010 - LAPTOP
--------------------------------------------------------------------------------

- download and install Racket Full 5.0.0.6 7/5/2010 build
 - note cant have "info" in any files with .rkt extension? - I had "copy of info.rkt" and it was messing things up so that stepper button wasnt showing up?
 - actually I think the problem was that the copied info.rkt file had a previous date and wasnt getting compiled - need to delete info compiled files (.zo and .dep) to get stepper button to show up
 
 - copied over info.rkt and lazy-tool.rkt to lazy/ and deleted info.zo and info.dep compiled files
 - ran setup-plt -D
 - copied over define-values case in annotate/top-level in annotate.rkt
 - copied over change to ~define and !*app in lazy.rkt
 - copied change to recon-value in reconstruct.rkt so struct wrapped procedures are extracted



Summary of changes to displaying fns defined with define in lazy racket:
 - changed displaying of this program (define (f x) (+ x 1))

from:

(define f (lambda (a1) ...))

to:

(define (f x)
  (lazy (lambda () (+ 1 x))))

- notes about this
 - dont actually need custom unwinder in ~define
 - therefore, dont need to change unwind in macro-unwind.rkt to use unwind instead of recur-on-pieces


Test program expansion:

running:

mzc --expand "\Documents and Settings\Stephen Chang\My Documents\plt\sandbox\lazy-expand-test.rkt"


on: 
(module test lazy  
  (define (f x) (+ 1 x))
  (f 10)
)

gives:

(module test lazy
  (#%plain-module-begin
   (#%require (for-syntax scheme/mzscheme))
   (define-values
    (f)
    (#%app
     lazy-proc
     (lambda (x)
       (#%app
        lazy
        (lambda ()
          (let-values (((p) (#%app ! +)) ((temp1) '1) ((x2) x))
            (if (if (#%app lazy-proc? p)
                  '#t
                  (#%app struct-constructor-procedure? p))
              (#%app p temp1 x2)
              (#%app p (#%app ! temp1) (#%app ! x2)))))))))
   (#%app
    (#%app toplevel-forcer)
    (let-values (((p) (#%app ! f)) ((temp3) '10))
      (if (if (#%app lazy-proc? p) '#t (#%app struct-constructor-procedure? p))
        (#%app p temp3)
        (#%app p (#%app ! temp3)))))))


Stepper steps: see stepper_steps_2010-07-05.txt for test-program1


TODO tomorrow: learn more about what stepper-skipto and skipto/auto are doing

--------------------------------------------------------------------------------
----- 7/6/2010 - LAPTOP
--------------------------------------------------------------------------------

- stepper-recertify in annotate.rkt calls syntax-recertify, which copies certificates from old syntax to a new target syntax


ToDo ToTry: expand beginner program with local - annotation of local may give hints on how to hide defines that are the result of lets in lazy racket?

- tried to annotate the toplevel case in ~!%app in lazy.rkt with 'stepper-skipto (append skipto/cdr skipto/second), but I got an error in find-special-value in reconstruct.rkt
 - hit the error case because the operand of the app wasnt another app
 - find-special-value is called by reset-special-values with name = 'list and valid-args = '(3)
 - somehow this expression (in find-special-value in reconstruct.rkt):
(expand (cons name valid-args)) = (expand (cons 'list '(3)))
expands to: 
(#%app (#%app toplevel-forcer) (let-values (((p) (#%app ! list)) ((temp3) (quote 3))) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp3) (#%app p (#%app ! temp3)))))
    - ok I guess this makes sense, it's the lazy expansion of (list 3)

 - reset-special-values is called in break in model.rkt as part of the "iter" lambda parameter to program-expander (break is local fn in go in model.rkt and program-expander is parameter to go)
 - reset-special-values sets two global variables: special-list-value and special-cons-value

Solution: added extra case to find-special-value (in reconstruct.rkt) to handle lazy-racket case and the annotation worked!!!
 - I needed to get rid of the double-break annotation in !*app, otherwise the first step would not show up at all




Call Graph: Stepper

stepper/

stepper-tool.rkt::stepper-unit-frame-mixin::stepper-button-callback

     |
     V

view-controller.rkt::go
 - called with current frame and stepper-tool.rkt::stepper-unit-frame-mixin::program-expander params

     |
     V

private/model.rkt::go
 - called with view-controller.rkt::go::program-expander-prime as param, which just wraps init param of stepper-tool.rkt::stepper-unit-frame-mixin::program-expander with custodian (iter param is not changed)

     |
     V

view-controller.rkt::go::program-expander-prime

     |
     V

stepper-tool.rkt::stepper-unit-frame-mixin::program-expander




Control Flow: iter parameter of stepper-tool.rkt::stepper-unit-frame-mixin::program-expander:
(created by stepper/private/model.rkt::go)

(lambda (expanded continue-thunk)
     (r:reset-special-values)
     (if (eof-object? expanded)
         (begin
           (receive-result (make-finished-stepping)))
         (step-through-expression expanded continue-thunk)))

- follows call graph above until given as param to:

drscheme:eval:expand-program

from racket help:

The first argument to iter is the expanded program (represented as syntax) or eof. The iter argument is called for each expression in the expanded program and once more with eof, unless an error is raised during expansion. It is called from the user’s thread. If an exception is raised during expansion of the user’s program, iter is not called. Consider setting the exception-handler during init  to handle this situation.

The second argument to iter is a thunk that continues expanding the rest of the contents of the definitions window. If the first argument to iter was eof, this argument is just the primitive void.


--------------------------------------------------------------------------------
----- 7/7/2010 - LAPTOP
--------------------------------------------------------------------------------

Next Task:

!*app in lazy.rkt introduces a let, but lets evaluate to a series of defines. In the lazy stepper, I want to hide these defines

ie - (let ([x ...] [y ...] ...) body) steps to (define x ...) (define y ...) ... body

- I think I will need to add a case to top-level-rewrite in annotate.rkt so identify when the defines come from a lazy racket introduced let, because it's not possible to annotate macros not in lazy racket (for a somewhat similar example, see cond in the beginner language and how it's handled in top-level-rewrite - it needs to check 'origin syntax-property and then uses 'comes-from-cond stepper-hint)

Where are the series of defines coming from?
 - unwind-define converts a define-values to a define (for non-lambda rhs)
 - they must be coming from the eval of the let?


TODO tomorrow:
 - figure out exactly what happens (ie - sequence of fn calls - from annotation to reconstruction) when the stepper "takes a step"
 - is there any way for the stepper to preserve stepper properties across a step?


--------------------------------------------------------------------------------
----- 7/8/2010 - LAPTOP
--------------------------------------------------------------------------------


Call Graph: what happens when stepper takes a step

files in stepper/

- private/model.rkt::go calls program-expander in stepper-tool.rkt with init and iter fns

- stepper-tool.rkt::stepper-unit-frame-mixin::program-expander calls drracket:eval:expand-program with iter

- iter is invoked once per (expanded) expression in def window
  - for test program, iter is called twice, once for f fn def and once for app of f

- iter calls private/model.rkt::go::step-through-expression with each expanded expr

- step-through-expression annotates given expr, evals it, and then evals the thunk that was given by drracket:eval:expand-program (to get to the other exprs in the def window)

expr #1

- the annotated f def looks like:
    (begin <annotated f fn def>
           (exp-finished-break (list (list (lambda () exp) 
                                           #f 
                                           (lambda () (list f))))))
   where exp is the unannotated expanded def of f

- annotate.rkt::annotate::exp-finished-break calls model.rkt::go::break with params:
    mark-set = #f
    break-find = 'exp-finished-break
    returned-value-list = (list (list (lambda () exp) #f (lambda () (list f))))

- when break-find is 'exp-finished-break, break applies add-to-finished to each element of returned-value-list

- add-to-finished appends (list (list (lambda () exp) #f (lambda () (list f)))) to the end of finished-exps, where
    exp-thunk = (lambda () exp)
    index = #f
    getter = (lambda () (list f))

- finished-exps used by model.rkt::go::break::reconstruct-all-completed
   - forces source thunk
   - checks if thunk has stepper-hide-completed property
   - if not, calls reconstruct.rkt::reconstruct-completed withed the forced source exp
   - depending on result of reconstruct-completed, calls macro-unwind.rkt::unwind

- reconstruct-all-completed used by model.rkt::go::break


expr #2
- annotated (f 10) first calls annotate.rkt::annotate::double-break, which calls break with current-continuation-marks and break-kind = 'double-break
  - there is a double break beause the expanded expr is a let-values and double-breaks always occur at the beginning of a let evaluation

- in the double-break case of break:
  - call reconstruct-all-completed (but finished-exps is still empty here???)
    - ok i think it's just here in case there's something, so we can append to it
  - call reconstruct.rkt::reconstruct-double-break with the mark-list, which calls reconstruct-current with break-kind = 'double-break
  - in the double-break case of reconstruct-current:
    - call recon-source-expr with car of mark-list, both with and without bindings (assuming car of mark-list is let) from let
      - when recon-source-expr is called with bindings, add stepper-lifted-name property to those bindings???
    - call recon with both versions the recon'ed car of mark-list (and rest of mark-list) and return as list of two elements
      - the first param of recon accumulates the marks recon'ed so far
      - recon just iterates over the rest of the (unreconstructed) mark-list, calling either reconstruct-top-level or reconstruct-current::recon-inner, depending on the label in the mark
  - unwind elements of 2 element returned list and use first as lhs and second as rhs
  - make append unwound elements to previous finished-exp and create make-before-after-result and give to receive-result, which is parameter of model.rkt::go (2nd param)
    - the fn given by view-controller.rkt::go is view-controller.rkt::go::hand-off


- expr #2 then sets from variables (see comments in annotate.rkt::annotate::annotate/inner::let-abstraction)

- then calls exp-finished-break with some variables

- the rest of the expression is annotated using with-continuation mark where the body of the wcm has the structure:

(begin (normal-break) 
       (result-value-break <some-variable>))


TODO tomorrow:
 - figure out how a let gets transformed into a series of defines
 - check out what happens in break when break-kind is 'normal-break and when break-kind is 'result-value-break
 - want to somehow annotate after a step
   - idea: annotate "left side" and transfer to "right side"
   - see double-break case in model.rkt::go::break



--------------------------------------------------------------------------------
----- 7/26-27/2010 - LAPTOP
--------------------------------------------------------------------------------


- difference between a "values" break and a regular break (ie - result-exp-break vs result-value-break, and normal-break vs normal-break/values) is the "values" break passes an additional "vals-list" param to break
  - the "vals-list" param is the result of evaluating the exp around which the break is wrapped

BREAK TYPE (FN NAME)  | WRAP FN NAME
----------------------------------------------------
normal-break          | break-wrap*
normal-break/values   | normal-break/values-wrap**
result-exp-break      | pre-break-wrap*
result-value-break    | return-value-wrap**
expr-finished-break / | make-define-struct-break***
exp-finished-break    |
double-break          | double-break-wrap*

* = (begin (break-fn) exp)
** = (call-with-values 
       (lambda () exp)
       (lambda (args)
         (break-fn args)
         (values args)))
*** = returns thunk with call to break and 'expr-finished-break break type (marks = #f)

wcm-wrap in marks.rkt:
(define (wcm-wrap marks expr)
  (wcm debug-key marks expr))

wcm-pre-break-wrap in annotate.rkt:
 - like wcm-wrap except wraps pre-break-wrap around exp

outer-wcm-wrap in annotate.rkt::annotate/inner:
 - gets set to wcm-pre-break-wrap if pre-break? = #t
 - gets set to wcm-wrap           if pre-break? = #f

wcm-break-wrap in annotate.rkt::annotate/inner:
 - like wcm-wrap except uses outer-wcm-wrap and wraps break-wrap around exp



- pre-break? in annotate/inner is #t in tail-recur and lambda-body-recur



--------- When are each of the break types used (in annotate/inner)? ----------
normal-break
- used by break-wrap, wcm-break-wrap
- used in #%plain-app case
- used in begin0 case
- used in varref-abstraction, var-stx case


normal-break/values
- used by normal-break/values-wrap
- used in let-abstraction, let-values, letrec-values case


result-exp-break
- used by pre-break-wrap, wcm-pre-break-wrap, and sometimes wcm-break-wrap (when pre-break = #t)
- used in let-abstraction (if outermost? = #f, ie - if not first expr in body)
- used in begin0 case (if not first-time?, ie - not first expr in begin)
wcm-break-wrap used in:
- used in varref-abstraction, in varref-break-wrap and top-level-varref-break-wrap
- used in begin0 case
outer-wcm-wrap used in (always as outer wrap):
- let-abstraction
- if-abstraction
- varref-abstraction, varref-no-break-wrap
- set! case
- #%plain-app case



result-value-break
- used by return-value-wrap
- wrapped around the var in varref-break-wrap
- used in set! case
- used in let-body of #%plain-app case


expr-finished-break
- used by exp-finished-break, make-define-struct-break
- used in annotate/module-top-level when there is a stepper-define-struct-hint property
- used in let-abstraction
- used in maybe-final-val-wrap, when there is 'stepper-use-val-as-final property
- in define-values case in annotate/module-top-level


double-break
- used by-double-break-wrap
- used in let-abstraction



--------- What does model.rkt::go::break do? ----------

- what does reconstruct-all-completed do?
for each expr in finished-exps:
1) forces thunk
2) calls reconstruct.rkt::reconstruct-completed
3) unwinds
-) skips expr if it has stepper-hide-completed property


- held-exp-list contains lhs exprs
  - gets init to the-no-sexp



- then it depends on BREAK TYPE:

--- normal-break, normal-break/values ---
1) set held-finished-list to result of reconstruct-all-completed
2) call reconstruct.rkt::reconstruct-left-side with mark list and returned-value-list
3) lifts result
4) unwind
5) stores result in held-exp-list



--- result-exp-break, result-value-break ---
1) create thunk for rhs:
  a) call reconstruct.rkt::reconstruct-right-side with mark list and returned-value-list
  b) lifts result
  c) unwind
2a) if held-exp-list is skipped step, reset it to the-no-sexp
2b) if held-exp-list is the-no-sexp, call send-result with before-after-result where before is result of reconstruct-all-completed, and after is result of forcing rhs thunk
2c) if held-exp-list is some held exps:
  a) add held-exps to end of held-finished-list and use as lhs
  b) add result of forcing rhs thunk to result of reconstruct-all-completed and use as rhs
  c) send result (resets held-exp-list to the-no-sexp)



--- double-break ---
- held-exp-list should be the-no-sexp
1) call reconstruct.rkt::reconstruct-double-break with mark list to get pair of exprs
2) lift 1st of pair and unwind and use as lhs
3) lift 2nd of pair and unwind and use as rhs
4) add lhs to end of reconstruct-all-completed and rhs to end of reconstruct-all-completed and send result



--- expr-finished-break ---
for each expr in returned-value-list:
1) add to finished-exps




- reconstruct-left-side, -right-side, and -double-break call reconstruct.rkt::reconstruct-current with either 'left-side, 'right-side, or 'double-break as the "break kind" (in addition to the mark-list and return-value-list)


---------- what does reconstruct-current do? ---------

- recon-inner
- recon

--- left-side ---
1) if return-value-list exists (break was normal-break/values)
  a) call recon-value on 1st element of return-value-list (there should be only 1 value)
  b) otherwise use nothing-so-far as the result
2) call recon with that result and mark list


--- right-side ---
1) if return-value-list exists (break was result-value-break)
  a) call recon-value on 1st element of return-value-list (there should be only 1 value)
  b) otherwise call recon-source-expr with the first expr in mark list and entire mark list
2) mark that result as highlight
3) call recon with that result and rest of mark list



--- double-break ---
1) call recon-source-expr with first expr in mark list (should be let) (and entire mark list)
2) mark result as highlight
3) call recon with result and rest of mark list

4) call recon-source-expr with first expr in mark list (should be let) (and entire mark list) and vars from let
5) mark result as highlight
6) call recon with result and rest of mark list

7) return two results as pair




TODO tomorrow: 
- add more fine-grained descriptions of when each break type is used
- check what recon-value, recon (in reconstruct-current), recon-source-expr, and reconstruct-completed do?




--------------------------------------------------------------------------------
----- 7/28/2010 - LAPTOP
--------------------------------------------------------------------------------


- in annotate.rkt::annotate/inner::let-abstraction, shared.rkt::get-lifted-var is called once for each var bound by the let
  - lifted vars look something like lifted-x-#, where x is the original name of the variable and # is an index that gets incremented every time get-lifted-var is called


---------- What does reconstruct.rkt::reconstruct-completed do? ----------
1a) turns variables and value(s) into a define
1b) handles stepper-define-struct-hint
1c) handles stepper-use-val-as-final
1d) o.w. uses vals-getter



---------- What does reconstruct.rkt::recon-value do? ----------
if val is closure
  then look it up in closure table and call recon-source-expr
  else render it using print-convert



---------- What does reconstruct.rkt::recon-source-expr do? ----------
- uses skipto/auto




---------- What does reconstruct.rkt::reconstruct-current::recon do? ----------




TODO tomorrow:
- figure out how to hide defines that get generated from let in lazy app
- fix body of the let to not use vars bound by let
- you've identified when a let comes from lazy racket, now wrap the defines that come from the let with stepper-skip-completely






--------------------------------------------------------------------------------
----- 7/29/2010 - LAPTOP
--------------------------------------------------------------------------------


- added 'comes-from-lazy case in reconstruct.rkt::hide-completed? (called by model.rkt::go::break::reconstruct-all-completed)

- in, annotate.rkt::annotate/inner::let-abstraction, add 'comes-from-lazy = #t stepper-syntax-property, to let clauses in exp-finished-clauses
  - TODO: add check to only add this property if original stx had it 
      - DONE 7/30/2010





TODO tomorrow:
- figure out how application gets annotated
  - I suspect it gets annotated as a sequence of partially evaluated steps, where one more subterm gets evaluated at each step
- also look at how app gets reconstructed
- add check in annotate.rkt::annotate/inner:let-abstraction to only add 'comes-from-lazy stepper-syntax-property if original let had the property - DONE 7/30/2010





--------------------------------------------------------------------------------
----- 7/30/2010 - LAPTOP
--------------------------------------------------------------------------------

- stepper steps are buffered in an async channel, using async-channel-put, and are retrieved using async-channel-get

- the receive-result param of model.rkt::go converts the received before-and-after result and converts it to a step, and adds to the view-history async-channel, where it gets retrieved by start-listener-thread

- in annotate.rkt::annotate/inner::let-abstraction, add 'comes-from-lazy property to let body (only in bodies length = 1 case)
 - TODO: add check to add this property only if original let (stx param) has it
    - DONE 7/30/2010
 - TODO: add this property to bodies length > 1 case also (just add to first one?)

- added steps-to-skip var in model.rkt::go, used in break to skip over a specified number of steps
example:
if we have the following stepper steps:
0: a -> b
1: b -> c
2: c -> d
3: d -> e

and we want to skip 2 steps starting at 0, then the stepper will display:
0: a -> e


- in lazy.rkt::!*app, we definitely do not want the stepper-skip-double-break property. this way, we can unwind the let directly to get the application to display propertly initially




--------------------------------------------------------------------------------
----- 8/4/2010 - LAPTOP
--------------------------------------------------------------------------------

TODO tommorrow:
- implement find-highlighted-expr fn in model.rkt::go::break
- use find-highlighted-expr instead of entire expr when checking 'comes-from-lazy
  - there exists a find-highlight fn in lifting.rkt



--------------------------------------------------------------------------------
----- 8/4/2010 - LAPTOP
--------------------------------------------------------------------------------

TODO tommorrow:
- body of let in a lazy app is currently annotated with 'comes-from-lazy-app-let-body property
- document steps-to-skip system in model.rkt::go::break