--------------------------------------------------------------------------------
----- 6/24/2010 - HOME PC
--------------------------------------------------------------------------------

- dl and install Racket Full 6/24/2010 nightly build
- copied over lazy/info.rkt and lazy/lazy-tool.rkt so stepper button would show up (must run setup-plt to register changes (use -D option, it's doesnt build docs so it's quicker)

Tried to step test program:
(define (f x) (+ 1 x))
(f 10)

Error Message:
annotate/top-level: unexpected top-level expression: (define-values (f) (#%app lazy-proc (lambda (x) (#%app lazy (lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2)))))))))

Solution:
A cond clause seems to have been removed from annotate/top-level in stepper/private/annotate.rkt (it's there on the version in my laptop)

Added clause: [(define-values (ids ...) bodies) (annotate/module-top-level exp)]



Error Message:
Internal stepper error: time to resync with simple-module-based-language-convert-value

Solution:
cond clause missing in simple-module-based-language-convert-value in stepper/stepper-tool.rkt

Added clause: [(print) value]

(TODO: eventually, I want Lazy Racket to use the 'constructor print style as default, but I havent been able to figure out how to do that yet)


- It works!

Output: 
(define f
  #(struct:lazy-proc
    #<procedure:...ate\annotate.rkt:809:52>))
((#<procedure:parameter-procedure>)
 (let ((p f) (temp6 10))
   (if (if (lazy-proc? p)
         #t
         (struct-constructor-procedure?
          p))
     (p temp6)
     (p temp6))))


- changed print style to 'constructor

Output:
(define f
  |...ate\annotate.rkt:809:52|)
((parameter-procedure)
 (let ((p f) (temp6 10))
   (if (if (lazy-proc? p)
         true
         (struct-constructor-procedure?
          p))
     (p temp6)
     (p temp6))))


- uncommented stepper-skipto annotation in !*app in lazy/lazy.rkt

Output:
(define f
  |...ts\lazy\lazy.rkt:124:48|)
((parameter-procedure)
 (let ((p f) (temp6 10))
   (p temp6)))


- trying to wrap output of ~!%app in lazy/lazy.rkt with stepper-annotate function
 - wrapped around (toplevel?) clause, got error: 
#%plain-app: bad syntax in: (#%plain-app (#%plain-app parameter-procedure) (let-values (((p) f) ((temp6) (quote 10))) (#%app p temp6)))

 - wrapped around else clause, no effect - same as if stepper-annotate wasnt used


Experiment:
- added a test clause in unwinder in ~!%app in lazy/lazy.rkt to see if unwinder gets called - it worked (error gets raised)
test clause: [_ (raise-syntax-error 'hi "testing...")]

- moved test clause to be last clause in unwinder to see if first clause matches - error gets raised again, which means first clause didnt get matched


Experiment:
- trying to move stepper-annotate to !*app in lazy/lazy.rkt - applied stepper-annotate to quasisyntax/loc expr - pattern in unwinder still not matched
- if I remove the raise-syntax-error clause, the error is:
let-values: bad syntax in: (let-values (((p) f) ((temp6) (quote 10))) (#%app p temp6))

Experiment:
- trying to change the pattern in unwinder to match the expression I'm working with (removed stepper-skip-double-break property for now):
(define (unwinder stx rec)
      (syntax-case stx (!)
        [(let-values ([(_p) f] [(_y) x] ...) _body)
         (with-syntax ([(f x ...) (rec #'(f x ...))])
           #'(f x ...))]))

It worked! Output:
(define f
  |...ts\lazy\lazy.rkt:124:48|)
((parameter-procedure) (f 10))
->
(define f
  |...ts\lazy\lazy.rkt:124:48|)
(force (f 10))
->
(define f
  |...ts\lazy\lazy.rkt:124:48|)
(define p_0 f)
(define temp6_0 10)
(force (p_0 temp6_0))
->
(define f
  |...ts\lazy\lazy.rkt:124:48|)
(define p_0
  |...ts\lazy\lazy.rkt:124:48|)
(define temp6_0 10)
(force
 (|...ts\lazy\lazy.rkt:124:48|
  temp6_0))
->
(define f
  |...ts\lazy\lazy.rkt:124:48|)
(define p_0
  |...ts\lazy\lazy.rkt:124:48|)
(define temp6_0 10)
(force
 (|...ts\lazy\lazy.rkt:124:48|
  10))
->
(define f
  |...ts\lazy\lazy.rkt:124:48|)
(define p_0
  |...ts\lazy\lazy.rkt:124:48|)
(define temp6_0 10)
(force
 (...
  (lazy (lambda () (+ 1 10)))
  ...))
->
(define f
  |...ts\lazy\lazy.rkt:124:48|)
(define p_0
  |...ts\lazy\lazy.rkt:124:48|)
(define temp6_0 10)
(force (delay ...))
->
(define f
  |...ts\lazy\lazy.rkt:124:48|)
(define p_0
  |...ts\lazy\lazy.rkt:124:48|)
(define temp6_0 10)
(define p_0 +)
(define temp1_0 1)
(define x2_0 10)
(... (p_0 temp1_0 x2_0) ...)

(13 steps total)



- adding back stepper-skip-double-break property

Output:
(define f
  |...ts\lazy\lazy.rkt:124:48|)
((parameter-procedure) (f 10))
->
(define f
  |...ts\lazy\lazy.rkt:124:48|)
(force (f 10))
->
(define f
  |...ts\lazy\lazy.rkt:124:48|)
(define p_0
  |...ts\lazy\lazy.rkt:124:48|)
(define temp6_0 10)
(force
 (|...ts\lazy\lazy.rkt:124:48|
  temp6_0))
->
(define f
  |...ts\lazy\lazy.rkt:124:48|)
(define p_0
  |...ts\lazy\lazy.rkt:124:48|)
(define temp6_0 10)
(force
 (|...ts\lazy\lazy.rkt:124:48|
  10))

(11 steps total)


TODO tomorrow:
1) read stepper internal docs more carefully
2) reread lazy code and lazy srfi docs


--------------------------------------------------------------------------------
----- 6/25/2010 - HOME PC
--------------------------------------------------------------------------------

- Functions defined with define (ie - (define (f x) (+ x 1)) ) in the Beginner languages are displayed the same way in the Stepper regardless of whether the Output Style in the Choose Language menu is 'constructor or 'quasiquote or 'write

- extended lazy language class (which implements module-based-language<%> - in drracket/private/language.rkt) and overrode default-settings and default-settings? methods so that the default print-style was 'constructor
 - ran setup-plt and stepper prints functions as lambdas with Lazy Racket
 - I tried experimenting with the pretty-print-depth parameter (#f = all depths printed, instead of "...") previously to show the entire lambda but was not successful

Weird behavior:
- when I change something in lazy.rkt and restart DrRacket, fns in the stepper display as line numbers -- (define f |...ts\lazy\lazy.rkt:131:25|) -- but when I re-run setup-plt (both with undoing and not undoing the changes), fns go back to being displayed as lambdas
  - yes this makes sense, because the source of the syntax is in the changed file so you need to recompile to make them show up properly

observation:
- There are two ways to add a property to some syntax (or other similar operations) (is this true?)
 1) use with-syntax
 2) use quasisyntax and escape when calling stepper-syntax-property, etc


Trying to get fns defined with define (and not using lambda) to display properly in stepper:

Experiment: 
- trying to use stepper-define-type stepper-syntax property to do it (Beginner languages use this property)

- doesnt seem to be working
- it works! if I remove the lazy-proc wrapping the lambda (so if I use just lambda instead of ~lambda)

Possible solutions:
1) add case in unwind-define in stepper/private/macro-unwind.rkt for functions that use ~lambda
2) add custom unwinder using stepper-hint like in !*app in lazy/lazy.rkt

TODO tomorrow:
1) finish implementing displaying of fns defined with define (see possible solutions above)

--------------------------------------------------------------------------------
----- 6/28/2010 - LAPTOP
--------------------------------------------------------------------------------

- module-identifier=? in mzscheme is the same as free-identifier=? in racket/base


--------------------------------------------------------------------------------
----- 6/29/2010 - LAPTOP
--------------------------------------------------------------------------------

- somehow, when using the custom unwinder, the body of the lambda gets quoted, but when using unwind-define in stepper/private/macro-unwind.rkt, there is no quote, even though both functions are the same and get they get the same inputs - THIS ISNT QUITE RIGHT, see below
  - finally figured it out! The custom unwinder was using recur-on-pieces (as specified in unwind in stepper/private/macro-unwind.rkt) to recursively unwind the body of the function but unwind-define was using unwind as the recursive call
    - I changed the recursive call in unwind in stepper/private/macro-unwind.rkt to use unwind instead of recur-on-pieces

- the recur-on-pieces doesnt add the quote, it just doesnt get rid of it. the unwind fn has a syntax-case clause in fall-through that gets rid of the quote; I still dont know why adding lazy-proc adds a quote
  - it seems like something funny is happening during annotation of lazy-proc - probably because it's a struct constructor and not a real function, so that the stepper doesnt quite know how to reconstruct it, and so that's why we get the funny results with the quote and the dots
  something like (lazy-proc (lambda (x) (+ 1 x))) is getting annotated and reconstructed as (quote (lambda (a1) ...)) where the quote and the dots are part of the actual output

- the 'stepper-define-type stepper-syntax-property seems to be lost when I add lazy-proc around the lambda


Call Graph: stepper/private/macro-unwind.rkt::unwind

stepper/private/model.rkt
  break:reconstruct-all-completed
  break (not skip-step, normal-break, normal-break/values)
    - applied to results of reconstruct.rkt::reconstruct-left-side
  break (not skip-step, result-exp-break, result-value-break)
    - applied to results of reconstruct.rkt::reconstruct-right-side
  break (not skip-step, double-break)
    - applied to results of reconstruct.rkt::reconstruct-double-break

          |
          V

stepper/private/macro-unwind.rkt::unwind



Call Graph: stepper/private/reconstruct.rkt::reconstruct-current

stepper/private/reconstruct.rkt
  reconstruct-left-side
  reconstruct-right-side
  reconstruct-double-break

          |
          V

stepper/private/reconstruct.rkt::reconstruct-current


- trying now to just use stepper-skipto to skip the lazy-proc application
  - the 'stepper-define-type stepper-syntax-property still seems to be lost when I add lazy-proc around 
    - trying to add the stepper-define-type property around the lazy-proc instead of around the lambda (and hopefully it gets transferred over?)the lambda
      - didnt work


TODO tomorrow:
 - look at stepper/private/reconstruct.rkt::recon-value
   - this is the function that inserts the quote
     1) it's because stepper/private/shared.rkt::closure-table-lookup returns #f
     2) also, the dots comes from render-settings-render-to-sexp, I think?
       - look in stepper/stepper-tool.rkt at stepper:render-to-sexp and simple-module-based-language-convert-value
 - check stepper/private/annotate.rkt::top-level-rewrite to see what kind of label lazy-proc gets (ie - macro-bound, non-lexical, etc)
   - print out stepper-binding-type given by top-level-rewrite for each var case
     - lazy-proc is 'non-lexical
   - labels are used in var (used in varref-abstraction in annotate::annotate/inner



--------------------------------------------------------------------------------
----- 6/30/2010 - LAPTOP
--------------------------------------------------------------------------------

 - stepper/private/annotate.rkt::return-value-wrap - calls return-value-wrap-maker - adds specified breakpoint and deals with multiple values
 - stepper/private/annotate.rkt::break-wrap adds a normal-break
 - annotate/inner::wcm-break-wrap adds a break-wrap to the expr before calling outer-wcm-wrap
 - annotate.rkt::wcm-pre-break-wrap adds pre-break-wrap to expr before calling wcm-wrap (pre-break-app adds result-exp-break)
 - stepper/private/marks.rkt::wcm-wrap makes the standard call to wcm with key 'debug-key

Annotating vars:
 - if var is not lexical but is from current module, add a break; otherwise, dont add a break


Experiment: see what happens if lambdas in lazy racket are wrapped with regular function (defined in module, ie - in lazy.rkt)

1) wrap with fn (define (test-proc x) x) defined in lazy.rkt
 - most things worked
   - using stepper-skipto (append skipto/cdr skipto/second)
   - using kernal-syntax-case* with literal #%app and pattern (#%app xx body) for function body, xx gets bound to 'test-proc
   - works when test-proc is in another file that is required


Experiment: what happens in annotate.rkt::varref-abstraction for various vars
  - interesting, neither test-proc nor f shows up as a parameter to varref-abstraction
    - dump: lazy private/promise.rkt + (quote #%kernel) toplevel-forcer (lib lazy/lazy.rkt)
  - dump is the same when test-proc is replaced with lazy-proc


Experiment: dumping all the exprs that get annotated by stepper/private/annotate.rkt::annotate::annotate/inner (using stepper-skipto for lazy-proc/test-proc)

- when using lazy-proc:
(#%app lazy-proc (lambda (x) (#%app lazy (lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2))))))))

(lambda (x) (#%app lazy (lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2)))))))


(#%app lazy (lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2))))))

lazy

(lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2)))))

(let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2))))

(#%app ! +)
+
(quote 1)
x
(if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2)))
(#%app p temp1 x2)
p
temp1
x2
(#%app p (#%app ! temp1) (#%app ! x2))
p
(#%app ! temp1)
temp1
(#%app ! x2)
x2
(#%app (#%app toplevel-forcer) (let-values (((p) (#%app ! (#%top . f))) ((temp6) (quote 10))) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp6) (#%app p (#%app ! temp6)))))
(#%app toplevel-forcer)
toplevel-forcer
(let-values (((p) (#%app ! (#%top . f))) ((temp6) (quote 10))) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp6)
(#%app p (#%app ! temp6))))
(#%app ! (#%top . f))
(#%top . f)
(quote 10)
(if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp6) (#%app p (#%app ! temp6)))
(#%app p temp6)
p
temp6
(#%app p (#%app ! temp6))
p
(#%app ! temp6)
temp6


when using test-proc (seems to be identical to lazy-proc)

(#%app test-proc (lambda (x) (#%app lazy (lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2))))))))

(lambda (x) (#%app lazy (lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2)))))))

(#%app lazy (lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2))))))

lazy

(lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%appp temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2)))))

(let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2))))

(#%app ! +)
+
(quote 1)
x
(if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2)))
(#%app p temp1 x2)
p
temp1
x2
(#%app p (#%app ! temp1) (#%app ! x2))
p
(#%app ! temp1)
temp1
(#%app ! x2)
x2
(#%app (#%app toplevel-forcer) (let-values (((p) (#%app ! (#%top . f))) ((temp6) (quote 10))) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp6) (#%app p (#%app ! temp6)))))
(#%app toplevel-forcer)
toplevel-forcer
(let-values (((p) (#%app ! (#%top . f))) ((temp6) (quote 10))) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp6) (#%app p (#%app ! temp6))))
(#%app ! (#%top . f))
(#%top . f)
(quote 10)
(if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp6) (#%app p (#%app ! temp6)))
(#%app p temp6)
p
temp6
(#%app p (#%app ! temp6))
p
(#%app ! temp6)
temp6


Experiment: dump of all exprs that get annotated by annotate.rkt:annotate (for my test file that uses lazy racket: (define (f x) (+ x 1)) (f 10)     )

- using lazy-proc

(define-values (f) (#%app lazy-proc (lambda (x) (#%app lazy (lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2)))))))))

(#%app (#%app toplevel-forcer) (let-values (((p) (#%app ! (#%top . f))) ((temp6) (quote 10))) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp6) (#%app p (#%app ! temp6)))))


- using test-proc (seems the same as for lazy-proc except using test-proc)

(define-values (f) (#%app test-proc (lambda (x) (#%app lazy (lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2)))))))))

(#%app (#%app toplevel-forcer) (let-values (((p) (#%app ! (#%top . f))) ((temp6) (quote 10))) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp6) (#%app p (#%app ! temp6)))))





Call graph for annotation of lazy racket (define (f x) (+ x 1))


stepper/private/model.rkt:

go
     |
     V

go::step-through-expression
(annotate break parameter is break fn in model.rkt)
(annotated expr is then eval'ed)

     |
     V

in stepper/private/annotate.rkt:

annotate
(break parameter is break fn in model.rkt)
     |
     V

annotate::annotate/top-level #'(define-values (f) (#%app lazy-proc (lambda (x) (+ x 1))))

     |
     V

annotate::annotate/module-top-level #'(define-values (f) (#%app lazy-proc (lambda (x) (+ x 1))))

     |
     V

annotate::top-level-annotate/inner #'(#%app lazy-proc (lambda (x) (+ x 1)))

     |
     V

annotate::annotate/inner #'(#%app lazy-proc (lambda (x) (+ x 1)))



- displaying syntax->datum of top-level-rewrites for my test code seems to produce no change
  - yes of course this is true, top-level-rewrites only applies stepper-binding-type labels and other stepper-properties





Experiment: dump of exprs given to annotate/inner and the results

- with test-proc

(#%app test-proc (lambda (x) (#%app lazy (lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2))))))))

(with-continuation-mark #<debug-key-struct> #<skipto-mark-struct> (#%app test-pr
oc (with-continuation-mark #<debug-key-struct> (#%plain-lambda () (#%plain-app #
<procedure:...rivate\marks.rkt:70:2> (#%plain-lambda () lazy) (#%plain-lambda ()
 +))) (#%plain-app #<procedure:closure-storing-proc> (#%plain-lambda (x) (begin
(let-values (((arg0-501 arg1-502) (#%plain-app values #<*unevaluated-struct*> #<
*unevaluated-struct*>))) (with-continuation-mark #<debug-key-struct> (#%plain-la
mbda () (#%plain-app #<procedure:...rivate\marks.rkt:70:2> (#%plain-lambda () la
zy) (#%plain-lambda () +) (#%plain-lambda () x) (#%plain-lambda () arg0-501) (#%
plain-lambda () arg1-502))) (begin (#%plain-app #<procedure:result-exp-break>) (
begin (set! arg0-501 (with-continuation-mark #<debug-key-struct> (#%plain-lambda
 () (#%plain-app #<procedure:...rivate\marks.rkt:70:2>)) lazy)) (set! arg1-502 (
with-continuation-mark #<debug-key-struct> (#%plain-lambda () (#%plain-app #<pro
cedure:...rivate\marks.rkt:70:2>)) (#%plain-app #<procedure:closure-storing-proc
> (#%plain-lambda () (begin (let ((lifting-counter (#<procedure:binding-indexer>
))) (let-values (((lifter-p-0 lifter-temp1-1 lifter-x2-2 p temp1 x2 let-counter)
 (values lifting-counter lifting-counter lifting-counter #<*unevaluated-struct*>
 #<*unevaluated-struct*> #<*unevaluated-struct*> 0))) (with-continuation-mark #<
debug-key-struct> (#%plain-lambda () (#%plain-app #<procedure:...rivate\marks.rk
t:70:2> (#%plain-lambda () +) (#%plain-lambda () x) (#%plain-lambda () p) (#%pla
in-lambda () temp1) (#%plain-lambda () x2) (#%plain-lambda () let-counter) (#%pl
ain-lambda () lifter-p-0) (#%plain-lambda () lifter-temp1-1) (#%plain-lambda ()
lifter-x2-2))) (begin (#%plain-app #<procedure:result-exp-break>) (begin (#%plai
n-app #<procedure:double-break>) (begin (set!-values (p) (with-continuation-mark
 #<debug-key-struct> #<skipto-mark-struct> (#%app ! (with-continuation-mark #<de
bug-key-struct> (#%plain-lambda () (#%plain-app #<procedure:...rivate\marks.rkt:
70:2>)) +)))) (set! let-counter 1) (set!-values (temp1) (with-continuation-mark
#<debug-key-struct> (#%plain-lambda () (#%plain-app #<procedure:...rivate\marks.
rkt:70:2>)) (quote 1))) (set! let-counter 2) (set!-values (x2) (with-continuatio
n-mark #<debug-key-struct> (#%plain-lambda () (#%plain-app #<procedure:...rivate
\marks.rkt:70:2>)) x)) (set! let-counter 3) (#%plain-app #<procedure:exp-finishe
d-break> (#%plain-app list (#%plain-app list #<procedure:...ate\annotate.rkt:657
:69> (#%plain-app list lifter-p-0) (#%plain-lambda () (#%plain-app list p))) (#%
plain-app list #<procedure:...ate\annotate.rkt:657:69> (#%plain-app list lifter-
temp1-1) (#%plain-lambda () (#%plain-app list temp1))) (#%plain-app list #<proce
dure:...ate\annotate.rkt:657:69> (#%plain-app list lifter-x2-2) (#%plain-lambda
() (#%plain-app list x2))))) (with-continuation-mark #<debug-key-struct> #<skipt
o-mark-struct> (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor
-procedure? p)) (let-values (((arg0-501 arg1-502 arg2-503) (#%plain-app values #
<*unevaluated-struct*> #<*unevaluated-struct*> #<*unevaluated-struct*>))) (with-
continuation-mark #<debug-key-struct> (#%plain-lambda () (#%plain-app #<procedur
e:...rivate\marks.rkt:70:2> (#%plain-lambda () p) (#%plain-lambda () temp1) (#%p
lain-lambda () x2) (#%plain-lambda () arg0-501) (#%plain-lambda () arg1-502) (#%
plain-lambda () arg2-503) (#%plain-lambda () lifter-p-0) (#%plain-lambda () lift
er-temp1-1) (#%plain-lambda () lifter-x2-2))) (begin (set! arg0-501 (with-contin
uation-mark #<debug-key-struct> (#%plain-lambda () (#%plain-app #<procedure:...r
ivate\marks.rkt:70:2>)) (begin (#%plain-app #<procedure:normal-break>) (#%plain-
app call-with-values (#%plain-lambda () p) (#%plain-lambda args (#%plain-app #<p
rocedure:result-value-break> args) (#%plain-app #<procedure:apply> values args))
)))) (set! arg1-502 (with-continuation-mark #<debug-key-struct> (#%plain-lambda
() (#%plain-app #<procedure:...rivate\marks.rkt:70:2>)) (begin (#%plain-app #<pr
ocedure:normal-break>) (#%plain-app call-with-values (#%plain-lambda () temp1) (
#%plain-lambda args (#%plain-app #<procedure:result-value-break> args) (#%plain-
app #<procedure:apply> values args)))))) (set! arg2-503 (with-continuation-mark
#<debug-key-struct> (#%plain-lambda () (#%plain-app #<procedure:...rivate\marks.
rkt:70:2>)) (begin (#%plain-app #<procedure:normal-break>) (#%plain-app call-wit
h-values (#%plain-lambda () x2) (#%plain-lambda args (#%plain-app #<procedure:re
sult-value-break> args) (#%plain-app #<procedure:apply> values args)))))) (begin
 (#%plain-app #<procedure:normal-break>) (with-continuation-mark #<debug-key-str
uct> (#%plain-lambda () (#%plain-app #<procedure:...rivate\marks.rkt:70:2> (#%pl
ain-lambda () arg0-501) (#%plain-lambda () arg1-502) (#%plain-lambda () arg2-503
))) (if (#%plain-app #<procedure:...ivate\shared.rkt:308:7> arg0-501) (#%plain-a
pp arg0-501 arg1-502 arg2-503) (#%plain-app call-with-values (#%plain-lambda ()
(#%plain-app arg0-501 arg1-502 arg2-503)) (#%plain-lambda args (#%plain-app #<pr
ocedure:result-value-break> args) (#%plain-app #<procedure:apply> values args)))
)))))) (let-values (((arg0-501 arg1-502 arg2-503) (#%plain-app values #<*unevalu
ated-struct*> #<*unevaluated-struct*> #<*unevaluated-struct*>))) (with-continuat
ion-mark #<debug-key-struct> (#%plain-lambda () (#%plain-app #<procedure:...riva
te\marks.rkt:70:2> (#%plain-lambda () p) (#%plain-lambda () temp1) (#%plain-lamb
da () x2) (#%plain-lambda () arg0-501) (#%plain-lambda () arg1-502) (#%plain-lam
bda () arg2-503) (#%plain-lambda () lifter-p-0) (#%plain-lambda () lifter-temp1-
1) (#%plain-lambda () lifter-x2-2))) (begin (set! arg0-501 (with-continuation-ma
rk #<debug-key-struct> (#%plain-lambda () (#%plain-app #<procedure:...rivate\mar
ks.rkt:70:2>)) (begin (#%plain-app #<procedure:normal-break>) (#%plain-app call-
with-values (#%plain-lambda () p) (#%plain-lambda args (#%plain-app #<procedure:
result-value-break> args) (#%plain-app #<procedure:apply> values args)))))) (set
! arg1-502 (with-continuation-mark #<debug-key-struct> #<skipto-mark-struct> (#%
app ! (with-continuation-mark #<debug-key-struct> (#%plain-lambda () (#%plain-ap
p #<procedure:...rivate\marks.rkt:70:2>)) (begin (#%plain-app #<procedure:normal
-break>) (#%plain-app call-with-values (#%plain-lambda () temp1) (#%plain-lambda
 args (#%plain-app #<procedure:result-value-break> args) (#%plain-app #<procedur
e:apply> values args)))))))) (set! arg2-503 (with-continuation-mark #<debug-key-
struct> #<skipto-mark-struct> (#%app ! (with-continuation-mark #<debug-key-struc
t> (#%plain-lambda () (#%plain-app #<procedure:...rivate\marks.rkt:70:2>)) (begi
n (#%plain-app #<procedure:normal-break>) (#%plain-app call-with-values (#%plain
-lambda () x2) (#%plain-lambda args (#%plain-app #<procedure:result-value-break>
 args) (#%plain-app #<procedure:apply> values args)))))))) (begin (#%plain-app #
<procedure:normal-break>) (with-continuation-mark #<debug-key-struct> (#%plain-l
ambda () (#%plain-app #<procedure:...rivate\marks.rkt:70:2> (#%plain-lambda () a
rg0-501) (#%plain-lambda () arg1-502) (#%plain-lambda () arg2-503))) (if (#%plai
n-app #<procedure:...ivate\shared.rkt:308:7> arg0-501) (#%plain-app arg0-501 arg
1-502 arg2-503) (#%plain-app call-with-values (#%plain-lambda () (#%plain-app ar
g0-501 arg1-502 arg2-503)) (#%plain-lambda args (#%plain-app #<procedure:result-
value-break> args) (#%plain-app #<procedure:apply> values args))))))))))))))))))
) (#%plain-lambda () (#%plain-app #<procedure:...rivate\marks.rkt:70:2> (#%plain
-lambda () +) (#%plain-lambda () x)))))) (begin (#%plain-app #<procedure:normal-
break>) (with-continuation-mark #<debug-key-struct> (#%plain-lambda () (#%plain-
app #<procedure:...rivate\marks.rkt:70:2> (#%plain-lambda () arg0-501) (#%plain-
lambda () arg1-502))) (if (#%plain-app #<procedure:...ivate\shared.rkt:308:7> ar
g0-501) (#%plain-app arg0-501 arg1-502) (#%plain-app call-with-values (#%plain-l
ambda () (#%plain-app arg0-501 arg1-502)) (#%plain-lambda args (#%plain-app #<pr
ocedure:result-value-break> args) (#%plain-app #<procedure:apply> values args)))
))))))))) (#%plain-lambda () (#%plain-app #<procedure:...rivate\marks.rkt:70:2>
(#%plain-lambda () lazy) (#%plain-lambda () +)))))))

(#%app (#%app toplevel-forcer) (let-values (((p) (#%app ! (#%top . f))) ((temp6) (quote 10))) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp6) (#%app p (#%app ! temp6)))))

(let-values (((arg0-501 arg1-502) (#%plain-app values #<*unevaluated-struct*> #<
*unevaluated-struct*>))) (with-continuation-mark #<debug-key-struct> (#%plain-la
mbda () (#%plain-app #<procedure:...rivate\marks.rkt:70:2> (#%plain-lambda () to
plevel-forcer) (#%plain-lambda () f) (#%plain-lambda () arg0-501) (#%plain-lambd
a () arg1-502))) (begin (set! arg0-501 (let-values (((arg0-501) (#%plain-app val
ues #<*unevaluated-struct*>))) (with-continuation-mark #<debug-key-struct> (#%pl
ain-lambda () (#%plain-app #<procedure:...rivate\marks.rkt:70:2> (#%plain-lambda
 () arg0-501))) (begin (set! arg0-501 (with-continuation-mark #<debug-key-struct
> (#%plain-lambda () (#%plain-app #<procedure:...rivate\marks.rkt:70:2>)) toplev
el-forcer)) (begin (#%plain-app #<procedure:normal-break>) (with-continuation-ma
rk #<debug-key-struct> (#%plain-lambda () (#%plain-app #<procedure:...rivate\mar
ks.rkt:70:2> (#%plain-lambda () arg0-501))) (if (#%plain-app #<procedure:...ivat
e\shared.rkt:308:7> arg0-501) (#%plain-app arg0-501) (#%plain-app call-with-valu
es (#%plain-lambda () (#%plain-app arg0-501)) (#%plain-lambda args (#%plain-app
#<procedure:result-value-break> args) (#%plain-app #<procedure:apply> values arg
s)))))))))) (set! arg1-502 (let ((lifting-counter (#<procedure:binding-indexer>)
)) (let-values (((lifter-p-3 lifter-temp6-4 p temp6 let-counter) (values lifting
-counter lifting-counter #<*unevaluated-struct*> #<*unevaluated-struct*> 0))) (w
ith-continuation-mark #<debug-key-struct> (#%plain-lambda () (#%plain-app #<proc
edure:...rivate\marks.rkt:70:2> (#%plain-lambda () p) (#%plain-lambda () temp6)
(#%plain-lambda () let-counter) (#%plain-lambda () lifter-p-3) (#%plain-lambda (
) lifter-temp6-4))) (begin (#%plain-app #<procedure:double-break>) (begin (set!-
values (p) (with-continuation-mark #<debug-key-struct> #<skipto-mark-struct> (#%
app ! (with-continuation-mark #<debug-key-struct> (#%plain-lambda () (#%plain-ap
p #<procedure:...rivate\marks.rkt:70:2>)) f)))) (set! let-counter 1) (set!-value
s (temp6) (with-continuation-mark #<debug-key-struct> (#%plain-lambda () (#%plai
n-app #<procedure:...rivate\marks.rkt:70:2>)) (quote 10))) (set! let-counter 2)
(#%plain-app #<procedure:exp-finished-break> (#%plain-app list (#%plain-app list
 #<procedure:...ate\annotate.rkt:657:69> (#%plain-app list lifter-p-3) (#%plain-
lambda () (#%plain-app list p))) (#%plain-app list #<procedure:...ate\annotate.r
kt:657:69> (#%plain-app list lifter-temp6-4) (#%plain-lambda () (#%plain-app lis
t temp6))))) (with-continuation-mark #<debug-key-struct> #<skipto-mark-struct> (
if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p))
(let-values (((arg0-501 arg1-502) (#%plain-app values #<*unevaluated-struct*> #<
*unevaluated-struct*>))) (with-continuation-mark #<debug-key-struct> (#%plain-la
mbda () (#%plain-app #<procedure:...rivate\marks.rkt:70:2> (#%plain-lambda () p)
 (#%plain-lambda () temp6) (#%plain-lambda () arg0-501) (#%plain-lambda () arg1-
502) (#%plain-lambda () lifter-p-3) (#%plain-lambda () lifter-temp6-4))) (begin
(set! arg0-501 (with-continuation-mark #<debug-key-struct> (#%plain-lambda () (#
%plain-app #<procedure:...rivate\marks.rkt:70:2>)) (begin (#%plain-app #<procedu
re:normal-break>) (#%plain-app call-with-values (#%plain-lambda () p) (#%plain-l
ambda args (#%plain-app #<procedure:result-value-break> args) (#%plain-app #<pro
cedure:apply> values args)))))) (set! arg1-502 (with-continuation-mark #<debug-k
ey-struct> (#%plain-lambda () (#%plain-app #<procedure:...rivate\marks.rkt:70:2>
)) (begin (#%plain-app #<procedure:normal-break>) (#%plain-app call-with-values
(#%plain-lambda () temp6) (#%plain-lambda args (#%plain-app #<procedure:result-v
alue-break> args) (#%plain-app #<procedure:apply> values args)))))) (begin (#%pl
ain-app #<procedure:normal-break>) (with-continuation-mark #<debug-key-struct> (
#%plain-lambda () (#%plain-app #<procedure:...rivate\marks.rkt:70:2> (#%plain-la
mbda () arg0-501) (#%plain-lambda () arg1-502))) (if (#%plain-app #<procedure:..
.ivate\shared.rkt:308:7> arg0-501) (#%plain-app arg0-501 arg1-502) (#%plain-app
call-with-values (#%plain-lambda () (#%plain-app arg0-501 arg1-502)) (#%plain-la
mbda args (#%plain-app #<procedure:result-value-break> args) (#%plain-app #<proc
edure:apply> values args))))))))) (let-values (((arg0-501 arg1-502) (#%plain-app
 values #<*unevaluated-struct*> #<*unevaluated-struct*>))) (with-continuation-ma
rk #<debug-key-struct> (#%plain-lambda () (#%plain-app #<procedure:...rivate\mar
ks.rkt:70:2> (#%plain-lambda () p) (#%plain-lambda () temp6) (#%plain-lambda ()
arg0-501) (#%plain-lambda () arg1-502) (#%plain-lambda () lifter-p-3) (#%plain-l
ambda () lifter-temp6-4))) (begin (set! arg0-501 (with-continuation-mark #<debug
-key-struct> (#%plain-lambda () (#%plain-app #<procedure:...rivate\marks.rkt:70:
2>)) (begin (#%plain-app #<procedure:normal-break>) (#%plain-app call-with-value
s (#%plain-lambda () p) (#%plain-lambda args (#%plain-app #<procedure:result-val
ue-break> args) (#%plain-app #<procedure:apply> values args)))))) (set! arg1-502
 (with-continuation-mark #<debug-key-struct> #<skipto-mark-struct> (#%app ! (wit
h-continuation-mark #<debug-key-struct> (#%plain-lambda () (#%plain-app #<proced
ure:...rivate\marks.rkt:70:2>)) (begin (#%plain-app #<procedure:normal-break>) (
#%plain-app call-with-values (#%plain-lambda () temp6) (#%plain-lambda args (#%p
lain-app #<procedure:result-value-break> args) (#%plain-app #<procedure:apply> v
alues args)))))))) (begin (#%plain-app #<procedure:normal-break>) (with-continua
tion-mark #<debug-key-struct> (#%plain-lambda () (#%plain-app #<procedure:...riv
ate\marks.rkt:70:2> (#%plain-lambda () arg0-501) (#%plain-lambda () arg1-502)))
(if (#%plain-app #<procedure:...ivate\shared.rkt:308:7> arg0-501) (#%plain-app a
rg0-501 arg1-502) (#%plain-app call-with-values (#%plain-lambda () (#%plain-app
arg0-501 arg1-502)) (#%plain-lambda args (#%plain-app #<procedure:result-value-b
reak> args) (#%plain-app #<procedure:apply> values args))))))))))))))))) (begin
(#%plain-app #<procedure:normal-break>) (with-continuation-mark #<debug-key-stru
ct> (#%plain-lambda () (#%plain-app #<procedure:...rivate\marks.rkt:70:2> (#%pla
in-lambda () arg0-501) (#%plain-lambda () arg1-502))) (if (#%plain-app #<procedu
re:...ivate\shared.rkt:308:7> arg0-501) (#%plain-app arg0-501 arg1-502) (#%plain
-app call-with-values (#%plain-lambda () (#%plain-app arg0-501 arg1-502)) (#%pla
in-lambda args (#%plain-app #<procedure:result-value-break> args) (#%plain-app #
<procedure:apply> values args)))))))))


- with lazy-proc

(#%app lazy-proc (lambda (x) (#%app lazy (lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2))))))))

(with-continuation-mark #<debug-key-struct> #<skipto-mark-struct> (#%app lazy-pr
oc (with-continuation-mark #<debug-key-struct> (#%plain-lambda () (#%plain-app #
<procedure:...rivate\marks.rkt:70:2> (#%plain-lambda () lazy) (#%plain-lambda ()
 +))) (#%plain-app #<procedure:closure-storing-proc> (#%plain-lambda (x) (begin
(let-values (((arg0-1257 arg1-1258) (#%plain-app values #<*unevaluated-struct*>
#<*unevaluated-struct*>))) (with-continuation-mark #<debug-key-struct> (#%plain-
lambda () (#%plain-app #<procedure:...rivate\marks.rkt:70:2> (#%plain-lambda ()
lazy) (#%plain-lambda () +) (#%plain-lambda () x) (#%plain-lambda () arg0-1257)
(#%plain-lambda () arg1-1258))) (begin (#%plain-app #<procedure:result-exp-break
>) (begin (set! arg0-1257 (with-continuation-mark #<debug-key-struct> (#%plain-l
ambda () (#%plain-app #<procedure:...rivate\marks.rkt:70:2>)) lazy)) (set! arg1-
1258 (with-continuation-mark #<debug-key-struct> (#%plain-lambda () (#%plain-app
 #<procedure:...rivate\marks.rkt:70:2>)) (#%plain-app #<procedure:closure-storin
g-proc> (#%plain-lambda () (begin (let ((lifting-counter (#<procedure:binding-in
dexer>))) (let-values (((lifter-p-0 lifter-temp1-1 lifter-x2-2 p temp1 x2 let-co
unter) (values lifting-counter lifting-counter lifting-counter #<*unevaluated-st
ruct*> #<*unevaluated-struct*> #<*unevaluated-struct*> 0))) (with-continuation-m
ark #<debug-key-struct> (#%plain-lambda () (#%plain-app #<procedure:...rivate\ma
rks.rkt:70:2> (#%plain-lambda () +) (#%plain-lambda () x) (#%plain-lambda () p)
(#%plain-lambda () temp1) (#%plain-lambda () x2) (#%plain-lambda () let-counter)
 (#%plain-lambda () lifter-p-0) (#%plain-lambda () lifter-temp1-1) (#%plain-lamb
da () lifter-x2-2))) (begin (#%plain-app #<procedure:result-exp-break>) (begin (
#%plain-app #<procedure:double-break>) (begin (set!-values (p) (with-continuatio
n-mark #<debug-key-struct> #<skipto-mark-struct> (#%app ! (with-continuation-mar
k #<debug-key-struct> (#%plain-lambda () (#%plain-app #<procedure:...rivate\mark
s.rkt:70:2>)) +)))) (set! let-counter 1) (set!-values (temp1) (with-continuation
-mark #<debug-key-struct> (#%plain-lambda () (#%plain-app #<procedure:...rivate\
marks.rkt:70:2>)) (quote 1))) (set! let-counter 2) (set!-values (x2) (with-conti
nuation-mark #<debug-key-struct> (#%plain-lambda () (#%plain-app #<procedure:...
rivate\marks.rkt:70:2>)) x)) (set! let-counter 3) (#%plain-app #<procedure:exp-f
inished-break> (#%plain-app list (#%plain-app list #<procedure:...ate\annotate.r
kt:657:69> (#%plain-app list lifter-p-0) (#%plain-lambda () (#%plain-app list p)
)) (#%plain-app list #<procedure:...ate\annotate.rkt:657:69> (#%plain-app list l
ifter-temp1-1) (#%plain-lambda () (#%plain-app list temp1))) (#%plain-app list #
<procedure:...ate\annotate.rkt:657:69> (#%plain-app list lifter-x2-2) (#%plain-l
ambda () (#%plain-app list x2))))) (with-continuation-mark #<debug-key-struct> #
<skipto-mark-struct> (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-const
ructor-procedure? p)) (let-values (((arg0-1257 arg1-1258 arg2-1259) (#%plain-app
 values #<*unevaluated-struct*> #<*unevaluated-struct*> #<*unevaluated-struct*>)
)) (with-continuation-mark #<debug-key-struct> (#%plain-lambda () (#%plain-app #
<procedure:...rivate\marks.rkt:70:2> (#%plain-lambda () p) (#%plain-lambda () te
mp1) (#%plain-lambda () x2) (#%plain-lambda () arg0-1257) (#%plain-lambda () arg
1-1258) (#%plain-lambda () arg2-1259) (#%plain-lambda () lifter-p-0) (#%plain-la
mbda () lifter-temp1-1) (#%plain-lambda () lifter-x2-2))) (begin (set! arg0-1257
 (with-continuation-mark #<debug-key-struct> (#%plain-lambda () (#%plain-app #<p
rocedure:...rivate\marks.rkt:70:2>)) (begin (#%plain-app #<procedure:normal-brea
k>) (#%plain-app call-with-values (#%plain-lambda () p) (#%plain-lambda args (#%
plain-app #<procedure:result-value-break> args) (#%plain-app #<procedure:apply>
values args)))))) (set! arg1-1258 (with-continuation-mark #<debug-key-struct> (#
%plain-lambda () (#%plain-app #<procedure:...rivate\marks.rkt:70:2>)) (begin (#%
plain-app #<procedure:normal-break>) (#%plain-app call-with-values (#%plain-lamb
da () temp1) (#%plain-lambda args (#%plain-app #<procedure:result-value-break> a
rgs) (#%plain-app #<procedure:apply> values args)))))) (set! arg2-1259 (with-con
tinuation-mark #<debug-key-struct> (#%plain-lambda () (#%plain-app #<procedure:.
..rivate\marks.rkt:70:2>)) (begin (#%plain-app #<procedure:normal-break>) (#%pla
in-app call-with-values (#%plain-lambda () x2) (#%plain-lambda args (#%plain-app
 #<procedure:result-value-break> args) (#%plain-app #<procedure:apply> values ar
gs)))))) (begin (#%plain-app #<procedure:normal-break>) (with-continuation-mark
#<debug-key-struct> (#%plain-lambda () (#%plain-app #<procedure:...rivate\marks.
rkt:70:2> (#%plain-lambda () arg0-1257) (#%plain-lambda () arg1-1258) (#%plain-l
ambda () arg2-1259))) (if (#%plain-app #<procedure:...ivate\shared.rkt:308:7> ar
g0-1257) (#%plain-app arg0-1257 arg1-1258 arg2-1259) (#%plain-app call-with-valu
es (#%plain-lambda () (#%plain-app arg0-1257 arg1-1258 arg2-1259)) (#%plain-lamb
da args (#%plain-app #<procedure:result-value-break> args) (#%plain-app #<proced
ure:apply> values args))))))))) (let-values (((arg0-1257 arg1-1258 arg2-1259) (#
%plain-app values #<*unevaluated-struct*> #<*unevaluated-struct*> #<*unevaluated
-struct*>))) (with-continuation-mark #<debug-key-struct> (#%plain-lambda () (#%p
lain-app #<procedure:...rivate\marks.rkt:70:2> (#%plain-lambda () p) (#%plain-la
mbda () temp1) (#%plain-lambda () x2) (#%plain-lambda () arg0-1257) (#%plain-lam
bda () arg1-1258) (#%plain-lambda () arg2-1259) (#%plain-lambda () lifter-p-0) (
#%plain-lambda () lifter-temp1-1) (#%plain-lambda () lifter-x2-2))) (begin (set!
 arg0-1257 (with-continuation-mark #<debug-key-struct> (#%plain-lambda () (#%pla
in-app #<procedure:...rivate\marks.rkt:70:2>)) (begin (#%plain-app #<procedure:n
ormal-break>) (#%plain-app call-with-values (#%plain-lambda () p) (#%plain-lambd
a args (#%plain-app #<procedure:result-value-break> args) (#%plain-app #<procedu
re:apply> values args)))))) (set! arg1-1258 (with-continuation-mark #<debug-key-
struct> #<skipto-mark-struct> (#%app ! (with-continuation-mark #<debug-key-struc
t> (#%plain-lambda () (#%plain-app #<procedure:...rivate\marks.rkt:70:2>)) (begi
n (#%plain-app #<procedure:normal-break>) (#%plain-app call-with-values (#%plain
-lambda () temp1) (#%plain-lambda args (#%plain-app #<procedure:result-value-bre
ak> args) (#%plain-app #<procedure:apply> values args)))))))) (set! arg2-1259 (w
ith-continuation-mark #<debug-key-struct> #<skipto-mark-struct> (#%app ! (with-c
ontinuation-mark #<debug-key-struct> (#%plain-lambda () (#%plain-app #<procedure
:...rivate\marks.rkt:70:2>)) (begin (#%plain-app #<procedure:normal-break>) (#%p
lain-app call-with-values (#%plain-lambda () x2) (#%plain-lambda args (#%plain-a
pp #<procedure:result-value-break> args) (#%plain-app #<procedure:apply> values
args)))))))) (begin (#%plain-app #<procedure:normal-break>) (with-continuation-m
ark #<debug-key-struct> (#%plain-lambda () (#%plain-app #<procedure:...rivate\ma
rks.rkt:70:2> (#%plain-lambda () arg0-1257) (#%plain-lambda () arg1-1258) (#%pla
in-lambda () arg2-1259))) (if (#%plain-app #<procedure:...ivate\shared.rkt:308:7
> arg0-1257) (#%plain-app arg0-1257 arg1-1258 arg2-1259) (#%plain-app call-with-
values (#%plain-lambda () (#%plain-app arg0-1257 arg1-1258 arg2-1259)) (#%plain-
lambda args (#%plain-app #<procedure:result-value-break> args) (#%plain-app #<pr
ocedure:apply> values args))))))))))))))))))) (#%plain-lambda () (#%plain-app #<
procedure:...rivate\marks.rkt:70:2> (#%plain-lambda () +) (#%plain-lambda () x))
)))) (begin (#%plain-app #<procedure:normal-break>) (with-continuation-mark #<de
bug-key-struct> (#%plain-lambda () (#%plain-app #<procedure:...rivate\marks.rkt:
70:2> (#%plain-lambda () arg0-1257) (#%plain-lambda () arg1-1258))) (if (#%plain
-app #<procedure:...ivate\shared.rkt:308:7> arg0-1257) (#%plain-app arg0-1257 ar
g1-1258) (#%plain-app call-with-values (#%plain-lambda () (#%plain-app arg0-1257
 arg1-1258)) (#%plain-lambda args (#%plain-app #<procedure:result-value-break> a
rgs) (#%plain-app #<procedure:apply> values args)))))))))))) (#%plain-lambda ()
(#%plain-app #<procedure:...rivate\marks.rkt:70:2> (#%plain-lambda () lazy) (#%p
lain-lambda () +)))))))

(#%app (#%app toplevel-forcer) (let-values (((p) (#%app ! (#%top . f))) ((temp6) (quote 10))) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp6) (#%app p (#%app ! temp6)))))

(let-values (((arg0-1257 arg1-1258) (#%plain-app values #<*unevaluated-struct*>
#<*unevaluated-struct*>))) (with-continuation-mark #<debug-key-struct> (#%plain-
lambda () (#%plain-app #<procedure:...rivate\marks.rkt:70:2> (#%plain-lambda ()
toplevel-forcer) (#%plain-lambda () f) (#%plain-lambda () arg0-1257) (#%plain-la
mbda () arg1-1258))) (begin (set! arg0-1257 (let-values (((arg0-1257) (#%plain-a
pp values #<*unevaluated-struct*>))) (with-continuation-mark #<debug-key-struct>
 (#%plain-lambda () (#%plain-app #<procedure:...rivate\marks.rkt:70:2> (#%plain-
lambda () arg0-1257))) (begin (set! arg0-1257 (with-continuation-mark #<debug-ke
y-struct> (#%plain-lambda () (#%plain-app #<procedure:...rivate\marks.rkt:70:2>)
) toplevel-forcer)) (begin (#%plain-app #<procedure:normal-break>) (with-continu
ation-mark #<debug-key-struct> (#%plain-lambda () (#%plain-app #<procedure:...ri
vate\marks.rkt:70:2> (#%plain-lambda () arg0-1257))) (if (#%plain-app #<procedur
e:...ivate\shared.rkt:308:7> arg0-1257) (#%plain-app arg0-1257) (#%plain-app cal
l-with-values (#%plain-lambda () (#%plain-app arg0-1257)) (#%plain-lambda args (
#%plain-app #<procedure:result-value-break> args) (#%plain-app #<procedure:apply
> values args)))))))))) (set! arg1-1258 (let ((lifting-counter (#<procedure:bind
ing-indexer>))) (let-values (((lifter-p-3 lifter-temp6-4 p temp6 let-counter) (v
alues lifting-counter lifting-counter #<*unevaluated-struct*> #<*unevaluated-str
uct*> 0))) (with-continuation-mark #<debug-key-struct> (#%plain-lambda () (#%pla
in-app #<procedure:...rivate\marks.rkt:70:2> (#%plain-lambda () p) (#%plain-lamb
da () temp6) (#%plain-lambda () let-counter) (#%plain-lambda () lifter-p-3) (#%p
lain-lambda () lifter-temp6-4))) (begin (#%plain-app #<procedure:double-break>)
(begin (set!-values (p) (with-continuation-mark #<debug-key-struct> #<skipto-mar
k-struct> (#%app ! (with-continuation-mark #<debug-key-struct> (#%plain-lambda (
) (#%plain-app #<procedure:...rivate\marks.rkt:70:2>)) f)))) (set! let-counter 1
) (set!-values (temp6) (with-continuation-mark #<debug-key-struct> (#%plain-lamb
da () (#%plain-app #<procedure:...rivate\marks.rkt:70:2>)) (quote 10))) (set! le
t-counter 2) (#%plain-app #<procedure:exp-finished-break> (#%plain-app list (#%p
lain-app list #<procedure:...ate\annotate.rkt:657:69> (#%plain-app list lifter-p
-3) (#%plain-lambda () (#%plain-app list p))) (#%plain-app list #<procedure:...a
te\annotate.rkt:657:69> (#%plain-app list lifter-temp6-4) (#%plain-lambda () (#%
plain-app list temp6))))) (with-continuation-mark #<debug-key-struct> #<skipto-m
ark-struct> (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-pr
ocedure? p)) (let-values (((arg0-1257 arg1-1258) (#%plain-app values #<*unevalua
ted-struct*> #<*unevaluated-struct*>))) (with-continuation-mark #<debug-key-stru
ct> (#%plain-lambda () (#%plain-app #<procedure:...rivate\marks.rkt:70:2> (#%pla
in-lambda () p) (#%plain-lambda () temp6) (#%plain-lambda () arg0-1257) (#%plain
-lambda () arg1-1258) (#%plain-lambda () lifter-p-3) (#%plain-lambda () lifter-t
emp6-4))) (begin (set! arg0-1257 (with-continuation-mark #<debug-key-struct> (#%
plain-lambda () (#%plain-app #<procedure:...rivate\marks.rkt:70:2>)) (begin (#%p
lain-app #<procedure:normal-break>) (#%plain-app call-with-values (#%plain-lambd
a () p) (#%plain-lambda args (#%plain-app #<procedure:result-value-break> args)
(#%plain-app #<procedure:apply> values args)))))) (set! arg1-1258 (with-continua
tion-mark #<debug-key-struct> (#%plain-lambda () (#%plain-app #<procedure:...riv
ate\marks.rkt:70:2>)) (begin (#%plain-app #<procedure:normal-break>) (#%plain-ap
p call-with-values (#%plain-lambda () temp6) (#%plain-lambda args (#%plain-app #
<procedure:result-value-break> args) (#%plain-app #<procedure:apply> values args
)))))) (begin (#%plain-app #<procedure:normal-break>) (with-continuation-mark #<
debug-key-struct> (#%plain-lambda () (#%plain-app #<procedure:...rivate\marks.rk
t:70:2> (#%plain-lambda () arg0-1257) (#%plain-lambda () arg1-1258))) (if (#%pla
in-app #<procedure:...ivate\shared.rkt:308:7> arg0-1257) (#%plain-app arg0-1257
arg1-1258) (#%plain-app call-with-values (#%plain-lambda () (#%plain-app arg0-12
57 arg1-1258)) (#%plain-lambda args (#%plain-app #<procedure:result-value-break>
 args) (#%plain-app #<procedure:apply> values args))))))))) (let-values (((arg0-
1257 arg1-1258) (#%plain-app values #<*unevaluated-struct*> #<*unevaluated-struc
t*>))) (with-continuation-mark #<debug-key-struct> (#%plain-lambda () (#%plain-a
pp #<procedure:...rivate\marks.rkt:70:2> (#%plain-lambda () p) (#%plain-lambda (
) temp6) (#%plain-lambda () arg0-1257) (#%plain-lambda () arg1-1258) (#%plain-la
mbda () lifter-p-3) (#%plain-lambda () lifter-temp6-4))) (begin (set! arg0-1257
(with-continuation-mark #<debug-key-struct> (#%plain-lambda () (#%plain-app #<pr
ocedure:...rivate\marks.rkt:70:2>)) (begin (#%plain-app #<procedure:normal-break
>) (#%plain-app call-with-values (#%plain-lambda () p) (#%plain-lambda args (#%p
lain-app #<procedure:result-value-break> args) (#%plain-app #<procedure:apply> v
alues args)))))) (set! arg1-1258 (with-continuation-mark #<debug-key-struct> #<s
kipto-mark-struct> (#%app ! (with-continuation-mark #<debug-key-struct> (#%plain
-lambda () (#%plain-app #<procedure:...rivate\marks.rkt:70:2>)) (begin (#%plain-
app #<procedure:normal-break>) (#%plain-app call-with-values (#%plain-lambda ()
temp6) (#%plain-lambda args (#%plain-app #<procedure:result-value-break> args) (
#%plain-app #<procedure:apply> values args)))))))) (begin (#%plain-app #<procedu
re:normal-break>) (with-continuation-mark #<debug-key-struct> (#%plain-lambda ()
 (#%plain-app #<procedure:...rivate\marks.rkt:70:2> (#%plain-lambda () arg0-1257
) (#%plain-lambda () arg1-1258))) (if (#%plain-app #<procedure:...ivate\shared.r
kt:308:7> arg0-1257) (#%plain-app arg0-1257 arg1-1258) (#%plain-app call-with-va
lues (#%plain-lambda () (#%plain-app arg0-1257 arg1-1258)) (#%plain-lambda args
(#%plain-app #<procedure:result-value-break> args) (#%plain-app #<procedure:appl
y> values args))))))))))))))))) (begin (#%plain-app #<procedure:normal-break>) (
with-continuation-mark #<debug-key-struct> (#%plain-lambda () (#%plain-app #<pro
cedure:...rivate\marks.rkt:70:2> (#%plain-lambda () arg0-1257) (#%plain-lambda (
) arg1-1258))) (if (#%plain-app #<procedure:...ivate\shared.rkt:308:7> arg0-1257
) (#%plain-app arg0-1257 arg1-1258) (#%plain-app call-with-values (#%plain-lambd
a () (#%plain-app arg0-1257 arg1-1258)) (#%plain-lambda args (#%plain-app #<proc
edure:result-value-break> args) (#%plain-app #<procedure:apply> values args)))))
))))



Experiment: dumping exprs given to annotate/inner, along with associated stepper-properties


- using lazy-proc


(#%app lazy-proc (lambda (x) (#%app lazy (lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2))))))))

((stepper-skipto (syntax-e cdr syntax-e cdr car)))

(lambda (x) (#%app lazy (lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2)))))))

((stepper-proc-define-name #<syntax:C:\Documents and Settings\Stephen Chang\My Documents\plt\sandbox\lazy-expand-test.rkt:1:9 f>) (stepper-define-type shortened
-proc-define))

(#%app lazy (lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2))))))

#f

lazy

((stepper-binding-type non-lexical))

(lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2)))))

#f

(let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2))))

((stepper-skip-double-break #t) (stepper-hint #<procedure:unwinder>))

(#%app ! +)

((stepper-skipto (syntax-e cdr syntax-e cdr car)))

+

((stepper-binding-type non-lexical))

(quote 1)
#f
x
((stepper-binding-type lambda-bound))
(if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2)))

(((stepper-skipto (syntax-e cdr cdr both-l () (car)))) (stepper-skipto (syntax-e cdr cdr both-l () (car))))

(#%app p temp1 x2)
#f
p
((stepper-binding-type let-bound))
temp1
((stepper-binding-type let-bound))
x2
((stepper-binding-type let-bound))
(#%app p (#%app ! temp1) (#%app ! x2))
#f
p
((stepper-binding-type let-bound))
(#%app ! temp1)
((stepper-skipto (syntax-e cdr syntax-e cdr car)))
temp1
((stepper-binding-type let-bound))
(#%app ! x2)
((stepper-skipto (syntax-e cdr syntax-e cdr car)))
x2
((stepper-binding-type let-bound))
(#%app (#%app toplevel-forcer) (let-values (((p) (#%app ! (#%top . f))) ((temp6) (quote 10))) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp6) (#%app p (#%app ! temp6)))))
#f
(#%app toplevel-forcer)
#f
toplevel-forcer
((stepper-binding-type non-lexical))
(let-values (((p) (#%app ! (#%top . f))) ((temp6) (quote 10))) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp6) (#%app p (#%app ! temp6))))
((stepper-skip-double-break #t) (stepper-hint #<procedure:unwinder>))
(#%app ! (#%top . f))
((stepper-skipto (syntax-e cdr syntax-e cdr car)))
(#%top . f)
#f
(quote 10)
#f
(if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp6) (#%app p (#%app ! temp6)))
(((stepper-skipto (syntax-e cdr cdr both-l () (car)))) (stepper-skipto (syntax-e
 cdr cdr both-l () (car))))
(#%app p temp6)
#f
p
((stepper-binding-type let-bound))
temp6
((stepper-binding-type let-bound))
(#%app p (#%app ! temp6))
#f
p
((stepper-binding-type let-bound))
(#%app ! temp6)
((stepper-skipto (syntax-e cdr syntax-e cdr car)))
temp6
((stepper-binding-type let-bound))


- using test-proc

(#%app test-proc (lambda (x) (#%app lazy (lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2))))))))

((stepper-skipto (syntax-e cdr syntax-e cdr car)))

(lambda (x) (#%app lazy (lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2)))))))

((stepper-proc-define-name #<syntax:C:\Documents and Settings\Stephen Chang\My Documents\plt\sandbox\lazy-expand-test.rkt:1:9 f>) (stepper-define-type shortened-proc-define))

(#%app lazy (lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2))))))

#f

lazy

((stepper-binding-type non-lexical))

(lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2)))))


#f

(let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2))))


((stepper-skip-double-break #t) (stepper-hint #<procedure:unwinder>))

(#%app ! +)
((stepper-skipto (syntax-e cdr syntax-e cdr car)))
+
((stepper-binding-type non-lexical))
(quote 1)
#f
x
((stepper-binding-type lambda-bound))
(if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p))
 (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2)))
(((stepper-skipto (syntax-e cdr cdr both-l () (car)))) (stepper-skipto (syntax-e
 cdr cdr both-l () (car))))
(#%app p temp1 x2)
#f
p
((stepper-binding-type let-bound))
temp1
((stepper-binding-type let-bound))
x2
((stepper-binding-type let-bound))
(#%app p (#%app ! temp1) (#%app ! x2))
#f
p
((stepper-binding-type let-bound))
(#%app ! temp1)
((stepper-skipto (syntax-e cdr syntax-e cdr car)))
temp1
((stepper-binding-type let-bound))
(#%app ! x2)
((stepper-skipto (syntax-e cdr syntax-e cdr car)))
x2
((stepper-binding-type let-bound))
(#%app (#%app toplevel-forcer) (let-values (((p) (#%app ! (#%top . f))) ((temp6)
 (quote 10))) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-
procedure? p)) (#%app p temp6) (#%app p (#%app ! temp6)))))
#f
(#%app toplevel-forcer)
#f
toplevel-forcer
((stepper-binding-type non-lexical))
(let-values (((p) (#%app ! (#%top . f))) ((temp6) (quote 10))) (if (if (#%app la
zy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp6)
(#%app p (#%app ! temp6))))
((stepper-skip-double-break #t) (stepper-hint #<procedure:unwinder>))
(#%app ! (#%top . f))
((stepper-skipto (syntax-e cdr syntax-e cdr car)))
(#%top . f)
#f
(quote 10)
#f
(if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p))
 (#%app p temp6) (#%app p (#%app ! temp6)))
(((stepper-skipto (syntax-e cdr cdr both-l () (car)))) (stepper-skipto (syntax-e
 cdr cdr both-l () (car))))
(#%app p temp6)
#f
p
((stepper-binding-type let-bound))
temp6
((stepper-binding-type let-bound))
(#%app p (#%app ! temp6))
#f
p
((stepper-binding-type let-bound))
(#%app ! temp6)
((stepper-skipto (syntax-e cdr syntax-e cdr car)))
temp6
((stepper-binding-type let-bound))





Structure of annotate function:

annotate
    normal-break
    result-exp-break
    result-value-break
    normal-break/values
    exp-finished-break
    double-break
    wcm-pre-break-wrap
    pre-break-wrap
    break-wrap
    double-break-wrap
    return-value-wrap
    normal-break/values-wrap
    top-level-annotate/inner

    annotate/inner
        cond skipto or skipto/discard
             skip-completely
             else let:

        tail-recur
        non-tail-recur
        result-recur
        lambda-body-recur
        make-debug-info-normal
        make-debug-info-app
        outer-wcm-wrap
        wcm-break-wrap
        lambda-clause-abstraction
        outer-lambda-abstraction
        let-abstraction
        if-abstraction
        varref-abraction
        recertifier
        maybe-final-val-wrap

        kernel-syntax-case
            (#%plain-lambda . clause)
            (case-lambda . clauses)
            (if test then else)
            (begin . bodies-stx)
            (begin0 body)
            (begin0 first-body . bodies-stx)
            (let-values . _)
            (letrec-values . _)
            (set! var val)
            (quote _)
            (quote-syntax _)
            (with-continuation-mark key mark body)
            (#%plain-app . terms)
            (#%top . var-stx)
            var-stx
            else
    annotate/top-level
    annotate/module-top-level




Experiment: dump of clause, annotated clause, and free-varrefs in #%plain-lambda case of kernal-syntax in annotate/inner

- test-proc case

(() (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2)))))

(() (begin (let ((lifting-counter (#<procedure:binding-indexer>))) (let-values (
((lifter-p-0 lifter-temp1-1 lifter-x2-2 p temp1 x2 let-counter) (values lifting-
counter lifting-counter lifting-counter #<*unevaluated-struct*> #<*unevaluated-s
truct*> #<*unevaluated-struct*> 0))) (with-continuation-mark #<debug-key-struct>
 (#%plain-lambda () (#%plain-app #<procedure:...rivate\marks.rkt:70:2> (#%plain-
lambda () +) (#%plain-lambda () x) (#%plain-lambda () p) (#%plain-lambda () temp
1) (#%plain-lambda () x2) (#%plain-lambda () let-counter) (#%plain-lambda () lif
ter-p-0) (#%plain-lambda () lifter-temp1-1) (#%plain-lambda () lifter-x2-2))) (b
egin (#%plain-app #<procedure:result-exp-break>) (begin (#%plain-app #<procedure
:double-break>) (begin (set!-values (p) (with-continuation-mark #<debug-key-stru
ct> #<skipto-mark-struct> (#%app ! (with-continuation-mark #<debug-key-struct> (
#%plain-lambda () (#%plain-app #<procedure:...rivate\marks.rkt:70:2>)) +)))) (se
t! let-counter 1) (set!-values (temp1) (with-continuation-mark #<debug-key-struc
t> (#%plain-lambda () (#%plain-app #<procedure:...rivate\marks.rkt:70:2>)) (quot
e 1))) (set! let-counter 2) (set!-values (x2) (with-continuation-mark #<debug-ke
y-struct> (#%plain-lambda () (#%plain-app #<procedure:...rivate\marks.rkt:70:2>)
) x)) (set! let-counter 3) (#%plain-app #<procedure:exp-finished-break> (#%plain
-app list (#%plain-app list #<procedure:...ate\annotate.rkt:653:69> (#%plain-app
 list lifter-p-0) (#%plain-lambda () (#%plain-app list p))) (#%plain-app list #<
procedure:...ate\annotate.rkt:653:69> (#%plain-app list lifter-temp1-1) (#%plain
-lambda () (#%plain-app list temp1))) (#%plain-app list #<procedure:...ate\annot
ate.rkt:653:69> (#%plain-app list lifter-x2-2) (#%plain-lambda () (#%plain-app l
ist x2))))) (with-continuation-mark #<debug-key-struct> #<skipto-mark-struct> (i
f (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (
let-values (((arg0-1545 arg1-1546 arg2-1547) (#%plain-app values #<*unevaluated-
struct*> #<*unevaluated-struct*> #<*unevaluated-struct*>))) (with-continuation-m
ark #<debug-key-struct> (#%plain-lambda () (#%plain-app #<procedure:...rivate\ma
rks.rkt:70:2> (#%plain-lambda () p) (#%plain-lambda () temp1) (#%plain-lambda ()
 x2) (#%plain-lambda () arg0-1545) (#%plain-lambda () arg1-1546) (#%plain-lambda
 () arg2-1547) (#%plain-lambda () lifter-p-0) (#%plain-lambda () lifter-temp1-1)
 (#%plain-lambda () lifter-x2-2))) (begin (set! arg0-1545 (with-continuation-mar
k #<debug-key-struct> (#%plain-lambda () (#%plain-app #<procedure:...rivate\mark
s.rkt:70:2>)) (begin (#%plain-app #<procedure:normal-break>) (#%plain-app call-w
ith-values (#%plain-lambda () p) (#%plain-lambda args (#%plain-app #<procedure:r
esult-value-break> args) (#%plain-app #<procedure:apply> values args)))))) (set!
 arg1-1546 (with-continuation-mark #<debug-key-struct> (#%plain-lambda () (#%pla
in-app #<procedure:...rivate\marks.rkt:70:2>)) (begin (#%plain-app #<procedure:n
ormal-break>) (#%plain-app call-with-values (#%plain-lambda () temp1) (#%plain-l
ambda args (#%plain-app #<procedure:result-value-break> args) (#%plain-app #<pro
cedure:apply> values args)))))) (set! arg2-1547 (with-continuation-mark #<debug-
key-struct> (#%plain-lambda () (#%plain-app #<procedure:...rivate\marks.rkt:70:2
>)) (begin (#%plain-app #<procedure:normal-break>) (#%plain-app call-with-values
 (#%plain-lambda () x2) (#%plain-lambda args (#%plain-app #<procedure:result-val
ue-break> args) (#%plain-app #<procedure:apply> values args)))))) (begin (#%plai
n-app #<procedure:normal-break>) (with-continuation-mark #<debug-key-struct> (#%
plain-lambda () (#%plain-app #<procedure:...rivate\marks.rkt:70:2> (#%plain-lamb
da () arg0-1545) (#%plain-lambda () arg1-1546) (#%plain-lambda () arg2-1547))) (
if (#%plain-app #<procedure:...ivate\shared.rkt:308:7> arg0-1545) (#%plain-app a
rg0-1545 arg1-1546 arg2-1547) (#%plain-app call-with-values (#%plain-lambda () (
#%plain-app arg0-1545 arg1-1546 arg2-1547)) (#%plain-lambda args (#%plain-app #<
procedure:result-value-break> args) (#%plain-app #<procedure:apply> values args)
)))))))) (let-values (((arg0-1545 arg1-1546 arg2-1547) (#%plain-app values #<*un
evaluated-struct*> #<*unevaluated-struct*> #<*unevaluated-struct*>))) (with-cont
inuation-mark #<debug-key-struct> (#%plain-lambda () (#%plain-app #<procedure:..
.rivate\marks.rkt:70:2> (#%plain-lambda () p) (#%plain-lambda () temp1) (#%plain
-lambda () x2) (#%plain-lambda () arg0-1545) (#%plain-lambda () arg1-1546) (#%pl
ain-lambda () arg2-1547) (#%plain-lambda () lifter-p-0) (#%plain-lambda () lifte
r-temp1-1) (#%plain-lambda () lifter-x2-2))) (begin (set! arg0-1545 (with-contin
uation-mark #<debug-key-struct> (#%plain-lambda () (#%plain-app #<procedure:...r
ivate\marks.rkt:70:2>)) (begin (#%plain-app #<procedure:normal-break>) (#%plain-
app call-with-values (#%plain-lambda () p) (#%plain-lambda args (#%plain-app #<p
rocedure:result-value-break> args) (#%plain-app #<procedure:apply> values args))
)))) (set! arg1-1546 (with-continuation-mark #<debug-key-struct> #<skipto-mark-s
truct> (#%app ! (with-continuation-mark #<debug-key-struct> (#%plain-lambda () (
#%plain-app #<procedure:...rivate\marks.rkt:70:2>)) (begin (#%plain-app #<proced
ure:normal-break>) (#%plain-app call-with-values (#%plain-lambda () temp1) (#%pl
ain-lambda args (#%plain-app #<procedure:result-value-break> args) (#%plain-app
#<procedure:apply> values args)))))))) (set! arg2-1547 (with-continuation-mark #
<debug-key-struct> #<skipto-mark-struct> (#%app ! (with-continuation-mark #<debu
g-key-struct> (#%plain-lambda () (#%plain-app #<procedure:...rivate\marks.rkt:70
:2>)) (begin (#%plain-app #<procedure:normal-break>) (#%plain-app call-with-valu
es (#%plain-lambda () x2) (#%plain-lambda args (#%plain-app #<procedure:result-v
alue-break> args) (#%plain-app #<procedure:apply> values args)))))))) (begin (#%
plain-app #<procedure:normal-break>) (with-continuation-mark #<debug-key-struct>
 (#%plain-lambda () (#%plain-app #<procedure:...rivate\marks.rkt:70:2> (#%plain-
lambda () arg0-1545) (#%plain-lambda () arg1-1546) (#%plain-lambda () arg2-1547)
)) (if (#%plain-app #<procedure:...ivate\shared.rkt:308:7> arg0-1545) (#%plain-a
pp arg0-1545 arg1-1546 arg2-1547) (#%plain-app call-with-values (#%plain-lambda
() (#%plain-app arg0-1545 arg1-1546 arg2-1547)) (#%plain-lambda args (#%plain-ap
p #<procedure:result-value-break> args) (#%plain-app #<procedure:apply> values a
rgs)))))))))))))))))))

(#<syntax:C:\Documents and Settings\Stephen Chang\My Documents\plt\sandbox\lazy-expand-test.rkt:1:15 +> #<syntax:C:\Documents and Settings\Stephen Chang\My Documents\plt\sandbox\lazy-expand-test.rkt:1:19 x>)

((x) (#%app lazy (lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2)))))))

((x) (begin (let-values (((arg0-1545 arg1-1546) (#%plain-app values #<*unevaluat
ed-struct*> #<*unevaluated-struct*>))) (with-continuation-mark #<debug-key-struc
t> (#%plain-lambda () (#%plain-app #<procedure:...rivate\marks.rkt:70:2> (#%plai
n-lambda () lazy) (#%plain-lambda () +) (#%plain-lambda () x) (#%plain-lambda ()
 arg0-1545) (#%plain-lambda () arg1-1546))) (begin (#%plain-app #<procedure:resu
lt-exp-break>) (begin (set! arg0-1545 (with-continuation-mark #<debug-key-struct
> (#%plain-lambda () (#%plain-app #<procedure:...rivate\marks.rkt:70:2>)) lazy))
 (set! arg1-1546 (with-continuation-mark #<debug-key-struct> (#%plain-lambda ()
(#%plain-app #<procedure:...rivate\marks.rkt:70:2>)) (#%plain-app #<procedure:cl
osure-storing-proc> (#%plain-lambda () (begin (let ((lifting-counter (#<procedur
e:binding-indexer>))) (let-values (((lifter-p-0 lifter-temp1-1 lifter-x2-2 p tem
p1 x2 let-counter) (values lifting-counter lifting-counter lifting-counter #<*un
evaluated-struct*> #<*unevaluated-struct*> #<*unevaluated-struct*> 0))) (with-co
ntinuation-mark #<debug-key-struct> (#%plain-lambda () (#%plain-app #<procedure:
...rivate\marks.rkt:70:2> (#%plain-lambda () +) (#%plain-lambda () x) (#%plain-l
ambda () p) (#%plain-lambda () temp1) (#%plain-lambda () x2) (#%plain-lambda ()
let-counter) (#%plain-lambda () lifter-p-0) (#%plain-lambda () lifter-temp1-1) (
#%plain-lambda () lifter-x2-2))) (begin (#%plain-app #<procedure:result-exp-brea
k>) (begin (#%plain-app #<procedure:double-break>) (begin (set!-values (p) (with
-continuation-mark #<debug-key-struct> #<skipto-mark-struct> (#%app ! (with-cont
inuation-mark #<debug-key-struct> (#%plain-lambda () (#%plain-app #<procedure:..
.rivate\marks.rkt:70:2>)) +)))) (set! let-counter 1) (set!-values (temp1) (with-
continuation-mark #<debug-key-struct> (#%plain-lambda () (#%plain-app #<procedur
e:...rivate\marks.rkt:70:2>)) (quote 1))) (set! let-counter 2) (set!-values (x2)
 (with-continuation-mark #<debug-key-struct> (#%plain-lambda () (#%plain-app #<p
rocedure:...rivate\marks.rkt:70:2>)) x)) (set! let-counter 3) (#%plain-app #<pro
cedure:exp-finished-break> (#%plain-app list (#%plain-app list #<procedure:...at
e\annotate.rkt:653:69> (#%plain-app list lifter-p-0) (#%plain-lambda () (#%plain
-app list p))) (#%plain-app list #<procedure:...ate\annotate.rkt:653:69> (#%plai
n-app list lifter-temp1-1) (#%plain-lambda () (#%plain-app list temp1))) (#%plai
n-app list #<procedure:...ate\annotate.rkt:653:69> (#%plain-app list lifter-x2-2
) (#%plain-lambda () (#%plain-app list x2))))) (with-continuation-mark #<debug-k
ey-struct> #<skipto-mark-struct> (if (if (#%app lazy-proc? p) (quote #t) (#%app
struct-constructor-procedure? p)) (let-values (((arg0-1545 arg1-1546 arg2-1547)
(#%plain-app values #<*unevaluated-struct*> #<*unevaluated-struct*> #<*unevaluat
ed-struct*>))) (with-continuation-mark #<debug-key-struct> (#%plain-lambda () (#
%plain-app #<procedure:...rivate\marks.rkt:70:2> (#%plain-lambda () p) (#%plain-
lambda () temp1) (#%plain-lambda () x2) (#%plain-lambda () arg0-1545) (#%plain-l
ambda () arg1-1546) (#%plain-lambda () arg2-1547) (#%plain-lambda () lifter-p-0)
 (#%plain-lambda () lifter-temp1-1) (#%plain-lambda () lifter-x2-2))) (begin (se
t! arg0-1545 (with-continuation-mark #<debug-key-struct> (#%plain-lambda () (#%p
lain-app #<procedure:...rivate\marks.rkt:70:2>)) (begin (#%plain-app #<procedure
:normal-break>) (#%plain-app call-with-values (#%plain-lambda () p) (#%plain-lam
bda args (#%plain-app #<procedure:result-value-break> args) (#%plain-app #<proce
dure:apply> values args)))))) (set! arg1-1546 (with-continuation-mark #<debug-ke
y-struct> (#%plain-lambda () (#%plain-app #<procedure:...rivate\marks.rkt:70:2>)
) (begin (#%plain-app #<procedure:normal-break>) (#%plain-app call-with-values (
#%plain-lambda () temp1) (#%plain-lambda args (#%plain-app #<procedure:result-va
lue-break> args) (#%plain-app #<procedure:apply> values args)))))) (set! arg2-15
47 (with-continuation-mark #<debug-key-struct> (#%plain-lambda () (#%plain-app #
<procedure:...rivate\marks.rkt:70:2>)) (begin (#%plain-app #<procedure:normal-br
eak>) (#%plain-app call-with-values (#%plain-lambda () x2) (#%plain-lambda args
(#%plain-app #<procedure:result-value-break> args) (#%plain-app #<procedure:appl
y> values args)))))) (begin (#%plain-app #<procedure:normal-break>) (with-contin
uation-mark #<debug-key-struct> (#%plain-lambda () (#%plain-app #<procedure:...r
ivate\marks.rkt:70:2> (#%plain-lambda () arg0-1545) (#%plain-lambda () arg1-1546
) (#%plain-lambda () arg2-1547))) (if (#%plain-app #<procedure:...ivate\shared.r
kt:308:7> arg0-1545) (#%plain-app arg0-1545 arg1-1546 arg2-1547) (#%plain-app ca
ll-with-values (#%plain-lambda () (#%plain-app arg0-1545 arg1-1546 arg2-1547)) (
#%plain-lambda args (#%plain-app #<procedure:result-value-break> args) (#%plain-
app #<procedure:apply> values args))))))))) (let-values (((arg0-1545 arg1-1546 a
rg2-1547) (#%plain-app values #<*unevaluated-struct*> #<*unevaluated-struct*> #<
*unevaluated-struct*>))) (with-continuation-mark #<debug-key-struct> (#%plain-la
mbda () (#%plain-app #<procedure:...rivate\marks.rkt:70:2> (#%plain-lambda () p)
 (#%plain-lambda () temp1) (#%plain-lambda () x2) (#%plain-lambda () arg0-1545)
(#%plain-lambda () arg1-1546) (#%plain-lambda () arg2-1547) (#%plain-lambda () l
ifter-p-0) (#%plain-lambda () lifter-temp1-1) (#%plain-lambda () lifter-x2-2)))
(begin (set! arg0-1545 (with-continuation-mark #<debug-key-struct> (#%plain-lamb
da () (#%plain-app #<procedure:...rivate\marks.rkt:70:2>)) (begin (#%plain-app #
<procedure:normal-break>) (#%plain-app call-with-values (#%plain-lambda () p) (#
%plain-lambda args (#%plain-app #<procedure:result-value-break> args) (#%plain-a
pp #<procedure:apply> values args)))))) (set! arg1-1546 (with-continuation-mark
#<debug-key-struct> #<skipto-mark-struct> (#%app ! (with-continuation-mark #<deb
ug-key-struct> (#%plain-lambda () (#%plain-app #<procedure:...rivate\marks.rkt:7
0:2>)) (begin (#%plain-app #<procedure:normal-break>) (#%plain-app call-with-val
ues (#%plain-lambda () temp1) (#%plain-lambda args (#%plain-app #<procedure:resu
lt-value-break> args) (#%plain-app #<procedure:apply> values args)))))))) (set!
arg2-1547 (with-continuation-mark #<debug-key-struct> #<skipto-mark-struct> (#%a
pp ! (with-continuation-mark #<debug-key-struct> (#%plain-lambda () (#%plain-app
 #<procedure:...rivate\marks.rkt:70:2>)) (begin (#%plain-app #<procedure:normal-
break>) (#%plain-app call-with-values (#%plain-lambda () x2) (#%plain-lambda arg
s (#%plain-app #<procedure:result-value-break> args) (#%plain-app #<procedure:ap
ply> values args)))))))) (begin (#%plain-app #<procedure:normal-break>) (with-co
ntinuation-mark #<debug-key-struct> (#%plain-lambda () (#%plain-app #<procedure:
...rivate\marks.rkt:70:2> (#%plain-lambda () arg0-1545) (#%plain-lambda () arg1-
1546) (#%plain-lambda () arg2-1547))) (if (#%plain-app #<procedure:...ivate\shar
ed.rkt:308:7> arg0-1545) (#%plain-app arg0-1545 arg1-1546 arg2-1547) (#%plain-ap
p call-with-values (#%plain-lambda () (#%plain-app arg0-1545 arg1-1546 arg2-1547
)) (#%plain-lambda args (#%plain-app #<procedure:result-value-break> args) (#%pl
ain-app #<procedure:apply> values args))))))))))))))))))) (#%plain-lambda () (#%
plain-app #<procedure:...rivate\marks.rkt:70:2> (#%plain-lambda () +) (#%plain-l
ambda () x)))))) (begin (#%plain-app #<procedure:normal-break>) (with-continuati
on-mark #<debug-key-struct> (#%plain-lambda () (#%plain-app #<procedure:...rivat
e\marks.rkt:70:2> (#%plain-lambda () arg0-1545) (#%plain-lambda () arg1-1546)))
(if (#%plain-app #<procedure:...ivate\shared.rkt:308:7> arg0-1545) (#%plain-app
arg0-1545 arg1-1546) (#%plain-app call-with-values (#%plain-lambda () (#%plain-a
pp arg0-1545 arg1-1546)) (#%plain-lambda args (#%plain-app #<procedure:result-va
lue-break> args) (#%plain-app #<procedure:apply> values args))))))))))))

(#<syntax lazy> #<syntax:C:\Documents and Settings\Stephen Chang\My Documents\plt\sandbox\lazy-expand-test.rkt:1:15 +>)



 - lazy-proc case

(() (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2)))))

(() (begin (let ((lifting-counter (#<procedure:binding-indexer>))) (let-values (
((lifter-p-0 lifter-temp1-1 lifter-x2-2 p temp1 x2 let-counter) (values lifting-
counter lifting-counter lifting-counter #<*unevaluated-struct*> #<*unevaluated-s
truct*> #<*unevaluated-struct*> 0))) (with-continuation-mark #<debug-key-struct>
 (#%plain-lambda () (#%plain-app #<procedure:...rivate\marks.rkt:70:2> (#%plain-
lambda () +) (#%plain-lambda () x) (#%plain-lambda () p) (#%plain-lambda () temp
1) (#%plain-lambda () x2) (#%plain-lambda () let-counter) (#%plain-lambda () lif
ter-p-0) (#%plain-lambda () lifter-temp1-1) (#%plain-lambda () lifter-x2-2))) (b
egin (#%plain-app #<procedure:result-exp-break>) (begin (#%plain-app #<procedure
:double-break>) (begin (set!-values (p) (with-continuation-mark #<debug-key-stru
ct> #<skipto-mark-struct> (#%app ! (with-continuation-mark #<debug-key-struct> (
#%plain-lambda () (#%plain-app #<procedure:...rivate\marks.rkt:70:2>)) +)))) (se
t! let-counter 1) (set!-values (temp1) (with-continuation-mark #<debug-key-struc
t> (#%plain-lambda () (#%plain-app #<procedure:...rivate\marks.rkt:70:2>)) (quot
e 1))) (set! let-counter 2) (set!-values (x2) (with-continuation-mark #<debug-ke
y-struct> (#%plain-lambda () (#%plain-app #<procedure:...rivate\marks.rkt:70:2>)
) x)) (set! let-counter 3) (#%plain-app #<procedure:exp-finished-break> (#%plain
-app list (#%plain-app list #<procedure:...ate\annotate.rkt:653:69> (#%plain-app
 list lifter-p-0) (#%plain-lambda () (#%plain-app list p))) (#%plain-app list #<
procedure:...ate\annotate.rkt:653:69> (#%plain-app list lifter-temp1-1) (#%plain
-lambda () (#%plain-app list temp1))) (#%plain-app list #<procedure:...ate\annot
ate.rkt:653:69> (#%plain-app list lifter-x2-2) (#%plain-lambda () (#%plain-app l
ist x2))))) (with-continuation-mark #<debug-key-struct> #<skipto-mark-struct> (i
f (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (
let-values (((arg0-1545 arg1-1546 arg2-1547) (#%plain-app values #<*unevaluated-
struct*> #<*unevaluated-struct*> #<*unevaluated-struct*>))) (with-continuation-m
ark #<debug-key-struct> (#%plain-lambda () (#%plain-app #<procedure:...rivate\ma
rks.rkt:70:2> (#%plain-lambda () p) (#%plain-lambda () temp1) (#%plain-lambda ()
 x2) (#%plain-lambda () arg0-1545) (#%plain-lambda () arg1-1546) (#%plain-lambda
 () arg2-1547) (#%plain-lambda () lifter-p-0) (#%plain-lambda () lifter-temp1-1)
 (#%plain-lambda () lifter-x2-2))) (begin (set! arg0-1545 (with-continuation-mar
k #<debug-key-struct> (#%plain-lambda () (#%plain-app #<procedure:...rivate\mark
s.rkt:70:2>)) (begin (#%plain-app #<procedure:normal-break>) (#%plain-app call-w
ith-values (#%plain-lambda () p) (#%plain-lambda args (#%plain-app #<procedure:r
esult-value-break> args) (#%plain-app #<procedure:apply> values args)))))) (set!
 arg1-1546 (with-continuation-mark #<debug-key-struct> (#%plain-lambda () (#%pla
in-app #<procedure:...rivate\marks.rkt:70:2>)) (begin (#%plain-app #<procedure:n
ormal-break>) (#%plain-app call-with-values (#%plain-lambda () temp1) (#%plain-l
ambda args (#%plain-app #<procedure:result-value-break> args) (#%plain-app #<pro
cedure:apply> values args)))))) (set! arg2-1547 (with-continuation-mark #<debug-
key-struct> (#%plain-lambda () (#%plain-app #<procedure:...rivate\marks.rkt:70:2
>)) (begin (#%plain-app #<procedure:normal-break>) (#%plain-app call-with-values
 (#%plain-lambda () x2) (#%plain-lambda args (#%plain-app #<procedure:result-val
ue-break> args) (#%plain-app #<procedure:apply> values args)))))) (begin (#%plai
n-app #<procedure:normal-break>) (with-continuation-mark #<debug-key-struct> (#%
plain-lambda () (#%plain-app #<procedure:...rivate\marks.rkt:70:2> (#%plain-lamb
da () arg0-1545) (#%plain-lambda () arg1-1546) (#%plain-lambda () arg2-1547))) (
if (#%plain-app #<procedure:...ivate\shared.rkt:308:7> arg0-1545) (#%plain-app a
rg0-1545 arg1-1546 arg2-1547) (#%plain-app call-with-values (#%plain-lambda () (
#%plain-app arg0-1545 arg1-1546 arg2-1547)) (#%plain-lambda args (#%plain-app #<
procedure:result-value-break> args) (#%plain-app #<procedure:apply> values args)
)))))))) (let-values (((arg0-1545 arg1-1546 arg2-1547) (#%plain-app values #<*un
evaluated-struct*> #<*unevaluated-struct*> #<*unevaluated-struct*>))) (with-cont
inuation-mark #<debug-key-struct> (#%plain-lambda () (#%plain-app #<procedure:..
.rivate\marks.rkt:70:2> (#%plain-lambda () p) (#%plain-lambda () temp1) (#%plain
-lambda () x2) (#%plain-lambda () arg0-1545) (#%plain-lambda () arg1-1546) (#%pl
ain-lambda () arg2-1547) (#%plain-lambda () lifter-p-0) (#%plain-lambda () lifte
r-temp1-1) (#%plain-lambda () lifter-x2-2))) (begin (set! arg0-1545 (with-contin
uation-mark #<debug-key-struct> (#%plain-lambda () (#%plain-app #<procedure:...r
ivate\marks.rkt:70:2>)) (begin (#%plain-app #<procedure:normal-break>) (#%plain-
app call-with-values (#%plain-lambda () p) (#%plain-lambda args (#%plain-app #<p
rocedure:result-value-break> args) (#%plain-app #<procedure:apply> values args))
)))) (set! arg1-1546 (with-continuation-mark #<debug-key-struct> #<skipto-mark-s
truct> (#%app ! (with-continuation-mark #<debug-key-struct> (#%plain-lambda () (
#%plain-app #<procedure:...rivate\marks.rkt:70:2>)) (begin (#%plain-app #<proced
ure:normal-break>) (#%plain-app call-with-values (#%plain-lambda () temp1) (#%pl
ain-lambda args (#%plain-app #<procedure:result-value-break> args) (#%plain-app
#<procedure:apply> values args)))))))) (set! arg2-1547 (with-continuation-mark #
<debug-key-struct> #<skipto-mark-struct> (#%app ! (with-continuation-mark #<debu
g-key-struct> (#%plain-lambda () (#%plain-app #<procedure:...rivate\marks.rkt:70
:2>)) (begin (#%plain-app #<procedure:normal-break>) (#%plain-app call-with-valu
es (#%plain-lambda () x2) (#%plain-lambda args (#%plain-app #<procedure:result-v
alue-break> args) (#%plain-app #<procedure:apply> values args)))))))) (begin (#%
plain-app #<procedure:normal-break>) (with-continuation-mark #<debug-key-struct>
 (#%plain-lambda () (#%plain-app #<procedure:...rivate\marks.rkt:70:2> (#%plain-
lambda () arg0-1545) (#%plain-lambda () arg1-1546) (#%plain-lambda () arg2-1547)
)) (if (#%plain-app #<procedure:...ivate\shared.rkt:308:7> arg0-1545) (#%plain-a
pp arg0-1545 arg1-1546 arg2-1547) (#%plain-app call-with-values (#%plain-lambda
() (#%plain-app arg0-1545 arg1-1546 arg2-1547)) (#%plain-lambda args (#%plain-ap
p #<procedure:result-value-break> args) (#%plain-app #<procedure:apply> values a
rgs)))))))))))))))))))

(#<syntax:C:\Documents and Settings\Stephen Chang\My Documents\plt\sandbox\lazy-expand-test.rkt:1:15 +> #<syntax:C:\Documents and Settings\Stephen Chang\My Documents\plt\sandbox\lazy-expand-test.rkt:1:19 x>)

((x) (#%app lazy (lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) (
(x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-proce
dure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2)))))))

((x) (begin (let-values (((arg0-1545 arg1-1546) (#%plain-app values #<*unevaluat
ed-struct*> #<*unevaluated-struct*>))) (with-continuation-mark #<debug-key-struc
t> (#%plain-lambda () (#%plain-app #<procedure:...rivate\marks.rkt:70:2> (#%plai
n-lambda () lazy) (#%plain-lambda () +) (#%plain-lambda () x) (#%plain-lambda ()
 arg0-1545) (#%plain-lambda () arg1-1546))) (begin (#%plain-app #<procedure:resu
lt-exp-break>) (begin (set! arg0-1545 (with-continuation-mark #<debug-key-struct
> (#%plain-lambda () (#%plain-app #<procedure:...rivate\marks.rkt:70:2>)) lazy))
 (set! arg1-1546 (with-continuation-mark #<debug-key-struct> (#%plain-lambda ()
(#%plain-app #<procedure:...rivate\marks.rkt:70:2>)) (#%plain-app #<procedure:cl
osure-storing-proc> (#%plain-lambda () (begin (let ((lifting-counter (#<procedur
e:binding-indexer>))) (let-values (((lifter-p-0 lifter-temp1-1 lifter-x2-2 p tem
p1 x2 let-counter) (values lifting-counter lifting-counter lifting-counter #<*un
evaluated-struct*> #<*unevaluated-struct*> #<*unevaluated-struct*> 0))) (with-co
ntinuation-mark #<debug-key-struct> (#%plain-lambda () (#%plain-app #<procedure:
...rivate\marks.rkt:70:2> (#%plain-lambda () +) (#%plain-lambda () x) (#%plain-l
ambda () p) (#%plain-lambda () temp1) (#%plain-lambda () x2) (#%plain-lambda ()
let-counter) (#%plain-lambda () lifter-p-0) (#%plain-lambda () lifter-temp1-1) (
#%plain-lambda () lifter-x2-2))) (begin (#%plain-app #<procedure:result-exp-brea
k>) (begin (#%plain-app #<procedure:double-break>) (begin (set!-values (p) (with
-continuation-mark #<debug-key-struct> #<skipto-mark-struct> (#%app ! (with-cont
inuation-mark #<debug-key-struct> (#%plain-lambda () (#%plain-app #<procedure:..
.rivate\marks.rkt:70:2>)) +)))) (set! let-counter 1) (set!-values (temp1) (with-
continuation-mark #<debug-key-struct> (#%plain-lambda () (#%plain-app #<procedur
e:...rivate\marks.rkt:70:2>)) (quote 1))) (set! let-counter 2) (set!-values (x2)
 (with-continuation-mark #<debug-key-struct> (#%plain-lambda () (#%plain-app #<p
rocedure:...rivate\marks.rkt:70:2>)) x)) (set! let-counter 3) (#%plain-app #<pro
cedure:exp-finished-break> (#%plain-app list (#%plain-app list #<procedure:...at
e\annotate.rkt:653:69> (#%plain-app list lifter-p-0) (#%plain-lambda () (#%plain
-app list p))) (#%plain-app list #<procedure:...ate\annotate.rkt:653:69> (#%plai
n-app list lifter-temp1-1) (#%plain-lambda () (#%plain-app list temp1))) (#%plai
n-app list #<procedure:...ate\annotate.rkt:653:69> (#%plain-app list lifter-x2-2
) (#%plain-lambda () (#%plain-app list x2))))) (with-continuation-mark #<debug-k
ey-struct> #<skipto-mark-struct> (if (if (#%app lazy-proc? p) (quote #t) (#%app
struct-constructor-procedure? p)) (let-values (((arg0-1545 arg1-1546 arg2-1547)
(#%plain-app values #<*unevaluated-struct*> #<*unevaluated-struct*> #<*unevaluat
ed-struct*>))) (with-continuation-mark #<debug-key-struct> (#%plain-lambda () (#
%plain-app #<procedure:...rivate\marks.rkt:70:2> (#%plain-lambda () p) (#%plain-
lambda () temp1) (#%plain-lambda () x2) (#%plain-lambda () arg0-1545) (#%plain-l
ambda () arg1-1546) (#%plain-lambda () arg2-1547) (#%plain-lambda () lifter-p-0)
 (#%plain-lambda () lifter-temp1-1) (#%plain-lambda () lifter-x2-2))) (begin (se
t! arg0-1545 (with-continuation-mark #<debug-key-struct> (#%plain-lambda () (#%p
lain-app #<procedure:...rivate\marks.rkt:70:2>)) (begin (#%plain-app #<procedure
:normal-break>) (#%plain-app call-with-values (#%plain-lambda () p) (#%plain-lam
bda args (#%plain-app #<procedure:result-value-break> args) (#%plain-app #<proce
dure:apply> values args)))))) (set! arg1-1546 (with-continuation-mark #<debug-ke
y-struct> (#%plain-lambda () (#%plain-app #<procedure:...rivate\marks.rkt:70:2>)
) (begin (#%plain-app #<procedure:normal-break>) (#%plain-app call-with-values (
#%plain-lambda () temp1) (#%plain-lambda args (#%plain-app #<procedure:result-va
lue-break> args) (#%plain-app #<procedure:apply> values args)))))) (set! arg2-15
47 (with-continuation-mark #<debug-key-struct> (#%plain-lambda () (#%plain-app #
<procedure:...rivate\marks.rkt:70:2>)) (begin (#%plain-app #<procedure:normal-br
eak>) (#%plain-app call-with-values (#%plain-lambda () x2) (#%plain-lambda args
(#%plain-app #<procedure:result-value-break> args) (#%plain-app #<procedure:appl
y> values args)))))) (begin (#%plain-app #<procedure:normal-break>) (with-contin
uation-mark #<debug-key-struct> (#%plain-lambda () (#%plain-app #<procedure:...r
ivate\marks.rkt:70:2> (#%plain-lambda () arg0-1545) (#%plain-lambda () arg1-1546
) (#%plain-lambda () arg2-1547))) (if (#%plain-app #<procedure:...ivate\shared.r
kt:308:7> arg0-1545) (#%plain-app arg0-1545 arg1-1546 arg2-1547) (#%plain-app ca
ll-with-values (#%plain-lambda () (#%plain-app arg0-1545 arg1-1546 arg2-1547)) (
#%plain-lambda args (#%plain-app #<procedure:result-value-break> args) (#%plain-
app #<procedure:apply> values args))))))))) (let-values (((arg0-1545 arg1-1546 a
rg2-1547) (#%plain-app values #<*unevaluated-struct*> #<*unevaluated-struct*> #<
*unevaluated-struct*>))) (with-continuation-mark #<debug-key-struct> (#%plain-la
mbda () (#%plain-app #<procedure:...rivate\marks.rkt:70:2> (#%plain-lambda () p)
 (#%plain-lambda () temp1) (#%plain-lambda () x2) (#%plain-lambda () arg0-1545)
(#%plain-lambda () arg1-1546) (#%plain-lambda () arg2-1547) (#%plain-lambda () l
ifter-p-0) (#%plain-lambda () lifter-temp1-1) (#%plain-lambda () lifter-x2-2)))
(begin (set! arg0-1545 (with-continuation-mark #<debug-key-struct> (#%plain-lamb
da () (#%plain-app #<procedure:...rivate\marks.rkt:70:2>)) (begin (#%plain-app #
<procedure:normal-break>) (#%plain-app call-with-values (#%plain-lambda () p) (#
%plain-lambda args (#%plain-app #<procedure:result-value-break> args) (#%plain-a
pp #<procedure:apply> values args)))))) (set! arg1-1546 (with-continuation-mark
#<debug-key-struct> #<skipto-mark-struct> (#%app ! (with-continuation-mark #<deb
ug-key-struct> (#%plain-lambda () (#%plain-app #<procedure:...rivate\marks.rkt:7
0:2>)) (begin (#%plain-app #<procedure:normal-break>) (#%plain-app call-with-val
ues (#%plain-lambda () temp1) (#%plain-lambda args (#%plain-app #<procedure:resu
lt-value-break> args) (#%plain-app #<procedure:apply> values args)))))))) (set!
arg2-1547 (with-continuation-mark #<debug-key-struct> #<skipto-mark-struct> (#%a
pp ! (with-continuation-mark #<debug-key-struct> (#%plain-lambda () (#%plain-app
 #<procedure:...rivate\marks.rkt:70:2>)) (begin (#%plain-app #<procedure:normal-
break>) (#%plain-app call-with-values (#%plain-lambda () x2) (#%plain-lambda arg
s (#%plain-app #<procedure:result-value-break> args) (#%plain-app #<procedure:ap
ply> values args)))))))) (begin (#%plain-app #<procedure:normal-break>) (with-co
ntinuation-mark #<debug-key-struct> (#%plain-lambda () (#%plain-app #<procedure:
...rivate\marks.rkt:70:2> (#%plain-lambda () arg0-1545) (#%plain-lambda () arg1-
1546) (#%plain-lambda () arg2-1547))) (if (#%plain-app #<procedure:...ivate\shar
ed.rkt:308:7> arg0-1545) (#%plain-app arg0-1545 arg1-1546 arg2-1547) (#%plain-ap
p call-with-values (#%plain-lambda () (#%plain-app arg0-1545 arg1-1546 arg2-1547
)) (#%plain-lambda args (#%plain-app #<procedure:result-value-break> args) (#%pl
ain-app #<procedure:apply> values args))))))))))))))))))) (#%plain-lambda () (#%
plain-app #<procedure:...rivate\marks.rkt:70:2> (#%plain-lambda () +) (#%plain-l
ambda () x)))))) (begin (#%plain-app #<procedure:normal-break>) (with-continuati
on-mark #<debug-key-struct> (#%plain-lambda () (#%plain-app #<procedure:...rivat
e\marks.rkt:70:2> (#%plain-lambda () arg0-1545) (#%plain-lambda () arg1-1546)))
(if (#%plain-app #<procedure:...ivate\shared.rkt:308:7> arg0-1545) (#%plain-app
arg0-1545 arg1-1546) (#%plain-app call-with-values (#%plain-lambda () (#%plain-a
pp arg0-1545 arg1-1546)) (#%plain-lambda args (#%plain-app #<procedure:result-va
lue-break> args) (#%plain-app #<procedure:apply> values args))))))))))))

(#<syntax lazy> #<syntax:C:\Documents and Settings\Stephen Chang\My Documents\plt\sandbox\lazy-expand-test.rkt:1:15 +>)


Experiment: checking out what is happening outer lambda abstraction (only place where closure-table-put! gets called)
 - for both lazy-proc and test-proc, show-lambdas-as-lambdas = #t, procedure-name-info = #f and f (symbol f, not false), and closure-name = #f
 - i'm starting to think the problem is not in the annotation code



Experiment: dump of vals given to recon-value
  - when test-proc is used, body of lambda seems to be processed (evidenced by the 1), but body is not processed when lazy-proc is used (no 1)

- using test-proc

#<procedure:...ts\lazy\lazy.rkt:206:19>
1
#<procedure:parameter-procedure>
10
#<procedure:...ts\lazy\lazy.rkt:206:19>
1
#<procedure:force>
10
#<procedure:...ts\lazy\lazy.rkt:206:19>
1
#<procedure:...ts\lazy\lazy.rkt:206:19>
1
#<procedure:...ts\lazy\lazy.rkt:206:19>
1
10
#<procedure:force>
#<procedure:...ts\lazy\lazy.rkt:206:19>
1
#<procedure:...ts\lazy\lazy.rkt:206:19>
1
10
#<procedure:...ts\lazy\lazy.rkt:206:19>
1
#<procedure:force>
10
#<procedure:...ts\lazy\lazy.rkt:206:19>
1
#<procedure:...ts\lazy\lazy.rkt:206:19>
1
10
#<procedure:...ts\lazy\lazy.rkt:206:19>
1
#<procedure:force>
#<procedure:...ts\lazy\lazy.rkt:206:19>
1
#<procedure:...ts\lazy\lazy.rkt:206:19>
1
10
10
#<procedure:...ts\lazy\lazy.rkt:206:19>
1
#<procedure:force>
#<procedure:...ts\lazy\lazy.rkt:206:19>
1
#<procedure:...ts\lazy\lazy.rkt:206:19>
1
10
#<procedure:...ts\lazy\lazy.rkt:206:19>
1
10
#<procedure:force>
#<procedure:...ts\lazy\lazy.rkt:206:19>
1
#<procedure:...ts\lazy\lazy.rkt:206:19>
1
10
1
10
#<procedure:force>
#<procedure:+>
#<procedure:...ts\lazy\lazy.rkt:206:19>
1
#<procedure:...ts\lazy\lazy.rkt:206:19>
1
10
#<procedure:+>
1
10
#<procedure:force>
#<promise:!running!...ts\lazy\lazy.rkt:337:29>
#<procedure:...ts\lazy\lazy.rkt:206:19>
1
#<procedure:...ts\lazy\lazy.rkt:206:19>
1
10
#<procedure:+>
1
10
#<procedure:+>
#<procedure:force>
#<promise:!running!...ts\lazy\lazy.rkt:337:29>
1
#<procedure:...ts\lazy\lazy.rkt:206:19>
1
#<procedure:...ts\lazy\lazy.rkt:206:19>
1
10
#<procedure:+>
1
10
#<procedure:+>
#<procedure:force>
#<promise:!running!...ts\lazy\lazy.rkt:337:29>
#<procedure:...ts\lazy\lazy.rkt:206:19>
1
#<procedure:...ts\lazy\lazy.rkt:206:19>
1
10
#<procedure:+>
1
10
1
#<procedure:+>
#<procedure:force>
#<promise:!running!...ts\lazy\lazy.rkt:337:29>
10
#<procedure:...ts\lazy\lazy.rkt:206:19>
1
#<procedure:...ts\lazy\lazy.rkt:206:19>
1
10
#<procedure:+>
1
10
#<procedure:+>
1
#<procedure:force>
#<promise:!running!...ts\lazy\lazy.rkt:337:29>
#<procedure:...ts\lazy\lazy.rkt:206:19>
1
#<procedure:...ts\lazy\lazy.rkt:206:19>
1
10
#<procedure:+>
1
10
10
#<procedure:+>
1
#<procedure:force>
#<promise:!running!...ts\lazy\lazy.rkt:337:29>
#<procedure:...ts\lazy\lazy.rkt:206:19>
1
#<procedure:...ts\lazy\lazy.rkt:206:19>
1
10
#<procedure:+>
1
10
#<procedure:+>
1
10
#<procedure:force>
#<promise:!running!...ts\lazy\lazy.rkt:337:29>
#<procedure:...ts\lazy\lazy.rkt:206:19>
1
#<procedure:...ts\lazy\lazy.rkt:206:19>
1
10
#<procedure:+>
1
10
11
#<procedure:force>
#<promise:!running!...ts\lazy\lazy.rkt:337:29>
#<procedure:...ts\lazy\lazy.rkt:206:19>
1
#<procedure:...ts\lazy\lazy.rkt:206:19>
1
10
#<procedure:+>
1
10
11


 - using lazy-proc

#<procedure:...ts\lazy\lazy.rkt:206:19>
#<procedure:parameter-procedure>
10
#<procedure:...ts\lazy\lazy.rkt:206:19>
#<procedure:force>
10
#<procedure:...ts\lazy\lazy.rkt:206:19>
#<procedure:...ts\lazy\lazy.rkt:206:19>
#<procedure:...ts\lazy\lazy.rkt:206:19>
10
#<procedure:force>
#<procedure:...ts\lazy\lazy.rkt:206:19>
#<procedure:...ts\lazy\lazy.rkt:206:19>
10
#<procedure:...ts\lazy\lazy.rkt:206:19>
#<procedure:force>
10
#<procedure:...ts\lazy\lazy.rkt:206:19>
#<procedure:...ts\lazy\lazy.rkt:206:19>
10
#<procedure:...ts\lazy\lazy.rkt:206:19>
#<procedure:force>
#<procedure:...ts\lazy\lazy.rkt:206:19>
#<procedure:...ts\lazy\lazy.rkt:206:19>
10
10
#<procedure:...ts\lazy\lazy.rkt:206:19>
#<procedure:force>
#<procedure:...ts\lazy\lazy.rkt:206:19>
#<procedure:...ts\lazy\lazy.rkt:206:19>
10
#<procedure:...ts\lazy\lazy.rkt:206:19>
10
#<procedure:force>
#<procedure:...ts\lazy\lazy.rkt:206:19>
#<procedure:...ts\lazy\lazy.rkt:206:19>
10
1
10
#<procedure:...ts\lazy\lazy.rkt:206:19>
10
#<procedure:force>
#<procedure:...ts\lazy\lazy.rkt:206:19>
#<procedure:...ts\lazy\lazy.rkt:206:19>
10
#<promise:...ts\lazy\lazy.rkt:337:29>
#<procedure:force>
#<procedure:+>
#<procedure:...ts\lazy\lazy.rkt:206:19>
#<procedure:...ts\lazy\lazy.rkt:206:19>
10
#<procedure:+>
1
10
#<procedure:force>
#<promise:!running!...ts\lazy\lazy.rkt:337:29>
#<procedure:...ts\lazy\lazy.rkt:206:19>
#<procedure:...ts\lazy\lazy.rkt:206:19>
10
#<procedure:+>
1
10
#<procedure:+>
#<procedure:force>
#<promise:!running!...ts\lazy\lazy.rkt:337:29>
1
#<procedure:...ts\lazy\lazy.rkt:206:19>
#<procedure:...ts\lazy\lazy.rkt:206:19>
10
#<procedure:+>
1
10
#<procedure:+>
#<procedure:force>
#<promise:!running!...ts\lazy\lazy.rkt:337:29>
#<procedure:...ts\lazy\lazy.rkt:206:19>
#<procedure:...ts\lazy\lazy.rkt:206:19>
10
#<procedure:+>
1
10
1
#<procedure:+>
#<procedure:force>
#<promise:!running!...ts\lazy\lazy.rkt:337:29>
10
#<procedure:...ts\lazy\lazy.rkt:206:19>
#<procedure:...ts\lazy\lazy.rkt:206:19>
10
#<procedure:+>
1
10
#<procedure:+>
1
#<procedure:force>
#<promise:!running!...ts\lazy\lazy.rkt:337:29>
#<procedure:...ts\lazy\lazy.rkt:206:19>
#<procedure:...ts\lazy\lazy.rkt:206:19>
10
#<procedure:+>
1
10
10
#<procedure:+>
1
#<procedure:force>
#<promise:!running!...ts\lazy\lazy.rkt:337:29>
#<procedure:...ts\lazy\lazy.rkt:206:19>
#<procedure:...ts\lazy\lazy.rkt:206:19>
10
#<procedure:+>
1
10
#<procedure:+>
1
10
#<procedure:force>
#<promise:!running!...ts\lazy\lazy.rkt:337:29>
#<procedure:...ts\lazy\lazy.rkt:206:19>
#<procedure:...ts\lazy\lazy.rkt:206:19>
10
#<procedure:+>
1
10
11
#<procedure:force>
#<promise:!running!...ts\lazy\lazy.rkt:337:29>
#<procedure:...ts\lazy\lazy.rkt:206:19>
#<procedure:...ts\lazy\lazy.rkt:206:19>
10
#<procedure:+>
1
10
11





TODO for tomorrow: 
 - look at how lambdas are reconstructed for both lazy-proc and test-proc - start in recon-value function?


--------------------------------------------------------------------------------
----- 7/1/2010 - LAPTOP
--------------------------------------------------------------------------------

Experiment: dump of vars given to stepper/private/reconstruct.rkt::recon-source-expr

 - using test-proc:
lazy + x p temp1 x2 p temp1 x2 p temp6 p temp6 lazy + x p temp1 x2 p temp1 x2 p
temp6 p temp6 lazy + x p temp1 x2 p temp1 x2 lazy + x p temp1 x2 p temp1 x2 lazy
 + x p temp1 x2 p temp1 x2 p temp6 lazy + x p temp1 x2 p temp1 x2 lazy + x p tem
p1 x2 p temp1 x2 lazy + x p temp1 x2 p temp1 x2 temp6 lazy + x p temp1 x2 p temp
1 x2 lazy + x p temp1 x2 p temp1 x2 temp6 lazy + x p temp1 x2 p temp1 x2 lazy +
x p temp1 x2 p temp1 x2 lazy + x p temp1 x2 p temp1 x2 lazy + x p temp1 x2 p tem
p1 x2 lazy + x p temp1 x2 p temp1 x2 lazy + x p temp1 x2 p temp1 x2 lazy + x p t
emp1 x2 p temp1 x2 lazy + x p temp1 x2 p temp1 x2 lazy + x p temp1 x2 p temp1 x2
 lazy + x p temp1 x2 p temp1 x2 lazy + x p temp1 x2 p temp1 x2 lazy + x p temp1
x2 p temp1 x2 p temp1 x2 lazy + x p temp1 x2 p temp1 x2 lazy + x p temp1 x2 p te
mp1 x2 temp1 x2 lazy + x p temp1 x2 p temp1 x2 lazy + x p temp1 x2 p temp1 x2 te
mp1 x2 lazy + x p temp1 x2 p temp1 x2 lazy + x p temp1 x2 p temp1 x2 x2 lazy + x
 p temp1 x2 p temp1 x2 lazy + x p temp1 x2 p temp1 x2 x2 lazy + x p temp1 x2 p t
emp1 x2 lazy + x p temp1 x2 p temp1 x2 lazy + x p temp1 x2 p temp1 x2 lazy + x p
 temp1 x2 p temp1 x2 lazy + x p temp1 x2 p temp1 x2 lazy + x p temp1 x2 p temp1
x2 lazy + x p temp1 x2 p temp1 x2 lazy + x p temp1 x2 p temp1 x2

 - using lazy-proc:
p temp6 p temp6 p temp6 p temp6 p temp6 temp6 temp6 lazy + x p temp1 x2 p temp1
x2 p temp1 x2 temp1 x2 temp1 x2 x2 x2



Experiment: dump of free-vars-captured after annotation in annotate/inner

- with lazy-proc:
(#<syntax:C:\Documents and Settings\Stephen Chang\My Documents\plt\sandbox\lazy-
expand-test.rkt:1:15 +>)
(#<syntax temp1>)
(#<syntax x2>)
(#<syntax:C:\Program Files\Racket-Full-5.0.0.1\collects\lazy\lazy.rkt:326:50 p>
#<syntax temp1> #<syntax x2>)
(#<syntax lazy> #<syntax:C:\Documents and Settings\Stephen Chang\My Documents\pl
t\sandbox\lazy-expand-test.rkt:1:15 +>)
(#<syntax:C:\Documents and Settings\Stephen Chang\My Documents\plt\sandbox\lazy-
expand-test.rkt:3:1 f>)
(#<syntax temp6>)
(#<syntax:C:\Program Files\Racket-Full-5.0.0.1\collects\lazy\lazy.rkt:326:50 p>
#<syntax temp6>)

- with test-proc
(#<syntax:C:\Documents and Settings\Stephen Chang\My Documents\plt\sandbox\lazy-
expand-test.rkt:1:15 +>)
(#<syntax temp1>)
(#<syntax x2>)
(#<syntax:C:\Program Files\Racket-Full-5.0.0.1\collects\lazy\lazy.rkt:326:50 p>
#<syntax temp1> #<syntax x2>)
(#<syntax lazy> #<syntax:C:\Documents and Settings\Stephen Chang\My Documents\pl
t\sandbox\lazy-expand-test.rkt:1:15 +>)
(#<syntax:C:\Documents and Settings\Stephen Chang\My Documents\plt\sandbox\lazy-
expand-test.rkt:3:1 f>)
(#<syntax temp6>)
(#<syntax:C:\Program Files\Racket-Full-5.0.0.1\collects\lazy\lazy.rkt:326:50 p>
#<syntax temp6>)



Experiment: dump of annotate.rkt::top-level-rewrite labels for all variables

 - with test-proc:
#%app non-lexical test-proc non-lexical lambda non-lexical x lambda-bound #%app
non-lexical lazy non-lexical lambda non-lexical p let-bound temp1 let-bound x2 l
et-bound #%app non-lexical ! non-lexical + non-lexical quote non-lexical x lambd
a-bound if non-lexical if non-lexical #%app non-lexical lazy-proc? non-lexical p
 let-bound quote non-lexical #%app non-lexical struct-constructor-procedure? non
-lexical p let-bound #%app non-lexical p let-bound temp1 let-bound x2 let-bound
#%app non-lexical p let-bound #%app non-lexical ! non-lexical temp1 let-bound #%
app non-lexical ! non-lexical x2 let-bound 

 - with lazy-proc:
#%app non-lexical lazy-proc non-lexical lambda non-lexical x lambda-bound #%app
non-lexical lazy non-lexical lambda non-lexical p let-bound temp1 let-bound x2 l
et-bound #%app non-lexical ! non-lexical + non-lexical quote non-lexical x lambd
a-bound if non-lexical if non-lexical #%app non-lexical lazy-proc? non-lexical p
 let-bound quote non-lexical #%app non-lexical struct-constructor-procedure? non
-lexical p let-bound #%app non-lexical p let-bound temp1 let-bound x2 let-bound
#%app non-lexical p let-bound #%app non-lexical ! non-lexical temp1 let-bound #%
app non-lexical ! non-lexical x2 let-bound 








TODO for tomorrow:
 - dump stuff in annotate/inner #%plain-app case and make sure everything is same for test-proc and lazy-proc (I did this already for #%plain-lambda case)





Experiment: dump of terms, annotated terms, and free varrefs for #%plain-app case in annotate/inner (outpouts are identical)

- with lazy-proc:
terms:
(#<syntax:C:\Program Files\Racket-Full-5.0.0.1\collects\lazy\lazy.rkt:325:50 p>
#<syntax temp1> #<syntax x2>)
annotated terms:
(#<syntax (with-continuation-mark #<deb...> #<syntax (with-continuation-mark #<d
eb...> #<syntax (with-continuation-mark #<deb...>)
free varrefs
((#<syntax:C:\Program Files\Racket-Full-5.0.0.1\collects\lazy\lazy.rkt:325:50 p>
) (#<syntax temp1>) (#<syntax x2>))
terms:
(#<syntax:C:\Program Files\Racket-Full-5.0.0.1\collects\lazy\lazy.rkt:326:50 p>
#<syntax:C:\Program Files\Racket-Full-5.0.0.1\collects\lazy\lazy.rkt:295:42 (#%a
pp ! temp1)> #<syntax:C:\Program Files\Racket-Full-5.0.0.1\collects\lazy\lazy.rk
t:295:42 (#%app ! x2)>)
annotated terms:
(#<syntax (with-continuation-mark #<deb...> #<syntax (with-continuation-mark #<d
eb...> #<syntax (with-continuation-mark #<deb...>)
free varrefs
((#<syntax:C:\Program Files\Racket-Full-5.0.0.1\collects\lazy\lazy.rkt:326:50 p>
) (#<syntax temp1>) (#<syntax x2>))
terms:
(#<syntax lazy> #<syntax:C:\Program Files\Racket-Full-5.0.0.1\collects\lazy\lazy
.rkt:337:29 (lambda () (let-values (((p) ...>)
annotated terms:
(#<syntax (with-continuation-mark #<deb...> #<syntax (with-continuation-mark #<d
eb...>)
free varrefs
((#<syntax lazy>) (#<syntax:C:\Documents and Settings\Stephen Chang\My Documents
\plt\sandbox\lazy-expand-test.rkt:1:15 +> #<syntax:C:\Documents and Settings\Ste
phen Chang\My Documents\plt\sandbox\lazy-expand-test.rkt:1:19 x>))
terms:
(#<syntax:C:\Program Files\Racket-Full-5.0.0.1\collects\lazy\lazy.rkt:371:32 top
level-forcer>)
annotated terms:
(#<syntax (with-continuation-mark #<deb...>)
free varrefs
((#<syntax:C:\Program Files\Racket-Full-5.0.0.1\collects\lazy\lazy.rkt:371:32 to
plevel-forcer>))
terms:
(#<syntax:C:\Program Files\Racket-Full-5.0.0.1\collects\lazy\lazy.rkt:325:50 p>
#<syntax temp6>)
annotated terms:
(#<syntax (with-continuation-mark #<deb...> #<syntax (with-continuation-mark #<d
eb...>)
free varrefs
((#<syntax:C:\Program Files\Racket-Full-5.0.0.1\collects\lazy\lazy.rkt:325:50 p>
) (#<syntax temp6>))
terms:
(#<syntax:C:\Program Files\Racket-Full-5.0.0.1\collects\lazy\lazy.rkt:326:50 p>
#<syntax:C:\Program Files\Racket-Full-5.0.0.1\collects\lazy\lazy.rkt:295:42 (#%a
pp ! temp6)>)
annotated terms:
(#<syntax (with-continuation-mark #<deb...> #<syntax (with-continuation-mark #<d
eb...>)
free varrefs
((#<syntax:C:\Program Files\Racket-Full-5.0.0.1\collects\lazy\lazy.rkt:326:50 p>
) (#<syntax temp6>))
terms:
(#<syntax:C:\Program Files\Racket-Full-5.0.0.1\collects\lazy\lazy.rkt:371:31 (#%
app toplevel-forcer)> #<syntax:C:\Program Files\Racket-Full-5.0.0.1\collects\laz
y\lazy.rkt:335:29 (let-values (((p) (#%app ! (#...>)
annotated terms:
(#<syntax:C:\Program Files\Racket-Full-5.0.0.1\collects\stepper\private\annotate
.rkt:1085:27 (let-values (((arg0-1733) (#%...> #<syntax:C:\Program Files\Racket-
Full-5.0.0.1\collects\lazy\lazy.rkt:335:29 (let ((lifting-counter (#<pro...>)
free varrefs
((#<syntax:C:\Program Files\Racket-Full-5.0.0.1\collects\lazy\lazy.rkt:371:32 to
plevel-forcer>) (#<syntax:C:\Documents and Settings\Stephen Chang\My Documents\p
lt\sandbox\lazy-expand-test.rkt:3:1 f>))


- with test-proc
terms:
(#<syntax:C:\Program Files\Racket-Full-5.0.0.1\collects\lazy\lazy.rkt:325:50 p>
#<syntax temp1> #<syntax x2>)
annotated terms:
(#<syntax (with-continuation-mark #<deb...> #<syntax (with-continuation-mark #<d
eb...> #<syntax (with-continuation-mark #<deb...>)
free varrefs
((#<syntax:C:\Program Files\Racket-Full-5.0.0.1\collects\lazy\lazy.rkt:325:50 p>
) (#<syntax temp1>) (#<syntax x2>))
terms:
(#<syntax:C:\Program Files\Racket-Full-5.0.0.1\collects\lazy\lazy.rkt:326:50 p>
#<syntax:C:\Program Files\Racket-Full-5.0.0.1\collects\lazy\lazy.rkt:295:42 (#%a
pp ! temp1)> #<syntax:C:\Program Files\Racket-Full-5.0.0.1\collects\lazy\lazy.rk
t:295:42 (#%app ! x2)>)
annotated terms:
(#<syntax (with-continuation-mark #<deb...> #<syntax (with-continuation-mark #<d
eb...> #<syntax (with-continuation-mark #<deb...>)
free varrefs
((#<syntax:C:\Program Files\Racket-Full-5.0.0.1\collects\lazy\lazy.rkt:326:50 p>
) (#<syntax temp1>) (#<syntax x2>))
terms:
(#<syntax lazy> #<syntax:C:\Program Files\Racket-Full-5.0.0.1\collects\lazy\lazy
.rkt:337:29 (lambda () (let-values (((p) ...>)
annotated terms:
(#<syntax (with-continuation-mark #<deb...> #<syntax (with-continuation-mark #<d
eb...>)
free varrefs
((#<syntax lazy>) (#<syntax:C:\Documents and Settings\Stephen Chang\My Documents
\plt\sandbox\lazy-expand-test.rkt:1:15 +> #<syntax:C:\Documents and Settings\Ste
phen Chang\My Documents\plt\sandbox\lazy-expand-test.rkt:1:19 x>))
terms:
(#<syntax:C:\Program Files\Racket-Full-5.0.0.1\collects\lazy\lazy.rkt:371:32 top
level-forcer>)
annotated terms:
(#<syntax (with-continuation-mark #<deb...>)
free varrefs
((#<syntax:C:\Program Files\Racket-Full-5.0.0.1\collects\lazy\lazy.rkt:371:32 to
plevel-forcer>))
terms:
(#<syntax:C:\Program Files\Racket-Full-5.0.0.1\collects\lazy\lazy.rkt:325:50 p>
#<syntax temp6>)
annotated terms:
(#<syntax (with-continuation-mark #<deb...> #<syntax (with-continuation-mark #<d
eb...>)
free varrefs
((#<syntax:C:\Program Files\Racket-Full-5.0.0.1\collects\lazy\lazy.rkt:325:50 p>
) (#<syntax temp6>))
terms:
(#<syntax:C:\Program Files\Racket-Full-5.0.0.1\collects\lazy\lazy.rkt:326:50 p>
#<syntax:C:\Program Files\Racket-Full-5.0.0.1\collects\lazy\lazy.rkt:295:42 (#%a
pp ! temp6)>)
annotated terms:
(#<syntax (with-continuation-mark #<deb...> #<syntax (with-continuation-mark #<d
eb...>)
free varrefs
((#<syntax:C:\Program Files\Racket-Full-5.0.0.1\collects\lazy\lazy.rkt:326:50 p>
) (#<syntax temp6>))
terms:
(#<syntax:C:\Program Files\Racket-Full-5.0.0.1\collects\lazy\lazy.rkt:371:31 (#%
app toplevel-forcer)> #<syntax:C:\Program Files\Racket-Full-5.0.0.1\collects\laz
y\lazy.rkt:335:29 (let-values (((p) (#%app ! (#...>)
annotated terms:
(#<syntax:C:\Program Files\Racket-Full-5.0.0.1\collects\stepper\private\annotate
.rkt:1085:27 (let-values (((arg0-1733) (#%...> #<syntax:C:\Program Files\Racket-
Full-5.0.0.1\collects\lazy\lazy.rkt:335:29 (let ((lifting-counter (#<pro...>)
free varrefs
((#<syntax:C:\Program Files\Racket-Full-5.0.0.1\collects\lazy\lazy.rkt:371:32 to
plevel-forcer>) (#<syntax:C:\Documents and Settings\Stephen Chang\My Documents\p
lt\sandbox\lazy-expand-test.rkt:3:1 f>))



Experiment: dump of tail-args in #%plain-app case of annotate/inner (identical)

- using test-proc
all
all
all
(#<syntax arg0-1733>)
(#<syntax:C:\Program Files\Racket-Full-5.0.0.1\collects\lazy\lazy.rkt:329:22 p>
#<syntax temp6> #<syntax arg0-1733> #<syntax arg1-1734>)
(#<syntax:C:\Program Files\Racket-Full-5.0.0.1\collects\lazy\lazy.rkt:329:22 p>
#<syntax temp6> #<syntax arg0-1733> #<syntax arg1-1734>)
all

- using lazy-proc
all
all
all
(#<syntax arg0-1733>)
(#<syntax:C:\Program Files\Racket-Full-5.0.0.1\collects\lazy\lazy.rkt:329:22 p>
#<syntax temp6> #<syntax arg0-1733> #<syntax arg1-1734>)
(#<syntax:C:\Program Files\Racket-Full-5.0.0.1\collects\lazy\lazy.rkt:329:22 p>
#<syntax temp6> #<syntax arg0-1733> #<syntax arg1-1734>)
all



Tentative conclusion - annotated programs are the same whether using lazy-proc or test-proc; reconstruction seems different though

TODO: find where reconstruction differs



reconstruction call graph


files in stepper/private

model.rkt::go::break

     |
     V

reconstruct.rkt::
reconstruct-left-side (normal-break, normal-break/values)
reconstruct-right-side (result-exp-break, result-value-break)
reconstruct-double-break (double-break)

     |
     V

reconstruct-current


     |
     V

(left-side)
recon-value
reconstruct-current::recon

(right-side)
recon-value or recon-source-expr
reconstruct-current::recon

(double-break)
recon-source-expr
reconstruct-current::recon

     |
     V

reconstruct-current::recon calls either
  reconstruct-top-level or
  reconstruct-current::recon-inner

Structure of stepper/private/reconstruct.rkt

recon-value
skip-step?
skip-redex-step?
recon-source-expr
- calls skipto/auto with 'discard and the following transformer fn
    recur
    let-recur
    recon-basic
    recon-let/rec
    recon-lambda-clause
    kernel-syntax-case
        (#%plain-lambda . clause-stx)
        (case-lambda . clauses-stx)
        (if test then else)
        (it test then)
        (begin . bodies)
        (begin0 . bodies)
        (let-values . rest)
        (letrec-values . rest)
        (set! var rhs)
        (quote body)
        (with-continuation-mark . rest)
        (#%plain-app . terms)
        var-stx
        (#%top . var)
reconstruct-completed
reconstruct-top-level
reconstruct-left-side
reconstruct-right-side
reconstruct-double-break
reconstruct-current
    recon-inner
        recon-source-current-marks
        iota
        recon-let
        kernel-syntax-case
            id
            (#%top . id)
            (#%plain-app . terms)
            (if test then else)
            (if test then)
            (begin . terms)
            (begin0 body)
            (begin0 first-body . rest-bodies)
            (let-values . rest)
            (letrec-values . rest)
            (set! var rhs)
    recon



Experiment: dumping closure-records in recon-value in reconstruct.rkt

 - using lazy-proc
 - using test-proc
 - everything seems to be a closure-record (no #f's)

Experiment: dumping base-names of closure-records in recon-value in reconstruct.rkt
 - weird, nothing printed from the true branch of if closure-records, even though in the previous experiment, everythings was showing as a closure-record
 - trying to print something in the false branch of if closure-records (the rendered)
    - it seems like where test-proc has 1, lazy-proc has lazy.rkt:206:19 (which is the start of the (lambda ...) expr

the false branch, for lazy-proc:

...ts\lazy\lazy.rkt:206:19
parameter-procedure
10
...ts\lazy\lazy.rkt:206:19
force
10
...ts\lazy\lazy.rkt:206:19
...ts\lazy\lazy.rkt:206:19
...ts\lazy\lazy.rkt:206:19
10
force
...ts\lazy\lazy.rkt:206:19
...ts\lazy\lazy.rkt:206:19
10
...ts\lazy\lazy.rkt:206:19
force
10
...ts\lazy\lazy.rkt:206:19
...ts\lazy\lazy.rkt:206:19
10
...ts\lazy\lazy.rkt:206:19
force
...ts\lazy\lazy.rkt:206:19
...ts\lazy\lazy.rkt:206:19
10
10
...ts\lazy\lazy.rkt:206:19
force
...ts\lazy\lazy.rkt:206:19
...ts\lazy\lazy.rkt:206:19
10
...ts\lazy\lazy.rkt:206:19
10
force
...ts\lazy\lazy.rkt:206:19
...ts\lazy\lazy.rkt:206:19
10
1
10
...ts\lazy\lazy.rkt:206:19
10
force
...ts\lazy\lazy.rkt:206:19
...ts\lazy\lazy.rkt:206:19
10
(delay ...)
force
+
...ts\lazy\lazy.rkt:206:19
...ts\lazy\lazy.rkt:206:19
10
+
1
10
force
(delay ...)
...ts\lazy\lazy.rkt:206:19
...ts\lazy\lazy.rkt:206:19
10
+
1
10
+
force
(delay ...)
1
...ts\lazy\lazy.rkt:206:19
...ts\lazy\lazy.rkt:206:19
10
+
1
10
+
force
(delay ...)
...ts\lazy\lazy.rkt:206:19
...ts\lazy\lazy.rkt:206:19
10
+
1
10
1
+
force
(delay ...)
10
...ts\lazy\lazy.rkt:206:19
...ts\lazy\lazy.rkt:206:19
10
+
1
10
+
1
force
(delay ...)
...ts\lazy\lazy.rkt:206:19
...ts\lazy\lazy.rkt:206:19
10
+
1
10
10
+
1
force
(delay ...)
...ts\lazy\lazy.rkt:206:19
...ts\lazy\lazy.rkt:206:19
10
+
1
10
+
1
10
force
(delay ...)
...ts\lazy\lazy.rkt:206:19
...ts\lazy\lazy.rkt:206:19
10
+
1
10
11
force
(delay ...)
...ts\lazy\lazy.rkt:206:19
...ts\lazy\lazy.rkt:206:19
10
+
1
10
11

the false branch of if closure-record in recon-value, for test-proc

1
parameter-procedure
10
1
force
10
1
1
1
10
force
1
1
10
1
force
10
1
1
10
1
force
1
1
10
10
1
force
1
1
10
1
10
force
1
1
10
1
10
force
+
1
1
10
+
1
10
force
(delay ...)
1
1
10
+
1
10
+
force
(delay ...)
1
1
1
10
+
1
10
+
force
(delay ...)
1
1
10
+
1
10
1
+
force
(delay ...)
10
1
1
10
+
1
10
+
1
force
(delay ...)
1
1
10
+
1
10
10
+
1
force
(delay ...)
1
1
10
+
1
10
+
1
10
force
(delay ...)
1
1
10
+
1
10
11
force
(delay ...)
1
1
10
+
1
10
11



Continuation Marks creation call graph:

stepper/private/marks.rkt::

make-debug-info

     |
     V

make-full-mark


     |
     V

make-make-full-mark-varargs

     |
     V

make-full-mark-struct
(define-struct full-mark-struct (source label bindings values))


--------------------------------------------------------------------------------
----- 7/2/2010 - LAPTOP
--------------------------------------------------------------------------------

Experiment: all keys added to closure table

- using lazy-proc:
#<procedure:...ts\lazy\lazy.rkt:207:19>
#<procedure:...ts\lazy\lazy.rkt:339:29>

- using test-proc
#<procedure:...ts\lazy\lazy.rkt:207:19>
#<procedure:...ts\lazy\lazy.rkt:339:29>




lookup-binding call graph:

stepper/private/

reconstruct.rkt::(various functions)

     |
     V

marks.rkt::

lookup-binding.rkt

     |
     V

lookup-first-binding

     |
     V

lookup-all-bindings
(for all marks, returns list of binding-value pairs where binding matches specified binding)
     |
     V

binding-matches
(for one mark, returns list of binding-value pairs where binding matches specified binding)
     |
     V

mark-bindings
(returns list of binding-value pairs)
     |
     V

full-mark-struct-bindings
full-mark-struct-values	



--------------------------------------------------------------------------------
----- 7/3/2010 - LAPTOP
--------------------------------------------------------------------------------


Call Graph - making a mark:

stepper/private/annotate.rkt::annotate:annotate/inner::
make-debug-info-normal (called by normal-bundle, if-abstraction, varref-abstraction, annotate/inner)
make-debug-info-app (outer-lambda-abstraction, annotate/inner)
make-debug-info-let (let-abstraction)
make-debug-info-fake-exp (let-abstraction)
make-debug-info-fake-exp/tail-bound (annotate/inner

     |
     V

stepper/private/marks.rkt::

make-debug-info
  source tail-bound free-vars label lifting

     |
     V

make-full-mark
  source label bindings
(creates syntax of a thunk where body is app:
   ( (make-make-full-mark-varargs source label bindings) 
     (map make-mark-binding-stx bindings) )

     | (when thunk is forced)           |
     V                                  V

make-make-full-mark-varargs      make-mark-binding-stx
  source label bindings
     |
     V

make-full-mark-struct
  source label bindings values
  (values is arg of lambda)



- lambda and lambda wrapped with lazy-proc print as the same!
  (see lazy-proc-print-test.rkt)

- if I apply the following fn to val before giving it to closure-table-lookup (this is in recon-value in reconstruct.rkt), then the function displays properly!

(lambda (val) 
    (if (procedure? val)
        (let ([targ (procedure-extract-target val)])
            (if targ
                targ
                val))
        val))