--------------------------------------------------------------------------------
----- 6/24/2010 - HOME PC
--------------------------------------------------------------------------------

- dl and install Racket Full 6/24/2010 nightly build
- copied over lazy/info.rkt and lazy/lazy-tool.rkt so stepper button would show up (must run setup-plt to register changes (use -D option, it's doesnt build docs so it's quicker)

Tried to step test program:
(define (f x) (+ 1 x))
(f 10)

Error Message:
annotate/top-level: unexpected top-level expression: (define-values (f) (#%app lazy-proc (lambda (x) (#%app lazy (lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2)))))))))

Solution:
A cond clause seems to have been removed from annotate/top-level in stepper/private/annotate.rkt (it's there on the version in my laptop)

Added clause: [(define-values (ids ...) bodies) (annotate/module-top-level exp)]



Error Message:
Internal stepper error: time to resync with simple-module-based-language-convert-value

Solution:
cond clause missing in simple-module-based-language-convert-value in stepper/stepper-tool.rkt

Added clause: [(print) value]

(TODO: eventually, I want Lazy Racket to use the 'constructor print style as default, but I havent been able to figure out how to do that yet)


- It works!

Output: 
(define f
  #(struct:lazy-proc
    #<procedure:...ate\annotate.rkt:809:52>))
((#<procedure:parameter-procedure>)
 (let ((p f) (temp6 10))
   (if (if (lazy-proc? p)
         #t
         (struct-constructor-procedure?
          p))
     (p temp6)
     (p temp6))))


- changed print style to 'constructor

Output:
(define f
  |...ate\annotate.rkt:809:52|)
((parameter-procedure)
 (let ((p f) (temp6 10))
   (if (if (lazy-proc? p)
         true
         (struct-constructor-procedure?
          p))
     (p temp6)
     (p temp6))))


- uncommented stepper-skipto annotation in !*app in lazy/lazy.rkt

Output:
(define f
  |...ts\lazy\lazy.rkt:124:48|)
((parameter-procedure)
 (let ((p f) (temp6 10))
   (p temp6)))


- trying to wrap output of ~!%app in lazy/lazy.rkt with stepper-annotate function
 - wrapped around (toplevel?) clause, got error: 
#%plain-app: bad syntax in: (#%plain-app (#%plain-app parameter-procedure) (let-values (((p) f) ((temp6) (quote 10))) (#%app p temp6)))

 - wrapped around else clause, no effect - same as if stepper-annotate wasnt used


Experiment:
- added a test clause in unwinder in ~!%app in lazy/lazy.rkt to see if unwinder gets called - it worked (error gets raised)
test clause: [_ (raise-syntax-error 'hi "testing...")]

- moved test clause to be last clause in unwinder to see if first clause matches - error gets raised again, which means first clause didnt get matched


Experiment:
- trying to move stepper-annotate to !*app in lazy/lazy.rkt - applied stepper-annotate to quasisyntax/loc expr - pattern in unwinder still not matched
- if I remove the raise-syntax-error clause, the error is:
let-values: bad syntax in: (let-values (((p) f) ((temp6) (quote 10))) (#%app p temp6))

Experiment:
- trying to change the pattern in unwinder to match the expression I'm working with (removed stepper-skip-double-break property for now):
(define (unwinder stx rec)
      (syntax-case stx (!)
        [(let-values ([(_p) f] [(_y) x] ...) _body)
         (with-syntax ([(f x ...) (rec #'(f x ...))])
           #'(f x ...))]))

It worked! Output:
(define f
  |...ts\lazy\lazy.rkt:124:48|)
((parameter-procedure) (f 10))
->
(define f
  |...ts\lazy\lazy.rkt:124:48|)
(force (f 10))
->
(define f
  |...ts\lazy\lazy.rkt:124:48|)
(define p_0 f)
(define temp6_0 10)
(force (p_0 temp6_0))
->
(define f
  |...ts\lazy\lazy.rkt:124:48|)
(define p_0
  |...ts\lazy\lazy.rkt:124:48|)
(define temp6_0 10)
(force
 (|...ts\lazy\lazy.rkt:124:48|
  temp6_0))
->
(define f
  |...ts\lazy\lazy.rkt:124:48|)
(define p_0
  |...ts\lazy\lazy.rkt:124:48|)
(define temp6_0 10)
(force
 (|...ts\lazy\lazy.rkt:124:48|
  10))
->
(define f
  |...ts\lazy\lazy.rkt:124:48|)
(define p_0
  |...ts\lazy\lazy.rkt:124:48|)
(define temp6_0 10)
(force
 (...
  (lazy (lambda () (+ 1 10)))
  ...))
->
(define f
  |...ts\lazy\lazy.rkt:124:48|)
(define p_0
  |...ts\lazy\lazy.rkt:124:48|)
(define temp6_0 10)
(force (delay ...))
->
(define f
  |...ts\lazy\lazy.rkt:124:48|)
(define p_0
  |...ts\lazy\lazy.rkt:124:48|)
(define temp6_0 10)
(define p_0 +)
(define temp1_0 1)
(define x2_0 10)
(... (p_0 temp1_0 x2_0) ...)

(13 steps total)



- adding back stepper-skip-double-break property

Output:
(define f
  |...ts\lazy\lazy.rkt:124:48|)
((parameter-procedure) (f 10))
->
(define f
  |...ts\lazy\lazy.rkt:124:48|)
(force (f 10))
->
(define f
  |...ts\lazy\lazy.rkt:124:48|)
(define p_0
  |...ts\lazy\lazy.rkt:124:48|)
(define temp6_0 10)
(force
 (|...ts\lazy\lazy.rkt:124:48|
  temp6_0))
->
(define f
  |...ts\lazy\lazy.rkt:124:48|)
(define p_0
  |...ts\lazy\lazy.rkt:124:48|)
(define temp6_0 10)
(force
 (|...ts\lazy\lazy.rkt:124:48|
  10))

(11 steps total)


TODO tomorrow:
1) read stepper internal docs more carefully
2) reread lazy code and lazy srfi docs


--------------------------------------------------------------------------------
----- 6/25/2010 - HOME PC
--------------------------------------------------------------------------------

- Functions defined with define (ie - (define (f x) (+ x 1)) ) in the Beginner languages are displayed the same way in the Stepper regardless of whether the Output Style in the Choose Language menu is 'constructor or 'quasiquote or 'write

- extended lazy language class (which implements module-based-language<%> - in drracket/private/language.rkt) and overrode default-settings and default-settings? methods so that the default print-style was 'constructor
 - ran setup-plt and stepper prints functions as lambdas with Lazy Racket
 - I tried experimenting with the pretty-print-depth parameter (#f = all depths printed, instead of "...") previously to show the entire lambda but was not successful

Weird behavior:
- when I change something in lazy.rkt and restart DrRacket, fns in the stepper display as line numbers -- (define f |...ts\lazy\lazy.rkt:131:25|) -- but when I re-run setup-plt (both with undoing and not undoing the changes), fns go back to being displayed as lambdas

observation:
- There are two ways to add a property to some syntax (or other similar operations) (is this true?)
 1) use with-syntax
 2) use quasisyntax and escape when calling stepper-syntax-property, etc


Trying to get fns defined with define (and not using lambda) to display properly in stepper:

Experiment: 
- trying to use stepper-define-type stepper-syntax property to do it (Beginner languages use this property)

- doesnt seem to be working
- it works! if I remove the lazy-proc wrapping the lambda (so if I use just lambda instead of ~lambda)

Possible solutions:
1) add case in unwind-define in stepper/private/macro-unwind.rkt for functions that use ~lambda
2) add custom unwinder using stepper-hint like in !*app in lazy/lazy.rkt

TODO tomorrow:
1) finish implementing displaying of fns defined with define (see possible solutions above)