--------------------------------------------------------------------------------
----- 6/24/2010 - HOME PC
--------------------------------------------------------------------------------

- dl and install Racket Full 6/24/2010 nightly build
- copied over lazy/info.rkt and lazy/lazy-tool.rkt so stepper button would show up (must run setup-plt to register changes (use -D option, it's doesnt build docs so it's quicker))

Tried to step test program:
(define (f x) (+ 1 x))
(f 10)

Error Message:
annotate/top-level: unexpected top-level expression: (define-values (f) (#%app lazy-proc (lambda (x) (#%app lazy (lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2)))))))))

Solution:
A cond clause seems to have been removed from annotate/top-level in stepper/private/annotate.rkt (it's there on the version in my laptop)
 - no, this was added by me

Added clause: [(define-values (ids ...) bodies) (annotate/module-top-level exp)]



Error Message:
Internal stepper error: time to resync with simple-module-based-language-convert-value

Solution:
cond clause missing in simple-module-based-language-convert-value in stepper/stepper-tool.rkt

Added clause: [(print) value]

(TODO: eventually, I want Lazy Racket to use the 'constructor print style as default, but I havent been able to figure out how to do that yet)


- It works!

Output: 
(define f
  #(struct:lazy-proc
    #<procedure:...ate\annotate.rkt:809:52>))
((#<procedure:parameter-procedure>)
 (let ((p f) (temp6 10))
   (if (if (lazy-proc? p)
         #t
         (struct-constructor-procedure?
          p))
     (p temp6)
     (p temp6))))


- changed print style to 'constructor

Output:
(define f
  |...ate\annotate.rkt:809:52|)
((parameter-procedure)
 (let ((p f) (temp6 10))
   (if (if (lazy-proc? p)
         true
         (struct-constructor-procedure?
          p))
     (p temp6)
     (p temp6))))


- uncommented stepper-skipto annotation in !*app in lazy/lazy.rkt

Output:
(define f
  |...ts\lazy\lazy.rkt:124:48|)
((parameter-procedure)
 (let ((p f) (temp6 10))
   (p temp6)))


- trying to wrap output of ~!%app in lazy/lazy.rkt with stepper-annotate function
 - wrapped around (toplevel?) clause, got error: 
#%plain-app: bad syntax in: (#%plain-app (#%plain-app parameter-procedure) (let-values (((p) f) ((temp6) (quote 10))) (#%app p temp6)))

 - wrapped around else clause, no effect - same as if stepper-annotate wasnt used


Experiment:
- added a test clause in unwinder in ~!%app in lazy/lazy.rkt to see if unwinder gets called - it worked (error gets raised)
test clause: [_ (raise-syntax-error 'hi "testing...")]

- moved test clause to be last clause in unwinder to see if first clause matches - error gets raised again, which means first clause didnt get matched


Experiment:
- trying to move stepper-annotate to !*app in lazy/lazy.rkt - applied stepper-annotate to quasisyntax/loc expr - pattern in unwinder still not matched
- if I remove the raise-syntax-error clause, the error is:
let-values: bad syntax in: (let-values (((p) f) ((temp6) (quote 10))) (#%app p temp6))

Experiment:
- trying to change the pattern in unwinder to match the expression I'm working with (removed stepper-skip-double-break property for now):
(define (unwinder stx rec)
      (syntax-case stx (!)
        [(let-values ([(_p) f] [(_y) x] ...) _body)
         (with-syntax ([(f x ...) (rec #'(f x ...))])
           #'(f x ...))]))

It worked! Output:
(define f
  |...ts\lazy\lazy.rkt:124:48|)
((parameter-procedure) (f 10))
->
(define f
  |...ts\lazy\lazy.rkt:124:48|)
(force (f 10))
->
(define f
  |...ts\lazy\lazy.rkt:124:48|)
(define p_0 f)
(define temp6_0 10)
(force (p_0 temp6_0))
->
(define f
  |...ts\lazy\lazy.rkt:124:48|)
(define p_0
  |...ts\lazy\lazy.rkt:124:48|)
(define temp6_0 10)
(force
 (|...ts\lazy\lazy.rkt:124:48|
  temp6_0))
->
(define f
  |...ts\lazy\lazy.rkt:124:48|)
(define p_0
  |...ts\lazy\lazy.rkt:124:48|)
(define temp6_0 10)
(force
 (|...ts\lazy\lazy.rkt:124:48|
  10))
->
(define f
  |...ts\lazy\lazy.rkt:124:48|)
(define p_0
  |...ts\lazy\lazy.rkt:124:48|)
(define temp6_0 10)
(force
 (...
  (lazy (lambda () (+ 1 10)))
  ...))
->
(define f
  |...ts\lazy\lazy.rkt:124:48|)
(define p_0
  |...ts\lazy\lazy.rkt:124:48|)
(define temp6_0 10)
(force (delay ...))
->
(define f
  |...ts\lazy\lazy.rkt:124:48|)
(define p_0
  |...ts\lazy\lazy.rkt:124:48|)
(define temp6_0 10)
(define p_0 +)
(define temp1_0 1)
(define x2_0 10)
(... (p_0 temp1_0 x2_0) ...)

(13 steps total)



- adding back stepper-skip-double-break property

Output:
(define f
  |...ts\lazy\lazy.rkt:124:48|)
((parameter-procedure) (f 10))
->
(define f
  |...ts\lazy\lazy.rkt:124:48|)
(force (f 10))
->
(define f
  |...ts\lazy\lazy.rkt:124:48|)
(define p_0
  |...ts\lazy\lazy.rkt:124:48|)
(define temp6_0 10)
(force
 (|...ts\lazy\lazy.rkt:124:48|
  temp6_0))
->
(define f
  |...ts\lazy\lazy.rkt:124:48|)
(define p_0
  |...ts\lazy\lazy.rkt:124:48|)
(define temp6_0 10)
(force
 (|...ts\lazy\lazy.rkt:124:48|
  10))

(11 steps total)


TODO tomorrow:
1) read stepper internal docs more carefully
2) reread lazy code and lazy srfi docs


--------------------------------------------------------------------------------
----- 6/25/2010 - HOME PC
--------------------------------------------------------------------------------

- Functions defined with define (ie - (define (f x) (+ x 1)) ) in the Beginner languages are displayed the same way in the Stepper regardless of whether the Output Style in the Choose Language menu is 'constructor or 'quasiquote or 'write

- extended lazy language class (which implements module-based-language<%> - in drracket/private/language.rkt) and overrode default-settings and default-settings? methods so that the default print-style was 'constructor
 - ran setup-plt and stepper prints functions as lambdas with Lazy Racket
 - I tried experimenting with the pretty-print-depth parameter (#f = all depths printed, instead of "...") previously to show the entire lambda but was not successful

Weird behavior:
- when I change something in lazy.rkt and restart DrRacket, fns in the stepper display as line numbers -- (define f |...ts\lazy\lazy.rkt:131:25|) -- but when I re-run setup-plt (both with undoing and not undoing the changes), fns go back to being displayed as lambdas
  - yes this makes sense, because the source of the syntax is in the changed file so you need to recompile to make them show up properly

observation:
- There are two ways to add a property to some syntax (or other similar operations) (is this true?)
 1) use with-syntax
 2) use quasisyntax and escape when calling stepper-syntax-property, etc


Trying to get fns defined with define (and not using lambda) to display properly in stepper:

Experiment: 
- trying to use stepper-define-type stepper-syntax property to do it (Beginner languages use this property)

- doesnt seem to be working
- it works! if I remove the lazy-proc wrapping the lambda (so if I use just lambda instead of ~lambda)

Possible solutions:
1) add case in unwind-define in stepper/private/macro-unwind.rkt for functions that use ~lambda
2) add custom unwinder using stepper-hint like in !*app in lazy/lazy.rkt

TODO tomorrow:
1) finish implementing displaying of fns defined with define (see possible solutions above)

--------------------------------------------------------------------------------
----- 6/28/2010 - LAPTOP
--------------------------------------------------------------------------------

- module-identifier=? in mzscheme is the same as free-identifier=? in racket/base


--------------------------------------------------------------------------------
----- 6/29/2010 - LAPTOP
--------------------------------------------------------------------------------

- somehow, when using the custom unwinder, the body of the lambda gets quoted, but when using unwind-define in stepper/private/macro-unwind.rkt, there is no quote, even though both functions are the same and get they get the same inputs - THIS ISNT QUITE RIGHT, see below
  - finally figured it out! The custom unwinder was using recur-on-pieces (as specified in unwind in stepper/private/macro-unwind.rkt) to recursively unwind the body of the function but unwind-define was using unwind as the recursive call
    - I changed the recursive call in unwind in stepper/private/macro-unwind.rkt to use unwind instead of recur-on-pieces

- the recur-on-pieces doesnt add the quote, it just doesnt get rid of it. the unwind fn has a syntax-case clause in fall-through that gets rid of the quote; I still dont know why adding lazy-proc adds a quote
  - it seems like something funny is happening during annotation of lazy-proc - probably because it's a struct constructor and not a real function, so that the stepper doesnt quite know how to reconstruct it, and so that's why we get the funny results with the quote and the dots
  something like (lazy-proc (lambda (x) (+ 1 x))) is getting annotated and reconstructed as (quote (lambda (a1) ...)) where the quote and the dots are part of the actual output

- the 'stepper-define-type stepper-syntax-property seems to be lost when I add lazy-proc around the lambda


Call Graph: stepper/private/macro-unwind.rkt::unwind

stepper/private/model.rkt
  break:reconstruct-all-completed
  break (not skip-step, normal-break, normal-break/values)
    - applied to results of reconstruct.rkt::reconstruct-left-side
  break (not skip-step, result-exp-break, result-value-break)
    - applied to results of reconstruct.rkt::reconstruct-right-side
  break (not skip-step, double-break)
    - applied to results of reconstruct.rkt::reconstruct-double-break

          |
          V

stepper/private/macro-unwind.rkt::unwind



Call Graph: stepper/private/reconstruct.rkt::reconstruct-current

stepper/private/reconstruct.rkt
  reconstruct-left-side
  reconstruct-right-side
  reconstruct-double-break

          |
          V

stepper/private/reconstruct.rkt::reconstruct-current


- trying now to just use stepper-skipto to skip the lazy-proc application
  - the 'stepper-define-type stepper-syntax-property still seems to be lost when I add lazy-proc around 
    - trying to add the stepper-define-type property around the lazy-proc instead of around the lambda (and hopefully it gets transferred over?)the lambda
      - didnt work


TODO tomorrow:
 - look at stepper/private/reconstruct.rkt::recon-value
   - this is the function that inserts the quote
     1) it's because stepper/private/shared.rkt::closure-table-lookup returns #f
     2) also, the dots comes from render-settings-render-to-sexp, I think?
       - look in stepper/stepper-tool.rkt at stepper:render-to-sexp and simple-module-based-language-convert-value
 - check stepper/private/annotate.rkt::top-level-rewrite to see what kind of label lazy-proc gets (ie - macro-bound, non-lexical, etc)
   - print out stepper-binding-type given by top-level-rewrite for each var case
     - lazy-proc is 'non-lexical
   - labels are used in var (used in varref-abstraction in annotate::annotate/inner



--------------------------------------------------------------------------------
----- 6/30/2010 - LAPTOP
--------------------------------------------------------------------------------

 - stepper/private/annotate.rkt::return-value-wrap - calls return-value-wrap-maker - adds specified breakpoint and deals with multiple values
 - stepper/private/annotate.rkt::break-wrap adds a normal-break
 - annotate/inner::wcm-break-wrap adds a break-wrap to the expr before calling outer-wcm-wrap
 - annotate.rkt::wcm-pre-break-wrap adds pre-break-wrap to expr before calling wcm-wrap (pre-break-app adds result-exp-break)
 - stepper/private/marks.rkt::wcm-wrap makes the standard call to wcm with key 'debug-key

Annotating vars:
 - if var is not lexical but is from current module, add a break; otherwise, dont add a break


Experiment: see what happens if lambdas in lazy racket are wrapped with regular function (defined in module, ie - in lazy.rkt)

1) wrap with fn (define (test-proc x) x) defined in lazy.rkt
 - most things worked
   - using stepper-skipto (append skipto/cdr skipto/second)
   - using kernal-syntax-case* with literal #%app and pattern (#%app xx body) for function body, xx gets bound to 'test-proc
   - works when test-proc is in another file that is required


Experiment: what happens in annotate.rkt::varref-abstraction for various vars
  - interesting, neither test-proc nor f shows up as a parameter to varref-abstraction
    - dump: lazy private/promise.rkt + (quote #%kernel) toplevel-forcer (lib lazy/lazy.rkt)
  - dump is the same when test-proc is replaced with lazy-proc


Experiment: dumping all the exprs that get annotated by stepper/private/annotate.rkt::annotate::annotate/inner (using stepper-skipto for lazy-proc/test-proc)

- when using lazy-proc:
(#%app lazy-proc (lambda (x) (#%app lazy (lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2))))))))

(lambda (x) (#%app lazy (lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2)))))))


(#%app lazy (lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2))))))

lazy

(lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2)))))

(let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2))))

(#%app ! +)
+
(quote 1)
x
(if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2)))
(#%app p temp1 x2)
p
temp1
x2
(#%app p (#%app ! temp1) (#%app ! x2))
p
(#%app ! temp1)
temp1
(#%app ! x2)
x2
(#%app (#%app toplevel-forcer) (let-values (((p) (#%app ! (#%top . f))) ((temp6) (quote 10))) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp6) (#%app p (#%app ! temp6)))))
(#%app toplevel-forcer)
toplevel-forcer
(let-values (((p) (#%app ! (#%top . f))) ((temp6) (quote 10))) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp6)
(#%app p (#%app ! temp6))))
(#%app ! (#%top . f))
(#%top . f)
(quote 10)
(if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp6) (#%app p (#%app ! temp6)))
(#%app p temp6)
p
temp6
(#%app p (#%app ! temp6))
p
(#%app ! temp6)
temp6


when using test-proc (seems to be identical to lazy-proc)

(#%app test-proc (lambda (x) (#%app lazy (lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2))))))))

(lambda (x) (#%app lazy (lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2)))))))

(#%app lazy (lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2))))))

lazy

(lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%appp temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2)))))

(let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2))))

(#%app ! +)
+
(quote 1)
x
(if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2)))
(#%app p temp1 x2)
p
temp1
x2
(#%app p (#%app ! temp1) (#%app ! x2))
p
(#%app ! temp1)
temp1
(#%app ! x2)
x2
(#%app (#%app toplevel-forcer) (let-values (((p) (#%app ! (#%top . f))) ((temp6) (quote 10))) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp6) (#%app p (#%app ! temp6)))))
(#%app toplevel-forcer)
toplevel-forcer
(let-values (((p) (#%app ! (#%top . f))) ((temp6) (quote 10))) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp6) (#%app p (#%app ! temp6))))
(#%app ! (#%top . f))
(#%top . f)
(quote 10)
(if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp6) (#%app p (#%app ! temp6)))
(#%app p temp6)
p
temp6
(#%app p (#%app ! temp6))
p
(#%app ! temp6)
temp6


Experiment: dump of all exprs that get annotated by annotate.rkt:annotate (for my test file that uses lazy racket: (define (f x) (+ x 1)) (f 10)     )

- using lazy-proc

(define-values (f) (#%app lazy-proc (lambda (x) (#%app lazy (lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2)))))))))

(#%app (#%app toplevel-forcer) (let-values (((p) (#%app ! (#%top . f))) ((temp6) (quote 10))) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp6) (#%app p (#%app ! temp6)))))


- using test-proc (seems the same as for lazy-proc except using test-proc)

(define-values (f) (#%app test-proc (lambda (x) (#%app lazy (lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2)))))))))

(#%app (#%app toplevel-forcer) (let-values (((p) (#%app ! (#%top . f))) ((temp6) (quote 10))) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp6) (#%app p (#%app ! temp6)))))





Call graph for annotation of lazy racket (define (f x) (+ x 1))


stepper/private/model.rkt:

go
     |
     V

go::step-through-expression
(annotate break parameter is break fn in model.rkt)
(annotated expr is then eval'ed)

     |
     V

in stepper/private/annotate.rkt:

annotate
(break parameter is break fn in model.rkt)
     |
     V

annotate::annotate/top-level #'(define-values (f) (#%app lazy-proc (lambda (x) (+ x 1))))

     |
     V

annotate::annotate/module-top-level #'(define-values (f) (#%app lazy-proc (lambda (x) (+ x 1))))

     |
     V

annotate::top-level-annotate/inner #'(#%app lazy-proc (lambda (x) (+ x 1)))

     |
     V

annotate::annotate/inner #'(#%app lazy-proc (lambda (x) (+ x 1)))



- displaying syntax->datum of top-level-rewrites for my test code seems to produce no change
  - yes of course this is true, top-level-rewrites only applies stepper-binding-type labels and other stepper-properties





Experiment: dump of exprs given to annotate/inner and the results

----- deleted -----



Experiment: dumping exprs given to annotate/inner, along with associated stepper-properties


- using lazy-proc


(#%app lazy-proc (lambda (x) (#%app lazy (lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2))))))))

((stepper-skipto (syntax-e cdr syntax-e cdr car)))

(lambda (x) (#%app lazy (lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2)))))))

((stepper-proc-define-name #<syntax:C:\Documents and Settings\Stephen Chang\My Documents\plt\sandbox\lazy-expand-test.rkt:1:9 f>) (stepper-define-type shortened
-proc-define))

(#%app lazy (lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2))))))

#f

lazy

((stepper-binding-type non-lexical))

(lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2)))))

#f

(let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2))))

((stepper-skip-double-break #t) (stepper-hint #<procedure:unwinder>))

(#%app ! +)

((stepper-skipto (syntax-e cdr syntax-e cdr car)))

+

((stepper-binding-type non-lexical))

(quote 1)
#f
x
((stepper-binding-type lambda-bound))
(if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2)))

(((stepper-skipto (syntax-e cdr cdr both-l () (car)))) (stepper-skipto (syntax-e cdr cdr both-l () (car))))

(#%app p temp1 x2)
#f
p
((stepper-binding-type let-bound))
temp1
((stepper-binding-type let-bound))
x2
((stepper-binding-type let-bound))
(#%app p (#%app ! temp1) (#%app ! x2))
#f
p
((stepper-binding-type let-bound))
(#%app ! temp1)
((stepper-skipto (syntax-e cdr syntax-e cdr car)))
temp1
((stepper-binding-type let-bound))
(#%app ! x2)
((stepper-skipto (syntax-e cdr syntax-e cdr car)))
x2
((stepper-binding-type let-bound))
(#%app (#%app toplevel-forcer) (let-values (((p) (#%app ! (#%top . f))) ((temp6) (quote 10))) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp6) (#%app p (#%app ! temp6)))))
#f
(#%app toplevel-forcer)
#f
toplevel-forcer
((stepper-binding-type non-lexical))
(let-values (((p) (#%app ! (#%top . f))) ((temp6) (quote 10))) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp6) (#%app p (#%app ! temp6))))
((stepper-skip-double-break #t) (stepper-hint #<procedure:unwinder>))
(#%app ! (#%top . f))
((stepper-skipto (syntax-e cdr syntax-e cdr car)))
(#%top . f)
#f
(quote 10)
#f
(if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp6) (#%app p (#%app ! temp6)))
(((stepper-skipto (syntax-e cdr cdr both-l () (car)))) (stepper-skipto (syntax-e
 cdr cdr both-l () (car))))
(#%app p temp6)
#f
p
((stepper-binding-type let-bound))
temp6
((stepper-binding-type let-bound))
(#%app p (#%app ! temp6))
#f
p
((stepper-binding-type let-bound))
(#%app ! temp6)
((stepper-skipto (syntax-e cdr syntax-e cdr car)))
temp6
((stepper-binding-type let-bound))


- using test-proc

(#%app test-proc (lambda (x) (#%app lazy (lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2))))))))

((stepper-skipto (syntax-e cdr syntax-e cdr car)))

(lambda (x) (#%app lazy (lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2)))))))

((stepper-proc-define-name #<syntax:C:\Documents and Settings\Stephen Chang\My Documents\plt\sandbox\lazy-expand-test.rkt:1:9 f>) (stepper-define-type shortened-proc-define))

(#%app lazy (lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2))))))

#f

lazy

((stepper-binding-type non-lexical))

(lambda () (let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2)))))


#f

(let-values (((p) (#%app ! +)) ((temp1) (quote 1)) ((x2) x)) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2))))


((stepper-skip-double-break #t) (stepper-hint #<procedure:unwinder>))

(#%app ! +)
((stepper-skipto (syntax-e cdr syntax-e cdr car)))
+
((stepper-binding-type non-lexical))
(quote 1)
#f
x
((stepper-binding-type lambda-bound))
(if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p))
 (#%app p temp1 x2) (#%app p (#%app ! temp1) (#%app ! x2)))
(((stepper-skipto (syntax-e cdr cdr both-l () (car)))) (stepper-skipto (syntax-e
 cdr cdr both-l () (car))))
(#%app p temp1 x2)
#f
p
((stepper-binding-type let-bound))
temp1
((stepper-binding-type let-bound))
x2
((stepper-binding-type let-bound))
(#%app p (#%app ! temp1) (#%app ! x2))
#f
p
((stepper-binding-type let-bound))
(#%app ! temp1)
((stepper-skipto (syntax-e cdr syntax-e cdr car)))
temp1
((stepper-binding-type let-bound))
(#%app ! x2)
((stepper-skipto (syntax-e cdr syntax-e cdr car)))
x2
((stepper-binding-type let-bound))
(#%app (#%app toplevel-forcer) (let-values (((p) (#%app ! (#%top . f))) ((temp6)
 (quote 10))) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-
procedure? p)) (#%app p temp6) (#%app p (#%app ! temp6)))))
#f
(#%app toplevel-forcer)
#f
toplevel-forcer
((stepper-binding-type non-lexical))
(let-values (((p) (#%app ! (#%top . f))) ((temp6) (quote 10))) (if (if (#%app la
zy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp6)
(#%app p (#%app ! temp6))))
((stepper-skip-double-break #t) (stepper-hint #<procedure:unwinder>))
(#%app ! (#%top . f))
((stepper-skipto (syntax-e cdr syntax-e cdr car)))
(#%top . f)
#f
(quote 10)
#f
(if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p))
 (#%app p temp6) (#%app p (#%app ! temp6)))
(((stepper-skipto (syntax-e cdr cdr both-l () (car)))) (stepper-skipto (syntax-e
 cdr cdr both-l () (car))))
(#%app p temp6)
#f
p
((stepper-binding-type let-bound))
temp6
((stepper-binding-type let-bound))
(#%app p (#%app ! temp6))
#f
p
((stepper-binding-type let-bound))
(#%app ! temp6)
((stepper-skipto (syntax-e cdr syntax-e cdr car)))
temp6
((stepper-binding-type let-bound))





Structure of annotate function:

annotate
    normal-break
    result-exp-break
    result-value-break
    normal-break/values
    exp-finished-break
    double-break
    wcm-pre-break-wrap
    pre-break-wrap
    break-wrap
    double-break-wrap
    return-value-wrap
    normal-break/values-wrap
    top-level-annotate/inner

    annotate/inner
        cond skipto or skipto/discard
             skip-completely
             else let:

        tail-recur
        non-tail-recur
        result-recur
        lambda-body-recur
        make-debug-info-normal
        make-debug-info-app
        outer-wcm-wrap
        wcm-break-wrap
        lambda-clause-abstraction
        outer-lambda-abstraction
        let-abstraction
        if-abstraction
        varref-abraction
        recertifier
        maybe-final-val-wrap

        kernel-syntax-case
            (#%plain-lambda . clause)
            (case-lambda . clauses)
            (if test then else)
            (begin . bodies-stx)
            (begin0 body)
            (begin0 first-body . bodies-stx)
            (let-values . _)
            (letrec-values . _)
            (set! var val)
            (quote _)
            (quote-syntax _)
            (with-continuation-mark key mark body)
            (#%plain-app . terms)
            (#%top . var-stx)
            var-stx
            else
    annotate/top-level
    annotate/module-top-level




Experiment: dump of clause, annotated clause, and free-varrefs in #%plain-lambda case of kernal-syntax in annotate/inner

----- deleted -----
see dump-annotate.rkt-annotateinner-plainlambda-lazy-proc.txt




Experiment: checking out what is happening outer lambda abstraction (only place where closure-table-put! gets called)
 - for both lazy-proc and test-proc, show-lambdas-as-lambdas = #t, procedure-name-info = #f and f (symbol f, not false), and closure-name = #f
 - i'm starting to think the problem is not in the annotation code



Experiment: dump of vals given to recon-value
  - when test-proc is used, body of lambda seems to be processed (evidenced by the 1), but body is not processed when lazy-proc is used (no 1)

----- deleted -----
see dump-reconstruct.rkt-revonvalue-val-closurerecord-lazy-proc.txt



TODO for tomorrow: 
 - look at how lambdas are reconstructed for both lazy-proc and test-proc - start in recon-value function?


--------------------------------------------------------------------------------
----- 7/1/2010 - LAPTOP
--------------------------------------------------------------------------------

Experiment: dump of vars given to stepper/private/reconstruct.rkt::recon-source-expr

 - using test-proc:
lazy + x p temp1 x2 p temp1 x2 p temp6 p temp6 lazy + x p temp1 x2 p temp1 x2 p
temp6 p temp6 lazy + x p temp1 x2 p temp1 x2 lazy + x p temp1 x2 p temp1 x2 lazy
 + x p temp1 x2 p temp1 x2 p temp6 lazy + x p temp1 x2 p temp1 x2 lazy + x p tem
p1 x2 p temp1 x2 lazy + x p temp1 x2 p temp1 x2 temp6 lazy + x p temp1 x2 p temp
1 x2 lazy + x p temp1 x2 p temp1 x2 temp6 lazy + x p temp1 x2 p temp1 x2 lazy +
x p temp1 x2 p temp1 x2 lazy + x p temp1 x2 p temp1 x2 lazy + x p temp1 x2 p tem
p1 x2 lazy + x p temp1 x2 p temp1 x2 lazy + x p temp1 x2 p temp1 x2 lazy + x p t
emp1 x2 p temp1 x2 lazy + x p temp1 x2 p temp1 x2 lazy + x p temp1 x2 p temp1 x2
 lazy + x p temp1 x2 p temp1 x2 lazy + x p temp1 x2 p temp1 x2 lazy + x p temp1
x2 p temp1 x2 p temp1 x2 lazy + x p temp1 x2 p temp1 x2 lazy + x p temp1 x2 p te
mp1 x2 temp1 x2 lazy + x p temp1 x2 p temp1 x2 lazy + x p temp1 x2 p temp1 x2 te
mp1 x2 lazy + x p temp1 x2 p temp1 x2 lazy + x p temp1 x2 p temp1 x2 x2 lazy + x
 p temp1 x2 p temp1 x2 lazy + x p temp1 x2 p temp1 x2 x2 lazy + x p temp1 x2 p t
emp1 x2 lazy + x p temp1 x2 p temp1 x2 lazy + x p temp1 x2 p temp1 x2 lazy + x p
 temp1 x2 p temp1 x2 lazy + x p temp1 x2 p temp1 x2 lazy + x p temp1 x2 p temp1
x2 lazy + x p temp1 x2 p temp1 x2 lazy + x p temp1 x2 p temp1 x2

 - using lazy-proc:
p temp6 p temp6 p temp6 p temp6 p temp6 temp6 temp6 lazy + x p temp1 x2 p temp1
x2 p temp1 x2 temp1 x2 temp1 x2 x2 x2



Experiment: dump of free-vars-captured after annotation in annotate/inner

- with lazy-proc:
(#<syntax:C:\Documents and Settings\Stephen Chang\My Documents\plt\sandbox\lazy-
expand-test.rkt:1:15 +>)
(#<syntax temp1>)
(#<syntax x2>)
(#<syntax:C:\Program Files\Racket-Full-5.0.0.1\collects\lazy\lazy.rkt:326:50 p>
#<syntax temp1> #<syntax x2>)
(#<syntax lazy> #<syntax:C:\Documents and Settings\Stephen Chang\My Documents\pl
t\sandbox\lazy-expand-test.rkt:1:15 +>)
(#<syntax:C:\Documents and Settings\Stephen Chang\My Documents\plt\sandbox\lazy-
expand-test.rkt:3:1 f>)
(#<syntax temp6>)
(#<syntax:C:\Program Files\Racket-Full-5.0.0.1\collects\lazy\lazy.rkt:326:50 p>
#<syntax temp6>)

- with test-proc
(#<syntax:C:\Documents and Settings\Stephen Chang\My Documents\plt\sandbox\lazy-
expand-test.rkt:1:15 +>)
(#<syntax temp1>)
(#<syntax x2>)
(#<syntax:C:\Program Files\Racket-Full-5.0.0.1\collects\lazy\lazy.rkt:326:50 p>
#<syntax temp1> #<syntax x2>)
(#<syntax lazy> #<syntax:C:\Documents and Settings\Stephen Chang\My Documents\pl
t\sandbox\lazy-expand-test.rkt:1:15 +>)
(#<syntax:C:\Documents and Settings\Stephen Chang\My Documents\plt\sandbox\lazy-
expand-test.rkt:3:1 f>)
(#<syntax temp6>)
(#<syntax:C:\Program Files\Racket-Full-5.0.0.1\collects\lazy\lazy.rkt:326:50 p>
#<syntax temp6>)



Experiment: dump of annotate.rkt::top-level-rewrite labels for all variables

 - with test-proc:
#%app non-lexical test-proc non-lexical lambda non-lexical x lambda-bound #%app
non-lexical lazy non-lexical lambda non-lexical p let-bound temp1 let-bound x2 l
et-bound #%app non-lexical ! non-lexical + non-lexical quote non-lexical x lambd
a-bound if non-lexical if non-lexical #%app non-lexical lazy-proc? non-lexical p
 let-bound quote non-lexical #%app non-lexical struct-constructor-procedure? non
-lexical p let-bound #%app non-lexical p let-bound temp1 let-bound x2 let-bound
#%app non-lexical p let-bound #%app non-lexical ! non-lexical temp1 let-bound #%
app non-lexical ! non-lexical x2 let-bound 

 - with lazy-proc:
#%app non-lexical lazy-proc non-lexical lambda non-lexical x lambda-bound #%app
non-lexical lazy non-lexical lambda non-lexical p let-bound temp1 let-bound x2 l
et-bound #%app non-lexical ! non-lexical + non-lexical quote non-lexical x lambd
a-bound if non-lexical if non-lexical #%app non-lexical lazy-proc? non-lexical p
 let-bound quote non-lexical #%app non-lexical struct-constructor-procedure? non
-lexical p let-bound #%app non-lexical p let-bound temp1 let-bound x2 let-bound
#%app non-lexical p let-bound #%app non-lexical ! non-lexical temp1 let-bound #%
app non-lexical ! non-lexical x2 let-bound 








TODO for tomorrow:
 - dump stuff in annotate/inner #%plain-app case and make sure everything is same for test-proc and lazy-proc (I did this already for #%plain-lambda case)





Experiment: dump of terms, annotated terms, and free varrefs for #%plain-app case in annotate/inner (outpouts are identical)

----- deleted -----




Experiment: dump of tail-args in #%plain-app case of annotate/inner (identical)

- using test-proc
all
all
all
(#<syntax arg0-1733>)
(#<syntax:C:\Program Files\Racket-Full-5.0.0.1\collects\lazy\lazy.rkt:329:22 p>
#<syntax temp6> #<syntax arg0-1733> #<syntax arg1-1734>)
(#<syntax:C:\Program Files\Racket-Full-5.0.0.1\collects\lazy\lazy.rkt:329:22 p>
#<syntax temp6> #<syntax arg0-1733> #<syntax arg1-1734>)
all

- using lazy-proc
all
all
all
(#<syntax arg0-1733>)
(#<syntax:C:\Program Files\Racket-Full-5.0.0.1\collects\lazy\lazy.rkt:329:22 p>
#<syntax temp6> #<syntax arg0-1733> #<syntax arg1-1734>)
(#<syntax:C:\Program Files\Racket-Full-5.0.0.1\collects\lazy\lazy.rkt:329:22 p>
#<syntax temp6> #<syntax arg0-1733> #<syntax arg1-1734>)
all



Tentative conclusion - annotated programs are the same whether using lazy-proc or test-proc; reconstruction seems different though

TODO: find where reconstruction differs



reconstruction call graph


files in stepper/private

model.rkt::go::break

     |
     V

reconstruct.rkt::
reconstruct-left-side (normal-break, normal-break/values)
reconstruct-right-side (result-exp-break, result-value-break)
reconstruct-double-break (double-break)

     |
     V

reconstruct-current


     |
     V

(left-side)
recon-value
reconstruct-current::recon

(right-side)
recon-value or recon-source-expr
reconstruct-current::recon

(double-break)
recon-source-expr
reconstruct-current::recon

     |
     V

reconstruct-current::recon calls either
  reconstruct-top-level or
  reconstruct-current::recon-inner

Structure of stepper/private/reconstruct.rkt

recon-value
skip-step?
skip-redex-step?
recon-source-expr
- calls skipto/auto with 'discard and the following transformer fn
    recur
    let-recur
    recon-basic
    recon-let/rec
    recon-lambda-clause
    kernel-syntax-case
        (#%plain-lambda . clause-stx)
        (case-lambda . clauses-stx)
        (if test then else)
        (it test then)
        (begin . bodies)
        (begin0 . bodies)
        (let-values . rest)
        (letrec-values . rest)
        (set! var rhs)
        (quote body)
        (with-continuation-mark . rest)
        (#%plain-app . terms)
        var-stx
        (#%top . var)
reconstruct-completed
reconstruct-top-level
reconstruct-left-side
reconstruct-right-side
reconstruct-double-break
reconstruct-current
    recon-inner
        recon-source-current-marks
        iota
        recon-let
        kernel-syntax-case
            id
            (#%top . id)
            (#%plain-app . terms)
            (if test then else)
            (if test then)
            (begin . terms)
            (begin0 body)
            (begin0 first-body . rest-bodies)
            (let-values . rest)
            (letrec-values . rest)
            (set! var rhs)
    recon



Experiment: dumping closure-records in recon-value in reconstruct.rkt

 - using lazy-proc
 - using test-proc
 - everything seems to be a closure-record (no #f's)

Experiment: dumping base-names of closure-records in recon-value in reconstruct.rkt
 - weird, nothing printed from the true branch of if closure-records, even though in the previous experiment, everythings was showing as a closure-record
    - because closure-record is also a function - needed to use let*
 - trying to print something in the false branch of if closure-records (the rendered)
    - it seems like where test-proc has 1, lazy-proc has lazy.rkt:206:19 (which is the start of the (lambda ...) expr


----- deleted -----
see dump-reconstruct.rkt-revonvalue-val-closurerecord-lazy-proc.txt



Continuation Marks creation call graph:

stepper/private/marks.rkt::

make-debug-info

     |
     V

make-full-mark


     |
     V

make-make-full-mark-varargs

     |
     V

make-full-mark-struct
(define-struct full-mark-struct (source label bindings values))


--------------------------------------------------------------------------------
----- 7/2/2010 - LAPTOP
--------------------------------------------------------------------------------

Experiment: all keys added to closure table

- using lazy-proc:
#<procedure:...ts\lazy\lazy.rkt:207:19>
#<procedure:...ts\lazy\lazy.rkt:339:29>

- using test-proc
#<procedure:...ts\lazy\lazy.rkt:207:19>
#<procedure:...ts\lazy\lazy.rkt:339:29>




lookup-binding call graph:

stepper/private/

reconstruct.rkt::(various functions)

     |
     V

marks.rkt::

lookup-binding.rkt

     |
     V

lookup-first-binding

     |
     V

lookup-all-bindings
(for all marks, returns list of binding-value pairs where binding matches specified binding)
     |
     V

binding-matches
(for one mark, returns list of binding-value pairs where binding matches specified binding)
     |
     V

mark-bindings
(returns list of binding-value pairs)
     |
     V

full-mark-struct-bindings
full-mark-struct-values	



--------------------------------------------------------------------------------
----- 7/3/2010 - LAPTOP
--------------------------------------------------------------------------------


Call Graph - making a mark:

stepper/private/annotate.rkt::annotate:annotate/inner::
make-debug-info-normal (called by normal-bundle, if-abstraction, varref-abstraction, annotate/inner)
make-debug-info-app (outer-lambda-abstraction, annotate/inner)
make-debug-info-let (let-abstraction)
make-debug-info-fake-exp (let-abstraction)
make-debug-info-fake-exp/tail-bound (annotate/inner

     |
     V

stepper/private/marks.rkt::

make-debug-info
  source tail-bound free-vars label lifting

     |
     V

make-full-mark
  source label bindings
(creates syntax of a thunk where body is app:
   ( (make-make-full-mark-varargs source label bindings) 
     (map make-mark-binding-stx bindings) )

     | (when thunk is forced)           |
     V                                  V

make-make-full-mark-varargs      make-mark-binding-stx
  source label bindings
     |
     V

make-full-mark-struct
  source label bindings values
  (values is arg of lambda)



- lambda and lambda wrapped with lazy-proc print as the same!
  (see lazy-proc-print-test.rkt)

- if I apply the following fn to val before giving it to closure-table-lookup (this is in recon-value in reconstruct.rkt), then the function displays properly!

(lambda (val) 
    (if (procedure? val)
        (let ([targ (procedure-extract-target val)])
            (if targ
                targ
                val))
        val))


some various notes:
- equal-hash-code generates hash code for hash table entries
- struct procedures (ie - lambdas wrapped with lazy-proc) return #f when given to struct? - this seems counterintuitive



--------------------------------------------------------------------------------
----- 7/5/2010 - LAPTOP
--------------------------------------------------------------------------------

- download and install Racket Full 5.0.0.6 7/5/2010 build
 - note cant have "info" in any files with .rkt extension? - I had "copy of info.rkt" and it was messing things up so that stepper button wasnt showing up?
 - actually I think the problem was that the copied info.rkt file had a previous date and wasnt getting compiled - need to delete info compiled files (.zo and .dep) to get stepper button to show up
 
 - copied over info.rkt and lazy-tool.rkt to lazy/ and deleted info.zo and info.dep compiled files
 - ran setup-plt -D
 - copied over define-values case in annotate/top-level in annotate.rkt
 - copied over change to ~define and !*app in lazy.rkt
 - copied change to recon-value in reconstruct.rkt so struct wrapped procedures are extracted



Summary of changes to displaying fns defined with define in lazy racket:
 - changed displaying of this program (define (f x) (+ x 1))

from:

(define f (lambda (a1) ...))

to:

(define (f x)
  (lazy (lambda () (+ 1 x))))

- notes about this
 - dont actually need custom unwinder in ~define
 - therefore, dont need to change unwind in macro-unwind.rkt to use unwind instead of recur-on-pieces


Test program expansion:

running:

mzc --expand "\Documents and Settings\Stephen Chang\My Documents\plt\sandbox\lazy-expand-test.rkt"


on: 
(module test lazy  
  (define (f x) (+ 1 x))
  (f 10)
)

gives:

(module test lazy
  (#%plain-module-begin
   (#%require (for-syntax scheme/mzscheme))
   (define-values
    (f)
    (#%app
     lazy-proc
     (lambda (x)
       (#%app
        lazy
        (lambda ()
          (let-values (((p) (#%app ! +)) ((temp1) '1) ((x2) x))
            (if (if (#%app lazy-proc? p)
                  '#t
                  (#%app struct-constructor-procedure? p))
              (#%app p temp1 x2)
              (#%app p (#%app ! temp1) (#%app ! x2)))))))))
   (#%app
    (#%app toplevel-forcer)
    (let-values (((p) (#%app ! f)) ((temp3) '10))
      (if (if (#%app lazy-proc? p) '#t (#%app struct-constructor-procedure? p))
        (#%app p temp3)
        (#%app p (#%app ! temp3)))))))


Stepper steps: see stepper_steps_2010-07-05.txt for test-program1


TODO tomorrow: learn more about what stepper-skipto and skipto/auto are doing

--------------------------------------------------------------------------------
----- 7/6/2010 - LAPTOP
--------------------------------------------------------------------------------

- stepper-recertify in annotate.rkt calls syntax-recertify, which copies certificates from old syntax to a new target syntax


ToDo ToTry: expand beginner program with local - annotation of local may give hints on how to hide defines that are the result of lets in lazy racket?

- tried to annotate the toplevel case in ~!%app in lazy.rkt with 'stepper-skipto (append skipto/cdr skipto/second), but I got an error in find-special-value in reconstruct.rkt
 - hit the error case because the operand of the app wasnt another app
 - find-special-value is called by reset-special-values with name = 'list and valid-args = '(3)
 - somehow this expression (in find-special-value in reconstruct.rkt):
(expand (cons name valid-args)) = (expand (cons 'list '(3)))
expands to: 
(#%app (#%app toplevel-forcer) (let-values (((p) (#%app ! list)) ((temp3) (quote 3))) (if (if (#%app lazy-proc? p) (quote #t) (#%app struct-constructor-procedure? p)) (#%app p temp3) (#%app p (#%app ! temp3)))))
    - ok I guess this makes sense, it's the lazy expansion of (list 3)

 - reset-special-values is called in break in model.rkt as part of the "iter" lambda parameter to program-expander (break is local fn in go in model.rkt and program-expander is parameter to go)
 - reset-special-values sets two global variables: special-list-value and special-cons-value

Solution: added extra case to find-special-value (in reconstruct.rkt) to handle lazy-racket case and the annotation worked!!!
 - I needed to get rid of the double-break annotation in !*app, otherwise the first step would not show up at all




Call Graph: Stepper

stepper/

stepper-tool.rkt::stepper-unit-frame-mixin::stepper-button-callback

     |
     V

view-controller.rkt::go
 - called with current frame and stepper-tool.rkt::stepper-unit-frame-mixin::program-expander params

     |
     V

private/model.rkt::go
 - called with view-controller.rkt::go::program-expander-prime as param, which just wraps init param of stepper-tool.rkt::stepper-unit-frame-mixin::program-expander with custodian (iter param is not changed)

     |
     V

view-controller.rkt::go::program-expander-prime

     |
     V

stepper-tool.rkt::stepper-unit-frame-mixin::program-expander




Control Flow: iter parameter of stepper-tool.rkt::stepper-unit-frame-mixin::program-expander:
(created by stepper/private/model.rkt::go)

(lambda (expanded continue-thunk)
     (r:reset-special-values)
     (if (eof-object? expanded)
         (begin
           (receive-result (make-finished-stepping)))
         (step-through-expression expanded continue-thunk)))

- follows call graph above until given as param to:

drscheme:eval:expand-program

from racket help:

The first argument to iter is the expanded program (represented as syntax) or eof. The iter argument is called for each expression in the expanded program and once more with eof, unless an error is raised during expansion. It is called from the user’s thread. If an exception is raised during expansion of the user’s program, iter is not called. Consider setting the exception-handler during init  to handle this situation.

The second argument to iter is a thunk that continues expanding the rest of the contents of the definitions window. If the first argument to iter was eof, this argument is just the primitive void.